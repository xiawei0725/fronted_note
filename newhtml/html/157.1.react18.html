<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>前端笔记</title>
    <link rel="stylesheet" type="text/css" href="./assets/css/main.css">
    <link rel="stylesheet" href="./assets/css/bootstrapmin_1645176572503.css" >
    <style>
        .page-toc > ul .red {
            background: #f3f3f3;
            z-index: 1;
            border-left: 3px solid #009a61;
            -webkit-transition: all .2s ease;
            transition: all .2s ease;
            color: #000
        }
    </style>
</head>
<body>
<div class="nav">
    <div class="logo">
        
                    前端笔记
                        
                        </div>
                        <ul><li><a href="./index.html">0.api</a></li><li><a href="../html/0.Async.html">0.Async</a></li><li><a href="../html/0.module.html">0.module</a></li><li><a href="../html/1.ES2015.html">1.ES2015</a></li><li><a href="../html/2.Promise.html">2.Promise</a></li><li><a href="../html/3.Node.html">3.Node</a></li><li><a href="../html/4.NodeInstall.html">4.NodeInstall</a></li><li><a href="../html/5.REPL.html">5.REPL</a></li><li><a href="../html/6.NodeCore.html">6.NodeCore</a></li><li><a href="../html/7.module&NPM.html">7.module&NPM</a></li><li><a href="../html/8.Encoding.html">8.Encoding</a></li><li><a href="../html/9.Buffer.html">9.Buffer</a></li><li><a href="../html/10.fs.html">10.fs</a></li><li><a href="../html/11.Stream-1.html">11.Stream-1</a></li><li><a href="../html/11.Stream-2.html">11.Stream-2</a></li><li><a href="../html/11.Stream-3.html">11.Stream-3</a></li><li><a href="../html/11.Stream-4.html">11.Stream-4</a></li><li><a href="../html/12-Network-2.html">12-Network-2</a></li><li><a href="../html/12.NetWork-3.html">12.NetWork-3</a></li><li><a href="../html/12.Network-1.html">12.Network-1</a></li><li><a href="../html/13.tcp.html">13.tcp</a></li><li><a href="../html/14.http-1.html">14.http-1</a></li><li><a href="../html/14.http-2.html">14.http-2</a></li><li><a href="../html/15.compress.html">15.compress</a></li><li><a href="../html/16.crypto.html">16.crypto</a></li><li><a href="../html/17.process.html">17.process</a></li><li><a href="../html/18.yargs.html">18.yargs</a></li><li><a href="../html/19.cache.html">19.cache</a></li><li><a href="../html/20.action.html">20.action</a></li><li><a href="../html/21.https.html">21.https</a></li><li><a href="../html/22.cookie.html">22.cookie</a></li><li><a href="../html/23.session.html">23.session</a></li><li><a href="../html/24.express-1.html">24.express-1</a></li><li><a href="../html/24.express-2.html">24.express-2</a></li><li><a href="../html/24.express-3.html">24.express-3</a></li><li><a href="../html/24.express-4.html">24.express-4</a></li><li><a href="../html/25.koa-1.html">25.koa-1</a></li><li><a href="../html/26.webpack-1-basic.html">26.webpack-1-basic</a></li><li><a href="../html/26.webpack-2-optimize.html">26.webpack-2-optimize</a></li><li><a href="../html/26.webpack-3-file.html">26.webpack-3-file</a></li><li><a href="../html/26.webpack-4.tapable.html">26.webpack-4.tapable</a></li><li><a href="../html/26.webpack-5-AST.html">26.webpack-5-AST</a></li><li><a href="../html/26.webpack-6-sources.html">26.webpack-6-sources</a></li><li><a href="../html/26.webpack-7-loader.html">26.webpack-7-loader</a></li><li><a href="../html/26.webpack-8-plugin.html">26.webpack-8-plugin</a></li><li><a href="../html/26.webpack-9-hand.html">26.webpack-9-hand</a></li><li><a href="../html/26.webpack-10-prepare.html">26.webpack-10-prepare</a></li><li><a href="../html/28.redux.html">28.redux</a></li><li><a href="../html/28.redux-jwt-back.html">28.redux-jwt-back</a></li><li><a href="../html/28.redux-jwt-front.html">28.redux-jwt-front</a></li><li><a href="../html/29.mongodb-1.html">29.mongodb-1</a></li><li><a href="../html/29.mongodb-2.html">29.mongodb-2</a></li><li><a href="../html/29.mongodb-3.html">29.mongodb-3</a></li><li><a href="../html/29.mongodb-4.html">29.mongodb-4</a></li><li><a href="../html/29.mongodb-5.html">29.mongodb-5</a></li><li><a href="../html/29.mongodb-6.html">29.mongodb-6</a></li><li><a href="../html/30.cms-1-mysql.html">30.cms-1-mysql</a></li><li><a href="../html/30.cms-2-mysql.html">30.cms-2-mysql</a></li><li><a href="../html/30.cms-3-mysql.html">30.cms-3-mysql</a></li><li><a href="../html/30.cms-4-nunjucks.html">30.cms-4-nunjucks</a></li><li><a href="../html/30.cms-5-mock.html">30.cms-5-mock</a></li><li><a href="../html/30.cms-6-egg.html">30.cms-6-egg</a></li><li><a href="../html/30.cms-7-api.html">30.cms-7-api</a></li><li><a href="../html/30.cms-8-roadhog.html">30.cms-8-roadhog</a></li><li><a href="../html/30.cms-9-yaml.html">30.cms-9-yaml</a></li><li><a href="../html/30.cms-10-umi.html">30.cms-10-umi</a></li><li><a href="../html/30.cms-12-dva.html">30.cms-12-dva</a></li><li><a href="../html/30.cms-13-dva-ant.html">30.cms-13-dva-ant</a></li><li><a href="../html/30.cms-14-front.html">30.cms-14-front</a></li><li><a href="../html/30.cms-15-deploy.html">30.cms-15-deploy</a></li><li><a href="../html/31.dva.html">31.dva</a></li><li><a href="../html/31.cms-13-dva-antdesign.html">31.cms-13-dva-antdesign</a></li><li><a href="../html/33.redis.html">33.redis</a></li><li><a href="../html/34.unittest.html">34.unittest</a></li><li><a href="../html/35.jwt.html">35.jwt</a></li><li><a href="../html/36.websocket-1.html">36.websocket-1</a></li><li><a href="../html/36.websocket-2.html">36.websocket-2</a></li><li><a href="../html/38.chat-api-1.html">38.chat-api-1</a></li><li><a href="../html/38.chat-api-2.html">38.chat-api-2</a></li><li><a href="../html/38.chat-3.html">38.chat-3</a></li><li><a href="../html/38.chat-api-3.html">38.chat-api-3</a></li><li><a href="../html/38.chat.html">38.chat</a></li><li><a href="../html/38.chat2.html">38.chat2</a></li><li><a href="../html/38.chat2.html">38.chat2</a></li><li><a href="../html/39.crawl-0.html">39.crawl-0</a></li><li><a href="../html/39.crawl-1.html">39.crawl-1</a></li><li><a href="../html/39.crawl-2.html">39.crawl-2</a></li><li><a href="../html/40.deploy.html">40.deploy</a></li><li><a href="../html/41.safe.html">41.safe</a></li><li><a href="../html/42.test.html">42.test</a></li><li><a href="../html/43.nginx.html">43.nginx</a></li><li><a href="../html/44.enzyme.html">44.enzyme</a></li><li><a href="../html/45.docker.html">45.docker</a></li><li><a href="../html/46.elastic.html">46.elastic</a></li><li><a href="../html/47.oauth.html">47.oauth</a></li><li><a href="../html/48.wxpay.html">48.wxpay</a></li><li><a href="../html/index.html">index</a></li><li><a href="../html/52.UML.html">52.UML</a></li><li><a href="../html/53.design.html">53.design</a></li><li><a href="../html/index.html">index</a></li><li><a href="../html/54.linux.html">54.linux</a></li><li><a href="../html/57.ts.html">57.ts</a></li><li><a href="../html/56.react-ssr.html">56.react-ssr</a></li><li><a href="../html/58.ts_react.html">58.ts_react</a></li><li><a href="../html/59.ketang.html">59.ketang</a></li><li><a href="../html/59.ketang2.html">59.ketang2</a></li><li><a href="../html/61.1.devops-linux.html">61.1.devops-linux</a></li><li><a href="../html/61.2.devops-vi.html">61.2.devops-vi</a></li><li><a href="../html/61.3.devops-user.html">61.3.devops-user</a></li><li><a href="../html/61.4.devops-auth.html">61.4.devops-auth</a></li><li><a href="../html/61.5.devops-shell.html">61.5.devops-shell</a></li><li><a href="../html/61.6.devops-install.html">61.6.devops-install</a></li><li><a href="../html/61.7.devops-system.html">61.7.devops-system</a></li><li><a href="../html/61.8.devops-service.html">61.8.devops-service</a></li><li><a href="../html/61.9.devops-network.html">61.9.devops-network</a></li><li><a href="../html/61.10.devops-nginx.html">61.10.devops-nginx</a></li><li><a href="../html/61.11.devops-docker.html">61.11.devops-docker</a></li><li><a href="../html/61.12.devops-jekins.html">61.12.devops-jekins</a></li><li><a href="../html/61.13.devops-groovy.html">61.13.devops-groovy</a></li><li><a href="../html/61.14.devops-php.html">61.14.devops-php</a></li><li><a href="../html/61.15.devops-java.html">61.15.devops-java</a></li><li><a href="../html/61.16.devops-node.html">61.16.devops-node</a></li><li><a href="../html/61.17.devops-k8s.html">61.17.devops-k8s</a></li><li><a href="../html/62.1.react-basic.html">62.1.react-basic</a></li><li><a href="../html/62.2.react-state.html">62.2.react-state</a></li><li><a href="../html/62.3.react-high.html">62.3.react-high</a></li><li><a href="../html/62.4.react-optimize.html">62.4.react-optimize</a></li><li><a href="../html/62.5.react-hooks.html">62.5.react-hooks</a></li><li><a href="../html/62.6.react-immutable.html">62.6.react-immutable</a></li><li><a href="../html/62.7.react-mobx.html">62.7.react-mobx</a></li><li><a href="../html/62.8.react-source.html">62.8.react-source</a></li><li><a href="../html/63.1.redux.html">63.1.redux</a></li><li><a href="../html/63.2.redux-middleware.html">63.2.redux-middleware</a></li><li><a href="../html/63.3.redux-hooks.html">63.3.redux-hooks</a></li><li><a href="../html/63.4.redux-saga.html">63.4.redux-saga</a></li><li><a href="../html/63.5.redux-saga-hand.html">63.5.redux-saga-hand</a></li><li><a href="../html/64.1.router.html">64.1.router</a></li><li><a href="../html/64.2.router-connected.html">64.2.router-connected</a></li><li><a href="../html/65.1.typescript.html">65.1.typescript</a></li><li><a href="../html/65.2.typescript.html">65.2.typescript</a></li><li><a href="../html/65.3.typescript.html">65.3.typescript</a></li><li><a href="../html/65.4.antd.html">65.4.antd</a></li><li><a href="../html/65.4.definition.html">65.4.definition</a></li><li><a href="../html/66-1.vue-base.html">66-1.vue-base</a></li><li><a href="../html/66-2.vue-component.html">66-2.vue-component</a></li><li><a href="../html/66-3.vue-cli3.0.html">66-3.vue-cli3.0</a></li><li><a href="../html/66-4.$message组件.html">66-4.$message组件</a></li><li><a href="../html/66-5.Form组件.html">66-5.Form组件</a></li><li><a href="../html/66-6.tree.html">66-6.tree</a></li><li><a href="../html/66-7.vue-router-apply.html">66-7.vue-router-apply</a></li><li><a href="../html/66-8.axios-apply.html">66-8.axios-apply</a></li><li><a href="../html/66-9.vuex-apply.html">66-9.vuex-apply</a></li><li><a href="../html/66-10.jwt-vue.html">66-10.jwt-vue</a></li><li><a href="../html/66-11.vue-ssr.html">66-11.vue-ssr</a></li><li><a href="../html/66-12.nuxt-apply.html">66-12.nuxt-apply</a></li><li><a href="../html/66-13.pwa.html">66-13.pwa</a></li><li><a href="../html/66-14.vue单元测试.html">66-14.vue单元测试</a></li><li><a href="../html/66-15.权限校验.html">66-15.权限校验</a></li><li><a href="../html/67-1-network.html">67-1-network</a></li><li><a href="../html/68-2-wireshark.html">68-2-wireshark</a></li><li><a href="../html/7.npm2.html">7.npm2</a></li><li><a href="../html/69-hooks.html">69-hooks</a></li><li><a href="../html/70-deploy.html">70-deploy</a></li><li><a href="../html/71-hmr.html">71-hmr</a></li><li><a href="../html/72.deploy.html">72.deploy</a></li><li><a href="../html/73.import.html">73.import</a></li><li><a href="../html/74.mobile.html">74.mobile</a></li><li><a href="../html/75.webpack-1.文件分析.html">75.webpack-1.文件分析</a></li><li><a href="../html/75.webpack-2.loader.html">75.webpack-2.loader</a></li><li><a href="../html/75.webpack-3.源码流程.html">75.webpack-3.源码流程</a></li><li><a href="../html/75.webpack-4.tapable.html">75.webpack-4.tapable</a></li><li><a href="../html/75.webpack-5.prepare.html">75.webpack-5.prepare</a></li><li><a href="../html/75.webpack-6.resolve.html">75.webpack-6.resolve</a></li><li><a href="../html/75.webpack-7.loader.html">75.webpack-7.loader</a></li><li><a href="../html/75.webpack-8.module.html">75.webpack-8.module</a></li><li><a href="../html/75.webpack-9.chunk.html">75.webpack-9.chunk</a></li><li><a href="../html/75.webpack-10.asset.html">75.webpack-10.asset</a></li><li><a href="../html/75.webpack-11.实现.html">75.webpack-11.实现</a></li><li><a href="../html/76.react_optimize.html">76.react_optimize</a></li><li><a href="../html/77.ts_ketang_back.html">77.ts_ketang_back</a></li><li><a href="../html/77.ts_ketang_front.html">77.ts_ketang_front</a></li><li><a href="../html/78.vue-domdiff.html">78.vue-domdiff</a></li><li><a href="../html/79.grammar.html">79.grammar</a></li><li><a href="../html/80.tree.html">80.tree</a></li><li><a href="../html/81.axios.html">81.axios</a></li><li><a href="../html/82.1.react.html">82.1.react</a></li><li><a href="../html/82.2.react-high.html">82.2.react-high</a></li><li><a href="../html/82.3.react-router.html">82.3.react-router</a></li><li><a href="../html/82.4.redux.html">82.4.redux</a></li><li><a href="../html/82.5.redux_middleware.html">82.5.redux_middleware</a></li><li><a href="../html/82.6.connected.html">82.6.connected</a></li><li><a href="../html/82.7.saga.html">82.7.saga</a></li><li><a href="../html/82.8.dva.html">82.8.dva</a></li><li><a href="../html/82.8.dva-source.html">82.8.dva-source</a></li><li><a href="../html/82.9.roadhog.html">82.9.roadhog</a></li><li><a href="../html/82.10.umi.html">82.10.umi</a></li><li><a href="../html/82.11.antdesign.html">82.11.antdesign</a></li><li><a href="../html/82.12.ketang-front.html">82.12.ketang-front</a></li><li><a href="../html/82.12.ketang-back.html">82.12.ketang-back</a></li><li><a href="../html/83.upload.html">83.upload</a></li><li><a href="../html/84.graphql.html">84.graphql</a></li><li><a href="../html/85.antpro.html">85.antpro</a></li><li><a href="../html/86.1.uml.html">86.1.uml</a></li><li><a href="../html/86.2.design.html">86.2.design</a></li><li><a href="../html/87.postcss.html">87.postcss</a></li><li><a href="../html/88.react16-1.html">88.react16-1</a></li><li><a href="../html/89.nextjs.html">89.nextjs</a></li><li><a href="../html/90.react-test.html">90.react-test</a></li><li><a href="../html/91.react-ts.html">91.react-ts</a></li><li><a href="../html/92.rbac.html">92.rbac</a></li><li><a href="../html/93.tsnode.html">93.tsnode</a></li><li><a href="../html/94.1.JavaScript.html">94.1.JavaScript</a></li><li><a href="../html/94.2.JavaScript.html">94.2.JavaScript</a></li><li><a href="../html/94.3.MODULE.html">94.3.MODULE</a></li><li><a href="../html/94.4.EventLoop.html">94.4.EventLoop</a></li><li><a href="../html/94.5.文件上传.html">94.5.文件上传</a></li><li><a href="../html/94.6.https.html">94.6.https</a></li><li><a href="../html/94.7. nginx.html">94.7. nginx</a></li><li><a href="../html/95.1. react.html">95.1. react</a></li><li><a href="../html/95.2.react.html">95.2.react</a></li><li><a href="../html/96.1.react16.html">96.1.react16</a></li><li><a href="../html/96.2.fiber.html">96.2.fiber</a></li><li><a href="../html/96.3.fiber.html">96.3.fiber</a></li><li><a href="../html/97.serverless.html">97.serverless</a></li><li><a href="../html/98.websocket.html">98.websocket</a></li><li><a href="../html/100.1.react-basic.html">100.1.react-basic</a></li><li><a href="../html/101.1.monitor.html">101.1.monitor</a></li><li><a href="../html/101.2.monitor.html">101.2.monitor</a></li><li><a href="../html/102.java.html">102.java</a></li><li><a href="../html/103.1.webpack-usage.html">103.1.webpack-usage</a></li><li><a href="../html/103.2.webpack-bundle.html">103.2.webpack-bundle</a></li><li><a href="../html/103.3.webpack-ast.html">103.3.webpack-ast</a></li><li><a href="../html/103.4.webpack-flow.html">103.4.webpack-flow</a></li><li><a href="../html/103.5.webpack-loader.html">103.5.webpack-loader</a></li><li><a href="../html/103.6.webpack-tapable.html">103.6.webpack-tapable</a></li><li><a href="../html/103.7.webpack-plugin.html">103.7.webpack-plugin</a></li><li><a href="../html/103.8.webpack-optimize1.html">103.8.webpack-optimize1</a></li><li><a href="../html/103.9.webpack-optimize2.html">103.9.webpack-optimize2</a></li><li><a href="../html/103.10.webpack-hand.html">103.10.webpack-hand</a></li><li><a href="../html/103.11.webpack-hmr.html">103.11.webpack-hmr</a></li><li><a href="../html/103.11.webpack5.html">103.11.webpack5</a></li><li><a href="../html/103.13.splitChunks.html">103.13.splitChunks</a></li><li><a href="../html/103.14.webpack-sourcemap.html">103.14.webpack-sourcemap</a></li><li><a href="../html/103.15.webpack-compiler1.html">103.15.webpack-compiler1</a></li><li><a href="../html/103.15.webpack-compiler2.html">103.15.webpack-compiler2</a></li><li><a href="../html/103.16.rollup.1.html">103.16.rollup.1</a></li><li><a href="../html/103.16.rollup.2.html">103.16.rollup.2</a></li><li><a href="../html/103.16.rollup.3.html">103.16.rollup.3</a></li><li><a href="../html/103.16.vite.basic.html">103.16.vite.basic</a></li><li><a href="../html/103.16.vite.source.html">103.16.vite.source</a></li><li><a href="../html/103.16.vite.plugin.html">103.16.vite.plugin</a></li><li><a href="../html/103.16.vite.1.html">103.16.vite.1</a></li><li><a href="../html/103.16.vite.2.html">103.16.vite.2</a></li><li><a href="../html/103.17.polyfill.html">103.17.polyfill</a></li><li><a href="../html/104.1.binary.html">104.1.binary</a></li><li><a href="../html/104.2.binary.html">104.2.binary</a></li><li><a href="../html/105.skeleton.html">105.skeleton</a></li><li><a href="../html/106.1.react.html">106.1.react</a></li><li><a href="../html/106.2.react_hooks.html">106.2.react_hooks</a></li><li><a href="../html/106.3.react_router.html">106.3.react_router</a></li><li><a href="../html/106.4.redux.html">106.4.redux</a></li><li><a href="../html/106.5.redux_middleware.html">106.5.redux_middleware</a></li><li><a href="../html/106.6.connected-react-router.html">106.6.connected-react-router</a></li><li><a href="../html/106.6.redux-first-history.html">106.6.redux-first-history</a></li><li><a href="../html/106.7.redux-saga.html">106.7.redux-saga</a></li><li><a href="../html/106.8.dva.html">106.8.dva</a></li><li><a href="../html/106.9.umi.html">106.9.umi</a></li><li><a href="../html/106.10.ketang.html">106.10.ketang</a></li><li><a href="../html/106.11.antdesign.html">106.11.antdesign</a></li><li><a href="../html/106.12.antpro.html">106.12.antpro</a></li><li><a href="../html/106.13.router-6.html">106.13.router-6</a></li><li><a href="../html/106.14.ssr.html">106.14.ssr</a></li><li><a href="../html/106.15.nextjs.html">106.15.nextjs</a></li><li><a href="../html/106.16.1.cms.html">106.16.1.cms</a></li><li><a href="../html/106.16.2.cms.html">106.16.2.cms</a></li><li><a href="../html/106.16.3.cms.html">106.16.3.cms</a></li><li><a href="../html/106.16.4.cms.html">106.16.4.cms</a></li><li><a href="../html/106.16.mobx.html">106.16.mobx</a></li><li><a href="../html/106.17.fomily.html">106.17.fomily</a></li><li><a href="../html/107.fiber.html">107.fiber</a></li><li><a href="../html/108.http.html">108.http</a></li><li><a href="../html/109.1.webpack_usage.html">109.1.webpack_usage</a></li><li><a href="../html/109.2.webpack_source.html">109.2.webpack_source</a></li><li><a href="../html/109.3.dll.html">109.3.dll</a></li><li><a href="../html/110.nest.js.html">110.nest.js</a></li><li><a href="../html/111.xstate.html">111.xstate</a></li><li><a href="../html/112.Form.html">112.Form</a></li><li><a href="../html/113.redux-saga.html">113.redux-saga</a></li><li><a href="../html/114.react+typescript.html">114.react+typescript</a></li><li><a href="../html/115.immer.html">115.immer</a></li><li><a href="../html/116.pro5.html">116.pro5</a></li><li><a href="../html/117.css-loader.html">117.css-loader</a></li><li><a href="../html/118.1.umi-core.html">118.1.umi-core</a></li><li><a href="../html/119.2.module-federation.html">119.2.module-federation</a></li><li><a href="../html/119.1.module-federation.html">119.1.module-federation</a></li><li><a href="../html/120.create-react-app.html">120.create-react-app</a></li><li><a href="../html/121.react-scripts.html">121.react-scripts</a></li><li><a href="../html/122.react-optimize.html">122.react-optimize</a></li><li><a href="../html/123.jsx-runtime.html">123.jsx-runtime</a></li><li><a href="../html/124.next.js.html">124.next.js</a></li><li><a href="../html/125.1.linux.html">125.1.linux</a></li><li><a href="../html/125.2.linux-vi.html">125.2.linux-vi</a></li><li><a href="../html/125.3.linux-user.html">125.3.linux-user</a></li><li><a href="../html/125.4.linux-auth.html">125.4.linux-auth</a></li><li><a href="../html/125.5.linux-shell.html">125.5.linux-shell</a></li><li><a href="../html/125.6.linux-install.html">125.6.linux-install</a></li><li><a href="../html/125.7.linux-system.html">125.7.linux-system</a></li><li><a href="../html/125.8.linux-service.html">125.8.linux-service</a></li><li><a href="../html/125.9.linux-network.html">125.9.linux-network</a></li><li><a href="../html/125.10.nginx.html">125.10.nginx</a></li><li><a href="../html/125.11.docker.html">125.11.docker</a></li><li><a href="../html/125.12.ci.html">125.12.ci</a></li><li><a href="../html/125.13.k8s.html">125.13.k8s</a></li><li><a href="../html/125.14.k8s.html">125.14.k8s</a></li><li><a href="../html/125.15.k8s.html">125.15.k8s</a></li><li><a href="../html/125.16.k8s.html">125.16.k8s</a></li><li><a href="../html/126.11.react-1.html">126.11.react-1</a></li><li><a href="../html/126.12.react-2.html">126.12.react-2</a></li><li><a href="../html/126.12.react-3.html">126.12.react-3</a></li><li><a href="../html/126.12.react-4.html">126.12.react-4</a></li><li><a href="../html/126.12.react-5.html">126.12.react-5</a></li><li><a href="../html/126.12.react-6.html">126.12.react-6</a></li><li><a href="../html/126.12.react-7.html">126.12.react-7</a></li><li><a href="../html/126.12.react-8.html">126.12.react-8</a></li><li><a href="../html/127.frontend.html">127.frontend</a></li><li><a href="../html/128.rollup.html">128.rollup</a></li><li><a href="../html/129.px2rem-loader.html">129.px2rem-loader</a></li><li><a href="../html/130.health.html">130.health</a></li><li><a href="../html/131.hooks.html">131.hooks</a></li><li><a href="../html/132.keepalive.html">132.keepalive</a></li><li><a href="../html/133.vue-cli.html">133.vue-cli</a></li><li><a href="../html/134.react18.html">134.react18</a></li><li><a href="../html/134.2.react18.html">134.2.react18</a></li><li><a href="../html/134.3.react18.html">134.3.react18</a></li><li><a href="../html/135.function.html">135.function</a></li><li><a href="../html/136.toolkit.html">136.toolkit</a></li><li><a href="../html/137.lerna.html">137.lerna</a></li><li><a href="../html/138.create-vite.html">138.create-vite</a></li><li><a href="../html/139.cli.html">139.cli</a></li><li><a href="../html/140.antd.html">140.antd</a></li><li><a href="../html/141.react-dnd.html">141.react-dnd</a></li><li><a href="../html/142.1.link.html">142.1.link</a></li><li><a href="../html/143.1.gulp.html">143.1.gulp</a></li><li><a href="../html/143.2.stream.html">143.2.stream</a></li><li><a href="../html/143.3.gulp.html">143.3.gulp</a></li><li><a href="../html/144.1.closure.html">144.1.closure</a></li><li><a href="../html/144.2.v8.html">144.2.v8</a></li><li><a href="../html/144.3.gc.html">144.3.gc</a></li><li><a href="../html/145.react-router-v6.html">145.react-router-v6</a></li><li><a href="../html/146.browser.html">146.browser</a></li><li><a href="../html/147.lighthouse.html">147.lighthouse</a></li><li><a href="../html/148.1.basic.html">148.1.basic</a></li><li><a href="../html/148.2.basic .html">148.2.basic </a></li><li><a href="../html/148.3.basic.html">148.3.basic</a></li><li><a href="../html/148.4.basic.html">148.4.basic</a></li><li><a href="../html/148.5.basic.html">148.5.basic</a></li><li><a href="../html/149.1.vite.html">149.1.vite</a></li><li><a href="../html/149.2.vite.html">149.2.vite</a></li><li><a href="../html/149.3.vite.html">149.3.vite</a></li><li><a href="../html/149.4.vite.html">149.4.vite</a></li><li><a href="../html/150.react-window.html">150.react-window</a></li><li><a href="../html/151.react-query.html">151.react-query</a></li><li><a href="../html/152.useRequest.html">152.useRequest</a></li><li><a href="../html/153.transition.html">153.transition</a></li><li><a href="../html/154.emotion.html">154.emotion</a></li><li><a href="../html/155.1.formily.html">155.1.formily</a></li><li><a href="../html/155.2.formily.html">155.2.formily</a></li><li><a href="../html/155.3.formily.html">155.3.formily</a></li><li><a href="../html/155.3.1.mobx.usage.html">155.3.1.mobx.usage</a></li><li><a href="../html/155.3.2.mobx.source.html">155.3.2.mobx.source</a></li><li><a href="../html/156.vue-loader.html">156.vue-loader</a></li><li><a href="../html/103.11.mf.html">103.11.mf</a></li><li class="active"><a href="../html/157.1.react18.html">157.1.react18</a></li><li><a href="../html/158.umi4.html">158.umi4</a></li><li><a href="../html/159.rxjs.html">159.rxjs</a></li><li><a href="../html/159.rxjs2.html">159.rxjs2</a></li><li><a href="../html/160.bff.html">160.bff</a></li></ul>                        </div>

                        
<div class="warpper">
    <div class="page-toc">
        <ul><li><a href="#t01.React 前置知识">1.React 前置知识</a><ul><li><a href="#t11.1 React 是什么?">1.1 React 是什么?</a></li><li><a href="#t21.2 JSX 是什么">1.2 JSX 是什么</a><ul><li><a href="#t31.2.1 旧转换">1.2.1 旧转换</a><ul><li><a href="#t41.2.1.1 jsx.js">1.2.1.1 jsx.js</a></li><li><a href="#t51.2.1.2 转译结果">1.2.1.2 转译结果</a></li></ul></li><li><a href="#t61.2.2 新转换">1.2.2 新转换</a><ul><li><a href="#t71.2.2.1 jsx.js">1.2.2.1 jsx.js</a></li><li><a href="#t81.2.2.2 转译结果">1.2.2.2 转译结果</a></li></ul></li></ul></li><li><a href="#t91.3 Virtual DOM">1.3 Virtual DOM</a></li><li><a href="#t101.4 链表">1.4 链表</a><ul><li><a href="#t111.4.1 链表分类">1.4.1 链表分类</a><ul><li><a href="#t121.4.1.1 单向链表">1.4.1.1 单向链表</a></li><li><a href="#t131.4.1.2 双向链表">1.4.1.2 双向链表</a></li><li><a href="#t141.4.1.3 循环链表">1.4.1.3 循环链表</a></li><li><a href="#t151.4.1.4 示例">1.4.1.4 示例</a></li></ul></li></ul></li><li><a href="#t161.5 fiber">1.5 fiber</a><ul><li><a href="#t171.5.1 性能瓶颈">1.5.1 性能瓶颈</a></li><li><a href="#t181.5.2 屏幕刷新率">1.5.2 屏幕刷新率</a></li><li><a href="#t191.5.3 帧">1.5.3 帧</a></li><li><a href="#t201.5.4 requestIdleCallback">1.5.4 requestIdleCallback</a></li><li><a href="#t211.5.5 fiber">1.5.5 fiber</a><ul><li><a href="#t221.5.5.1 Fiber 是一个执行单元">1.5.5.1 Fiber 是一个执行单元</a></li><li><a href="#t231.5.5.2 Fiber 是一种数据结构">1.5.5.2 Fiber 是一种数据结构</a></li><li><a href="#t241.5.5.3 递归构建 fiber 树">1.5.5.3 递归构建 fiber 树</a></li></ul></li></ul></li><li><a href="#t251.6 树的遍历">1.6 树的遍历</a><ul><li><a href="#t261.6.1 深度优先(DFS)">1.6.1 深度优先(DFS)</a></li><li><a href="#t271.6.2 广度优先(BFS)">1.6.2 广度优先(BFS)</a></li><li><a href="#t281.6.3 栈">1.6.3 栈</a></li></ul></li><li><a href="#t291.7 位运算">1.7 位运算</a><ul><li><a href="#t301.7.1 比特">1.7.1 比特</a></li><li><a href="#t311.7.2 位运算">1.7.2 位运算</a></li><li><a href="#t321.7.3 使用">1.7.3 使用</a></li></ul></li><li><a href="#t331.8 事件">1.8 事件</a><ul><li><a href="#t341.8.1 DOM 事件流">1.8.1 DOM 事件流</a></li><li><a href="#t351.8.2 事件捕获">1.8.2 事件捕获</a></li><li><a href="#t361.8.3 目标阶段">1.8.3 目标阶段</a></li><li><a href="#t371.8.4 事件冒泡">1.8.4 事件冒泡</a></li><li><a href="#t381.8.5 addEventListener">1.8.5 addEventListener</a></li><li><a href="#t391.8.6 阻止冒泡">1.8.6 阻止冒泡</a></li><li><a href="#t401.8.7 阻止默认行为">1.8.7 阻止默认行为</a></li><li><a href="#t411.8.8 事件代理">1.8.8 事件代理</a></li><li><a href="#t421.8.9 事件系统">1.8.9 事件系统</a><ul><li><a href="#t431.8.10.1 使用">1.8.10.1 使用</a></li><li><a href="#t441.8.10.2 简易实现">1.8.10.2 简易实现</a></li></ul></li></ul></li><li><a href="#t451.9 最小堆">1.9 最小堆</a><ul><li><a href="#t461.9.1 二叉树">1.9.1 二叉树</a></li><li><a href="#t471.9.2 满二叉树">1.9.2 满二叉树</a></li><li><a href="#t481.9.3 完全二叉树">1.9.3 完全二叉树</a></li><li><a href="#t491.9.4 最小堆">1.9.4 最小堆</a></li><li><a href="#t501.9.5 SchedulerMinHeap.js">1.9.5 SchedulerMinHeap.js</a></li></ul></li><li><a href="#t511.10 MessageChannel">1.10 MessageChannel</a></li><li><a href="#t521.11 二进制">1.11 二进制</a><ul><li><a href="#t531.11.1 ES5规范">1.11.1 ES5规范</a></li><li><a href="#t541.11.2 真值">1.11.2 真值</a></li><li><a href="#t551.11.3 原码">1.11.3 原码</a></li><li><a href="#t561.11.4 反码">1.11.4 反码</a></li><li><a href="#t571.11.5 补码">1.11.5 补码</a></li><li><a href="#t581.11.6 二进制数整数">1.11.6 二进制数整数</a></li><li><a href="#t591.11.7 ~非">1.11.7 ~非</a></li><li><a href="#t601.11.8 getHighestPriorityLane">1.11.8 getHighestPriorityLane</a></li><li><a href="#t611.11.9 左移">1.11.9 左移</a></li><li><a href="#t621.11.10 >> 有符号右移">1.11.10 >> 有符号右移</a></li><li><a href="#t631.11.11 >>>无符号右移">1.11.11 >>>无符号右移</a></li></ul></li><li><a href="#t641.12 更新优先级">1.12 更新优先级</a><ul><li><a href="#t651.12.1 lane">1.12.1 lane</a></li><li><a href="#t661.12.2 Hydration">1.12.2 Hydration</a></li><li><a href="#t671.12.3 ReactFiberLane.js">1.12.3 ReactFiberLane.js</a></li><li><a href="#t681.12.4 ReactUpdateQueue.js">1.12.4 ReactUpdateQueue.js</a></li><li><a href="#t691.12.5 processUpdateQueue.js">1.12.5 processUpdateQueue.js</a></li></ul></li></ul></li><li><a href="#t702.创建项目">2.创建项目</a><ul><li><a href="#t712.1 创建目录">2.1 创建目录</a></li><li><a href="#t722.2 安装">2.2 安装</a></li><li><a href="#t732.3 vite.config.js">2.3 vite.config.js</a></li><li><a href="#t742.4 jsconfig.json">2.4 jsconfig.json</a></li><li><a href="#t752.5 main.jsx">2.5 main.jsx</a></li><li><a href="#t762.6 index.html">2.6 index.html</a></li><li><a href="#t772.7 package.json">2.7 package.json</a></li></ul></li><li><a href="#t783.实现虚拟 DOM">3.实现虚拟 DOM</a><ul><li><a href="#t793.1 main.jsx">3.1 main.jsx</a></li><li><a href="#t803.2 jsx-dev-runtime.js">3.2 jsx-dev-runtime.js</a></li><li><a href="#t813.3 ReactJSXElement.js">3.3 ReactJSXElement.js</a></li><li><a href="#t823.4 ReactSymbols.js">3.4 ReactSymbols.js</a></li><li><a href="#t833.5 hasOwnProperty.js">3.5 hasOwnProperty.js</a></li></ul></li><li><a href="#t844.创建 ReactDOMRoot">4.创建 ReactDOMRoot</a><ul><li><a href="#t854.1 main.jsx">4.1 main.jsx</a></li><li><a href="#t864.2 client.js">4.2 client.js</a></li><li><a href="#t874.3 ReactDOMRoot.js">4.3 ReactDOMRoot.js</a></li><li><a href="#t884.4 ReactFiberReconciler.js">4.4 ReactFiberReconciler.js</a></li><li><a href="#t894.5 ReactFiberRoot.js">4.5 ReactFiberRoot.js</a></li></ul></li><li><a href="#t905.创建 RootFiber">5.创建 RootFiber</a><ul><li><a href="#t915.1 ReactFiberRoot.js">5.1 ReactFiberRoot.js</a></li><li><a href="#t925.2 ReactFiber.js">5.2 ReactFiber.js</a></li><li><a href="#t935.3 ReactWorkTags.js">5.3 ReactWorkTags.js</a></li><li><a href="#t945.4 ReactFiberFlags.js">5.4 ReactFiberFlags.js</a></li></ul></li><li><a href="#t956.初始化 UpdateQueue">6.初始化 UpdateQueue</a><ul><li><a href="#t966.1 ReactFiberRoot.js">6.1 ReactFiberRoot.js</a></li><li><a href="#t976.2 ReactFiberClassUpdateQueue.js">6.2 ReactFiberClassUpdateQueue.js</a></li></ul></li><li><a href="#t987. enqueueUpdate">7. enqueueUpdate</a><ul><li><a href="#t997.1 main.jsx">7.1 main.jsx</a></li><li><a href="#t1007.2 ReactDOMRoot.js">7.2 ReactDOMRoot.js</a></li><li><a href="#t1017.3 ReactFiberReconciler.js">7.3 ReactFiberReconciler.js</a></li><li><a href="#t1027.4 ReactFiberClassUpdateQueue.js">7.4 ReactFiberClassUpdateQueue.js</a></li><li><a href="#t1037.5 ReactFiberConcurrentUpdates.js">7.5 ReactFiberConcurrentUpdates.js</a></li></ul></li><li><a href="#t1048.performConcurrentWorkOnRoot">8.performConcurrentWorkOnRoot</a><ul><li><a href="#t1058.1 ReactFiberReconciler.js">8.1 ReactFiberReconciler.js</a></li><li><a href="#t1068.2 ReactFiberWorkLoop.js">8.2 ReactFiberWorkLoop.js</a></li><li><a href="#t1078.3 scheduler\index.js">8.3 scheduler\index.js</a></li><li><a href="#t1088.4 Scheduler.js">8.4 Scheduler.js</a></li></ul></li><li><a href="#t1099.prepareFreshStack">9.prepareFreshStack</a><ul><li><a href="#t1109.1 ReactFiberWorkLoop.js">9.1 ReactFiberWorkLoop.js</a></li><li><a href="#t1119.2 ReactFiber.js">9.2 ReactFiber.js</a></li></ul></li><li><a href="#t11210.beginWork">10.beginWork</a><ul><li><a href="#t11310.1 ReactFiberWorkLoop.js">10.1 ReactFiberWorkLoop.js</a></li><li><a href="#t11410.2 ReactFiberBeginWork.js">10.2 ReactFiberBeginWork.js</a></li><li><a href="#t11510.3 ReactWorkTags.js">10.3 ReactWorkTags.js</a></li><li><a href="#t11610.4 ReactFiberClassUpdateQueue.js">10.4 ReactFiberClassUpdateQueue.js</a></li><li><a href="#t11710.5 ReactChildFiber.js">10.5 ReactChildFiber.js</a></li><li><a href="#t11810.6 ReactDOMHostConfig.js">10.6 ReactDOMHostConfig.js</a></li><li><a href="#t11910.7 logger.js">10.7 logger.js</a></li><li><a href="#t12010.8 assign.js">10.8 assign.js</a></li><li><a href="#t12110.9 isArray.js">10.9 isArray.js</a></li><li><a href="#t12210.10 ReactFiber.js">10.10 ReactFiber.js</a></li><li><a href="#t12310.11 ReactFiberFlags.js">10.11 ReactFiberFlags.js</a></li></ul></li><li><a href="#t12411.completeUnitOfWork">11.completeUnitOfWork</a><ul><li><a href="#t12511.1 ReactFiberWorkLoop.js">11.1 ReactFiberWorkLoop.js</a></li><li><a href="#t12611.2 ReactFiberCompleteWork.js">11.2 ReactFiberCompleteWork.js</a></li><li><a href="#t12711.3 ReactDOMHostConfig.js">11.3 ReactDOMHostConfig.js</a></li><li><a href="#t12811.4 ReactDOMComponent.js">11.4 ReactDOMComponent.js</a></li><li><a href="#t12911.5 CSSPropertyOperations.js">11.5 CSSPropertyOperations.js</a></li><li><a href="#t13011.6 setTextContent.js">11.6 setTextContent.js</a></li><li><a href="#t13111.7 DOMPropertyOperations.js">11.7 DOMPropertyOperations.js</a></li></ul></li><li><a href="#t13212.commitRoot">12.commitRoot</a><ul><li><a href="#t13312.1 ReactFiberWorkLoop.js">12.1 ReactFiberWorkLoop.js</a></li></ul></li><li><a href="#t13413.commitMutationEffectsOnFiber">13.commitMutationEffectsOnFiber</a><ul><li><a href="#t13513.1 ReactFiberWorkLoop.js">13.1 ReactFiberWorkLoop.js</a></li><li><a href="#t13613.2 ReactFiberCommitWork.js">13.2 ReactFiberCommitWork.js</a></li></ul></li><li><a href="#t13714.commitPlacement">14.commitPlacement</a><ul><li><a href="#t13814.1 ReactFiberCommitWork.js">14.1 ReactFiberCommitWork.js</a></li><li><a href="#t13914.2 ReactDOMHostConfig.js">14.2 ReactDOMHostConfig.js</a></li></ul></li><li><a href="#t14015.函数组件">15.函数组件</a><ul><li><a href="#t14115.1 src\main.jsx">15.1 src\main.jsx</a></li><li><a href="#t14215.2 ReactWorkTags.js">15.2 ReactWorkTags.js</a></li><li><a href="#t14315.3 ReactFiberBeginWork.js">15.3 ReactFiberBeginWork.js</a></li><li><a href="#t14415.4 ReactFiberHooks.js">15.4 ReactFiberHooks.js</a></li><li><a href="#t14515.5 ReactFiberCommitWork.js">15.5 ReactFiberCommitWork.js</a></li></ul></li><li><a href="#t14616.注册事件名">16.注册事件名</a><ul><li><a href="#t14716.1 src\main.jsx">16.1 src\main.jsx</a></li><li><a href="#t14816.2 ReactDOMRoot.js">16.2 ReactDOMRoot.js</a></li><li><a href="#t14916.3 DOMPluginEventSystem.js">16.3 DOMPluginEventSystem.js</a></li><li><a href="#t15016.4 EventRegistry.js">16.4 EventRegistry.js</a></li><li><a href="#t15116.5 SimpleEventPlugin.js">16.5 SimpleEventPlugin.js</a></li><li><a href="#t15216.6 DOMEventProperties.js">16.6 DOMEventProperties.js</a></li></ul></li><li><a href="#t15317.listenToNativeEvent">17.listenToNativeEvent</a><ul><li><a href="#t15417.1 DOMPluginEventSystem.js">17.1 DOMPluginEventSystem.js</a></li><li><a href="#t15517.2 EventSystemFlags.js">17.2 EventSystemFlags.js</a></li><li><a href="#t15617.3 ReactDOMEventListener.js">17.3 ReactDOMEventListener.js</a></li><li><a href="#t15717.4 EventListener.js">17.4 EventListener.js</a></li></ul></li><li><a href="#t15818.extractEvents">18.extractEvents</a><ul><li><a href="#t15918.1 ReactDOMEventListener.js">18.1 ReactDOMEventListener.js</a></li><li><a href="#t16018.2 getEventTarget.js">18.2 getEventTarget.js</a></li><li><a href="#t16118.3 ReactDOMComponentTree.js">18.3 ReactDOMComponentTree.js</a></li><li><a href="#t16218.4 DOMPluginEventSystem.js">18.4 DOMPluginEventSystem.js</a></li><li><a href="#t16318.5 getListener.js">18.5 getListener.js</a></li><li><a href="#t16418.6 SimpleEventPlugin.js">18.6 SimpleEventPlugin.js</a></li><li><a href="#t16518.7 SyntheticEvent.js">18.7 SyntheticEvent.js</a></li><li><a href="#t16618.8 ReactDOMHostConfig.js">18.8 ReactDOMHostConfig.js</a></li><li><a href="#t16718.9 DOMEventProperties.js">18.9 DOMEventProperties.js</a></li></ul></li><li><a href="#t16819.processDispatchQueue">19.processDispatchQueue</a><ul><li><a href="#t16919.1 DOMPluginEventSystem.js">19.1 DOMPluginEventSystem.js</a></li></ul></li><li><a href="#t17020.dispatchReducerAction">20.dispatchReducerAction</a><ul><li><a href="#t17120.1 src\main.jsx">20.1 src\main.jsx</a></li><li><a href="#t17220.2 ReactFiberHooks.js">20.2 ReactFiberHooks.js</a></li><li><a href="#t17320.3 react\index.js">20.3 react\index.js</a></li><li><a href="#t17420.4 React.js">20.4 React.js</a></li><li><a href="#t17520.5 ReactHooks.js">20.5 ReactHooks.js</a></li><li><a href="#t17620.6 ReactCurrentDispatcher.js">20.6 ReactCurrentDispatcher.js</a></li><li><a href="#t17720.7 ReactSharedInternals.js">20.7 ReactSharedInternals.js</a></li><li><a href="#t17820.8 ReactSharedInternals.js">20.8 ReactSharedInternals.js</a></li></ul></li><li><a href="#t17921.HooksDispatcherOnUpdateInDEV">21.HooksDispatcherOnUpdateInDEV</a><ul><li><a href="#t18021.1 ReactFiberHooks.js">21.1 ReactFiberHooks.js</a></li><li><a href="#t18121.2 ReactFiberConcurrentUpdates.js">21.2 ReactFiberConcurrentUpdates.js</a></li><li><a href="#t18221.3 ReactFiberWorkLoop.js">21.3 ReactFiberWorkLoop.js</a></li><li><a href="#t18321.4 ReactFiberBeginWork.js">21.4 ReactFiberBeginWork.js</a></li><li><a href="#t18421.5 ReactChildFiber.js">21.5 ReactChildFiber.js</a></li><li><a href="#t18521.6 ReactFiberCompleteWork.js">21.6 ReactFiberCompleteWork.js</a></li><li><a href="#t18621.7 ReactFiberFlags.js">21.7 ReactFiberFlags.js</a></li><li><a href="#t18721.8 ReactDOMHostConfig.js">21.8 ReactDOMHostConfig.js</a></li><li><a href="#t18821.9 ReactDOMComponent.js">21.9 ReactDOMComponent.js</a></li></ul></li><li><a href="#t18922.commitUpdate">22.commitUpdate</a><ul><li><a href="#t19022.1 DOMPluginEventSystem.js">22.1 DOMPluginEventSystem.js</a></li><li><a href="#t19122.2 ReactFiberCompleteWork.js">22.2 ReactFiberCompleteWork.js</a></li><li><a href="#t19222.3 ReactFiberCommitWork.js">22.3 ReactFiberCommitWork.js</a></li><li><a href="#t19322.4 ReactDOMHostConfig.js">22.4 ReactDOMHostConfig.js</a></li><li><a href="#t19422.5 ReactDOMComponent.js">22.5 ReactDOMComponent.js</a></li></ul></li><li><a href="#t19523.useState">23.useState</a><ul><li><a href="#t19623.1 src\main.jsx">23.1 src\main.jsx</a></li><li><a href="#t19723.2 react\index.js">23.2 react\index.js</a></li><li><a href="#t19823.3 React.js">23.3 React.js</a></li><li><a href="#t19923.4 ReactHooks.js">23.4 ReactHooks.js</a></li><li><a href="#t20023.5 objectIs.js">23.5 objectIs.js</a></li><li><a href="#t20123.6 ReactFiberHooks.js">23.6 ReactFiberHooks.js</a></li></ul></li><li><a href="#t20224.单节点(key 相同,类型相同)">24.单节点(key 相同,类型相同)</a><ul><li><a href="#t20324.1 src\main.jsx">24.1 src\main.jsx</a></li></ul></li><li><a href="#t20425.单节点 key 不同,类型相同">25.单节点 key 不同,类型相同</a><ul><li><a href="#t20525.1 main.jsx">25.1 main.jsx</a></li><li><a href="#t20625.2 ReactFiberFlags.js">25.2 ReactFiberFlags.js</a></li><li><a href="#t20725.3 ReactFiber.js">25.3 ReactFiber.js</a></li><li><a href="#t20825.4 ReactDOMHostConfig.js">25.4 ReactDOMHostConfig.js</a></li><li><a href="#t20925.5 ReactChildFiber.js">25.5 ReactChildFiber.js</a></li><li><a href="#t21025.6 ReactFiberCommitWork.js">25.6 ReactFiberCommitWork.js</a></li></ul></li><li><a href="#t21126.单节点 key 相同,类型不同">26.单节点 key 相同,类型不同</a><ul><li><a href="#t21226.1 src\main.jsx">26.1 src\main.jsx</a></li><li><a href="#t21326.2 ReactChildFiber.js">26.2 ReactChildFiber.js</a></li></ul></li><li><a href="#t21427.原来多个节点，现在只有一个节点">27.原来多个节点，现在只有一个节点</a><ul><li><a href="#t21527.1 src\main.jsx">27.1 src\main.jsx</a></li></ul></li><li><a href="#t21628.多节点 DIFF">28.多节点 DIFF</a></li><li><a href="#t21729.多个节点的数量和 key 相同，有的 type 不同">29.多个节点的数量和 key 相同，有的 type 不同</a><ul><li><a href="#t21829.1 src\main.jsx">29.1 src\main.jsx</a></li><li><a href="#t21929.2 ReactChildFiber.js">29.2 ReactChildFiber.js</a></li></ul></li><li><a href="#t22030.多个节点的类型和 key 全部相同，有新增元素">30.多个节点的类型和 key 全部相同，有新增元素</a><ul><li><a href="#t22130.1 src\main.jsx">30.1 src\main.jsx</a></li></ul></li><li><a href="#t22231.多个节点的类型和 key 全部相同，有删除老元素">31.多个节点的类型和 key 全部相同，有删除老元素</a><ul><li><a href="#t22331.1 src\main.jsx">31.1 src\main.jsx</a></li></ul></li><li><a href="#t22432.多个节点数量不同、key 不同">32.多个节点数量不同、key 不同</a><ul><li><a href="#t22532.1 src\main.jsx">32.1 src\main.jsx</a></li><li><a href="#t22632.2 ReactFiber.js">32.2 ReactFiber.js</a></li><li><a href="#t22732.3 ReactFiberWorkLoop.js">32.3 ReactFiberWorkLoop.js</a></li><li><a href="#t22832.4 ReactChildFiber.js">32.4 ReactChildFiber.js</a></li></ul></li><li><a href="#t22933.useEffect">33.useEffect</a><ul><li><a href="#t23033.1 src\main.jsx">33.1 src\main.jsx</a></li><li><a href="#t23133.2 react\index.js">33.2 react\index.js</a></li><li><a href="#t23233.3 React.js">33.3 React.js</a></li><li><a href="#t23333.4 ReactHooks.js">33.4 ReactHooks.js</a></li><li><a href="#t23433.5 ReactHookEffectTags.js">33.5 ReactHookEffectTags.js</a></li><li><a href="#t23533.6 ReactFiberFlags.js">33.6 ReactFiberFlags.js</a></li><li><a href="#t23633.7 ReactFiberHooks.js">33.7 ReactFiberHooks.js</a></li><li><a href="#t23733.8 ReactFiberWorkLoop.js">33.8 ReactFiberWorkLoop.js</a></li><li><a href="#t23833.9 ReactFiberCommitWork.js">33.9 ReactFiberCommitWork.js</a></li></ul></li><li><a href="#t23934.useLayoutEffect">34.useLayoutEffect</a><ul><li><a href="#t24034.1 src\main.jsx">34.1 src\main.jsx</a></li><li><a href="#t24133.2 react\index.js">33.2 react\index.js</a></li><li><a href="#t24234.3 React.js">34.3 React.js</a></li><li><a href="#t24334.4 ReactHooks.js">34.4 ReactHooks.js</a></li><li><a href="#t24434.5 ReactHookEffectTags.js">34.5 ReactHookEffectTags.js</a></li><li><a href="#t24534.6 ReactFiberFlags.js">34.6 ReactFiberFlags.js</a></li><li><a href="#t24634.7 ReactFiberHooks.js">34.7 ReactFiberHooks.js</a></li><li><a href="#t24734.8 ReactFiberWorkLoop.js">34.8 ReactFiberWorkLoop.js</a></li><li><a href="#t24834.9 ReactFiberCommitWork.js">34.9 ReactFiberCommitWork.js</a></li></ul></li><li><a href="#t24935.Scheduler_scheduleCallback">35.Scheduler_scheduleCallback</a><ul><li><a href="#t25035.1 ReactFiberWorkLoop.js">35.1 ReactFiberWorkLoop.js</a></li><li><a href="#t25135.2 Scheduler.js">35.2 Scheduler.js</a></li><li><a href="#t25235.3 Scheduler.js">35.3 Scheduler.js</a></li><li><a href="#t25335.4 SchedulerFeatureFlags.js">35.4 SchedulerFeatureFlags.js</a></li><li><a href="#t25435.5 SchedulerMinHeap.js">35.5 SchedulerMinHeap.js</a></li><li><a href="#t25535.6 SchedulerPriorities.js">35.6 SchedulerPriorities.js</a></li></ul></li><li><a href="#t25636.初次渲染">36.初次渲染</a><ul><li><a href="#t25736.1 src\main.jsx">36.1 src\main.jsx</a></li><li><a href="#t25836.2  ReactFiberReconciler.js">36.2  ReactFiberReconciler.js</a></li><li><a href="#t25936.3  ReactFiberClassUpdateQueue.js">36.3  ReactFiberClassUpdateQueue.js</a></li><li><a href="#t26036.4 ReactFiberConcurrentUpdates.js">36.4 ReactFiberConcurrentUpdates.js</a></li><li><a href="#t26136.5 ReactFiberWorkLoop.js">36.5 ReactFiberWorkLoop.js</a></li><li><a href="#t26236.6 ReactFiberBeginWork.js">36.6 ReactFiberBeginWork.js</a></li><li><a href="#t26336.7 ReactFiberLane.js">36.7 ReactFiberLane.js</a></li><li><a href="#t26436.8 ReactEventPriorities.js">36.8 ReactEventPriorities.js</a></li><li><a href="#t26536.9 ReactDOMHostConfig.js">36.9 ReactDOMHostConfig.js</a></li><li><a href="#t26636.10 ReactDOMEventListener.js">36.10 ReactDOMEventListener.js</a></li><li><a href="#t26736.11 Scheduler.js">36.11 Scheduler.js</a></li></ul></li><li><a href="#t26837.更新渲染">37.更新渲染</a><ul><li><a href="#t26937.1 main.jsx">37.1 main.jsx</a></li><li><a href="#t27037.2 ReactFiberHooks.js">37.2 ReactFiberHooks.js</a></li><li><a href="#t27137.3 ReactFiberWorkLoop.js">37.3 ReactFiberWorkLoop.js</a></li><li><a href="#t27237.4 ReactFiberSyncTaskQueue.js">37.4 ReactFiberSyncTaskQueue.js</a></li><li><a href="#t27337.5  ReactFiberConcurrentUpdates.js">37.5  ReactFiberConcurrentUpdates.js</a></li><li><a href="#t27437.6 ReactDOMEventListener.js">37.6 ReactDOMEventListener.js</a></li></ul></li><li><a href="#t27538.并发渲染">38.并发渲染</a><ul><li><a href="#t27638.1  src\main.jsx">38.1  src\main.jsx</a></li><li><a href="#t27738.2  ReactFiberWorkLoop.js">38.2  ReactFiberWorkLoop.js</a></li><li><a href="#t27838.3 Scheduler.js">38.3 Scheduler.js</a></li><li><a href="#t27938.4 Scheduler.js">38.4 Scheduler.js</a></li><li><a href="#t28038.5 ReactFiberLane.js">38.5 ReactFiberLane.js</a></li><li><a href="#t28138.6 ReactFeatureFlags.js">38.6 ReactFeatureFlags.js</a></li></ul></li><li><a href="#t28239.批量更新">39.批量更新</a><ul><li><a href="#t28339.1  src\main.jsx">39.1  src\main.jsx</a></li><li><a href="#t28439.2 ReactFiberHooks.js">39.2 ReactFiberHooks.js</a></li><li><a href="#t28539.3  ReactFiberWorkLoop.js">39.3  ReactFiberWorkLoop.js</a></li></ul></li><li><a href="#t28640.高优更新打断低优更新(useRef)">40.高优更新打断低优更新(useRef)</a><ul><li><a href="#t28740.1 src\main.jsx">40.1 src\main.jsx</a></li><li><a href="#t28840.2 react\index.js">40.2 react\index.js</a></li><li><a href="#t28940.3 React.js">40.3 React.js</a></li><li><a href="#t29040.4 ReactHooks.js">40.4 ReactHooks.js</a></li><li><a href="#t29140.5 ReactFiberWorkLoop.js">40.5 ReactFiberWorkLoop.js</a></li><li><a href="#t29240.6 ReactFiberLane.js">40.6 ReactFiberLane.js</a></li><li><a href="#t29340.7  ReactFiberHooks.js">40.7  ReactFiberHooks.js</a></li><li><a href="#t29440.8 ReactFiberFlags.js">40.8 ReactFiberFlags.js</a></li><li><a href="#t29540.9 ReactFiberCompleteWork.js">40.9 ReactFiberCompleteWork.js</a></li><li><a href="#t29640.10 ReactFiberCommitWork.js">40.10 ReactFiberCommitWork.js</a></li><li><a href="#t29740.11  ReactFiber.js">40.11  ReactFiber.js</a></li><li><a href="#t29840.12 ReactChildFiber.js">40.12 ReactChildFiber.js</a></li></ul></li><li><a href="#t29941.饥饿问题">41.饥饿问题</a><ul><li><a href="#t30041.1 src\main.jsx">41.1 src\main.jsx</a></li><li><a href="#t30141.2 Scheduler.js">41.2 Scheduler.js</a></li><li><a href="#t30241.3 Scheduler.js">41.3 Scheduler.js</a></li><li><a href="#t30341.4 ReactFiberWorkLoop.js">41.4 ReactFiberWorkLoop.js</a></li><li><a href="#t30441.5 ReactFiberLane.js">41.5 ReactFiberLane.js</a></li><li><a href="#t30541.6 ReactFiber.js">41.6 ReactFiber.js</a></li><li><a href="#t30641.7 ReactFiberBeginWork.js">41.7 ReactFiberBeginWork.js</a></li><li><a href="#t30741.8 ReactFiberCompleteWork.js">41.8 ReactFiberCompleteWork.js</a></li><li><a href="#t30841.9 ReactFiberConcurrentUpdates.js">41.9 ReactFiberConcurrentUpdates.js</a></li><li><a href="#t30941.10 ReactFiberHooks.js">41.10 ReactFiberHooks.js</a></li><li><a href="#t31041.11 ReactFiberReconciler.js">41.11 ReactFiberReconciler.js</a></li><li><a href="#t31141.12 ReactFiberRoot.js">41.12 ReactFiberRoot.js</a></li></ul></li><li><a href="#t31242.context">42.context</a><ul><li><a href="#t31342.1 src\main.jsx">42.1 src\main.jsx</a></li><li><a href="#t31442.2  react\index.js">42.2  react\index.js</a></li><li><a href="#t31542.3 React.js">42.3 React.js</a></li><li><a href="#t31642.4 ReactContext.js">42.4 ReactContext.js</a></li><li><a href="#t31742.5 ReactHooks.js">42.5 ReactHooks.js</a></li><li><a href="#t31842.6 ReactFiber.js">42.6 ReactFiber.js</a></li><li><a href="#t31942.7 ReactFiberBeginWork.js">42.7 ReactFiberBeginWork.js</a></li><li><a href="#t32042.8 ReactFiberCompleteWork.js">42.8 ReactFiberCompleteWork.js</a></li><li><a href="#t32142.9 ReactFiberCommitWork.js">42.9 ReactFiberCommitWork.js</a></li><li><a href="#t32242.10 ReactFiberHooks.js">42.10 ReactFiberHooks.js</a></li><li><a href="#t32342.11 ReactFiberNewContext.js">42.11 ReactFiberNewContext.js</a></li><li><a href="#t32442.12 ReactWorkTags.js">42.12 ReactWorkTags.js</a></li><li><a href="#t32542.13 ReactSymbols.js">42.13 ReactSymbols.js</a></li></ul></li></ul>
    </div>
    <div class="content markdown-body">
        <h2 id="t01.React &#x524D;&#x7F6E;&#x77E5;&#x8BC6;">1.React &#x524D;&#x7F6E;&#x77E5;&#x8BC6; <a href="#t01.React &#x524D;&#x7F6E;&#x77E5;&#x8BC6;"> # </a></h2>
<h3 id="t11.1 React &#x662F;&#x4EC0;&#x4E48;?">1.1 React &#x662F;&#x4EC0;&#x4E48;? <a href="#t11.1 React &#x662F;&#x4EC0;&#x4E48;?"> # </a></h3>
<ul>
<li><a href="https://zh-hans.reactjs.org/">React</a>&#x662F;&#x4E00;&#x4E2A;&#x7528;&#x4E8E;&#x6784;&#x5EFA;&#x7528;&#x6237;&#x754C;&#x9762;&#x7684; JavaScript &#x5E93;</li>
<li>&#x53EF;&#x4EE5;&#x901A;&#x8FC7;&#x7EC4;&#x4EF6;&#x5316;&#x7684;&#x65B9;&#x5F0F;&#x6784;&#x5EFA; &#x6784;&#x5EFA;&#x5FEB;&#x901F;&#x54CD;&#x5E94;&#x7684;&#x5927;&#x578B;<code>Web</code>&#x5E94;&#x7528;&#x7A0B;&#x5E8F;</li>
</ul>
<h3 id="t21.2 JSX &#x662F;&#x4EC0;&#x4E48;">1.2 JSX &#x662F;&#x4EC0;&#x4E48; <a href="#t21.2 JSX &#x662F;&#x4EC0;&#x4E48;"> # </a></h3>
<ul>
<li><a href="https://zh-hans.reactjs.org/docs/introducing-jsx.html">jsx</a></li>
<li>JSX &#x662F;&#x4E00;&#x4E2A;<code>JavaScript</code>&#x7684;&#x8BED;&#x6CD5;&#x6269;&#x5C55;,JSX &#x53EF;&#x4EE5;&#x5F88;&#x597D;&#x5730;&#x63CF;&#x8FF0; UI &#x5E94;&#x8BE5;&#x5448;&#x73B0;&#x51FA;&#x5B83;&#x5E94;&#x6709;&#x4EA4;&#x4E92;&#x7684;&#x672C;&#x8D28;&#x5F62;&#x5F0F;</li>
<li><a href="https://babeljs.io/repl">repl</a>&#x53EF;&#x4EE5;&#x5728;&#x7EBF;&#x8F6C;&#x6362;&#x4EE3;&#x7801;</li>
<li><a href="https://astexplorer.net/">astexplorer</a>&#x53EF;&#x4EE5;&#x628A;&#x4EE3;&#x7801;&#x8F6C;&#x6362;&#x6210; AST &#x6811;</li>
<li><code>react/jsx-runtime</code> &#x548C; <code>react/jsx-dev-runtime</code> &#x4E2D;&#x7684;&#x51FD;&#x6570;&#x53EA;&#x80FD;&#x7531;&#x7F16;&#x8BD1;&#x5668;&#x8F6C;&#x6362;&#x4F7F;&#x7528;&#x3002;&#x5982;&#x679C;&#x4F60;&#x9700;&#x8981;&#x5728;&#x4EE3;&#x7801;&#x4E2D;&#x624B;&#x52A8;&#x521B;&#x5EFA;&#x5143;&#x7D20;&#xFF0C;&#x4F60;&#x53EF;&#x4EE5;&#x7EE7;&#x7EED;&#x4F7F;&#x7528; <code>React.createElement</code></li>
</ul>
<h4 id="t31.2.1 &#x65E7;&#x8F6C;&#x6362;">1.2.1 &#x65E7;&#x8F6C;&#x6362; <a href="#t31.2.1 &#x65E7;&#x8F6C;&#x6362;"> # </a></h4>
<h5 id="t41.2.1.1 jsx.js">1.2.1.1 jsx.js <a href="#t41.2.1.1 jsx.js"> # </a></h5>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> babel = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/core&quot;</span>);
<span class="hljs-keyword">const</span> sourceCode = <span class="hljs-string">`
&lt;h1&gt;
    hello&lt;span style={{ color: &quot;red&quot; }}&gt;world&lt;/span&gt;
&lt;/h1&gt;
`</span>;
<span class="hljs-keyword">const</span> result = babel.transform(sourceCode, {
  <span class="hljs-attr">plugins</span>: [[<span class="hljs-string">&quot;@babel/plugin-transform-react-jsx&quot;</span>, { <span class="hljs-attr">runtime</span>: <span class="hljs-string">&quot;classic&quot;</span> }]],
});
<span class="hljs-built_in">console</span>.log(result.code);
</code></pre>
<h5 id="t51.2.1.2 &#x8F6C;&#x8BD1;&#x7ED3;&#x679C;">1.2.1.2 &#x8F6C;&#x8BD1;&#x7ED3;&#x679C; <a href="#t51.2.1.2 &#x8F6C;&#x8BD1;&#x7ED3;&#x679C;"> # </a></h5>
<pre><code class="lang-js">React.createElement(
  <span class="hljs-string">&quot;h1&quot;</span>,
  <span class="hljs-literal">null</span>,
  <span class="hljs-string">&quot;hello&quot;</span>,
  React.createElement(
    <span class="hljs-string">&quot;span&quot;</span>,
    {
      <span class="hljs-attr">style</span>: {
        <span class="hljs-attr">color</span>: <span class="hljs-string">&quot;red&quot;</span>,
      },
    },
    <span class="hljs-string">&quot;world&quot;</span>
  )
);
</code></pre>
<h4 id="t61.2.2 &#x65B0;&#x8F6C;&#x6362;">1.2.2 &#x65B0;&#x8F6C;&#x6362; <a href="#t61.2.2 &#x65B0;&#x8F6C;&#x6362;"> # </a></h4>
<h5 id="t71.2.2.1 jsx.js">1.2.2.1 jsx.js <a href="#t71.2.2.1 jsx.js"> # </a></h5>
<pre><code class="lang-diff">const babel = require(&quot;@babel/core&quot;);
const sourceCode = `
&lt;h1&gt;
    hello&lt;span style={{ color: &quot;red&quot; }}&gt;world&lt;/span&gt;
&lt;/h1&gt;
`;
const result = babel.transform(sourceCode, {
<span class="hljs-addition">+ plugins: [[&quot;@babel/plugin-transform-react-jsx&quot;, { runtime: &quot;automatic&quot; }]],</span>
});
console.log(result.code);
</code></pre>
<h5 id="t81.2.2.2 &#x8F6C;&#x8BD1;&#x7ED3;&#x679C;">1.2.2.2 &#x8F6C;&#x8BD1;&#x7ED3;&#x679C; <a href="#t81.2.2.2 &#x8F6C;&#x8BD1;&#x7ED3;&#x679C;"> # </a></h5>
<pre><code class="lang-js"><span class="hljs-keyword">var</span> { jsxDEV } = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;react/jsx-dev-runtime&quot;</span>);
jsxDEV(<span class="hljs-string">&quot;h1&quot;</span>, {
  <span class="hljs-attr">children</span>: [
    <span class="hljs-string">&quot;hello&quot;</span>,
    jsxDEV(<span class="hljs-string">&quot;span&quot;</span>, {
      <span class="hljs-attr">style</span>: {
        <span class="hljs-attr">color</span>: <span class="hljs-string">&quot;red&quot;</span>,
      },
      <span class="hljs-attr">children</span>: <span class="hljs-string">&quot;world&quot;</span>,
    }),
  ],
});
</code></pre>
<h3 id="t91.3 Virtual DOM">1.3 Virtual DOM <a href="#t91.3 Virtual DOM"> # </a></h3>
<ul>
<li><code>React.createElement</code> &#x51FD;&#x6570;&#x6240;&#x8FD4;&#x56DE;&#x7684;&#x5C31;&#x662F;&#x4E00;&#x4E2A;&#x865A;&#x62DF; DOM</li>
<li>&#x865A;&#x62DF; DOM &#x5C31;&#x662F;&#x4E00;&#x4E2A;&#x63CF;&#x8FF0;&#x771F;&#x5B9E; DOM &#x7684;&#x7EAF; JS &#x5BF9;&#x8C61;</li>
</ul>
<p><img src="./assets/img/4b369c4c4fb2ff21be0ce9f197569d68.jpg" alt></p>
<h3 id="t101.4 &#x94FE;&#x8868;">1.4 &#x94FE;&#x8868; <a href="#t101.4 &#x94FE;&#x8868;"> # </a></h3>
<h4 id="t111.4.1 &#x94FE;&#x8868;&#x5206;&#x7C7B;">1.4.1 &#x94FE;&#x8868;&#x5206;&#x7C7B; <a href="#t111.4.1 &#x94FE;&#x8868;&#x5206;&#x7C7B;"> # </a></h4>
<h5 id="t121.4.1.1 &#x5355;&#x5411;&#x94FE;&#x8868;">1.4.1.1 &#x5355;&#x5411;&#x94FE;&#x8868; <a href="#t121.4.1.1 &#x5355;&#x5411;&#x94FE;&#x8868;"> # </a></h5>
<p><img src="./assets/img/2c760b36c6e40940d6ea27f75c9d5d2d.jpg" alt></p>
<h5 id="t131.4.1.2 &#x53CC;&#x5411;&#x94FE;&#x8868;">1.4.1.2 &#x53CC;&#x5411;&#x94FE;&#x8868; <a href="#t131.4.1.2 &#x53CC;&#x5411;&#x94FE;&#x8868;"> # </a></h5>
<p><img src="./assets/img/8c01888f379407b545ce7e1a196f5897.jpg" alt></p>
<h5 id="t141.4.1.3 &#x5FAA;&#x73AF;&#x94FE;&#x8868;">1.4.1.3 &#x5FAA;&#x73AF;&#x94FE;&#x8868; <a href="#t141.4.1.3 &#x5FAA;&#x73AF;&#x94FE;&#x8868;"> # </a></h5>
<p><img src="./assets/img/bb696f199eda051d68b03c1dd6cb0c16.jpg" alt></p>
<p><img src="./assets/img/4153f4758053bc7c33563155549f534d.png" alt></p>
<h5 id="t151.4.1.4 &#x793A;&#x4F8B;">1.4.1.4 &#x793A;&#x4F8B; <a href="#t151.4.1.4 &#x793A;&#x4F8B;"> # </a></h5>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> UpdateState = <span class="hljs-number">0</span>;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">initializeUpdateQueue</span>(<span class="hljs-params">fiber</span>) </span>{
  <span class="hljs-keyword">const</span> queue = {
    <span class="hljs-attr">shared</span>: {
      <span class="hljs-attr">pending</span>: <span class="hljs-literal">null</span>,
    },
  };
  fiber.updateQueue = queue;
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createUpdate</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> update = { <span class="hljs-attr">tag</span>: UpdateState };
  <span class="hljs-keyword">return</span> update;
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">enqueueUpdate</span>(<span class="hljs-params">fiber, update</span>) </span>{
  <span class="hljs-keyword">const</span> updateQueue = fiber.updateQueue;
  <span class="hljs-keyword">const</span> sharedQueue = updateQueue.shared;
  <span class="hljs-keyword">const</span> pending = sharedQueue.pending;
  <span class="hljs-keyword">if</span> (pending === <span class="hljs-literal">null</span>) {
    update.next = update;
  } <span class="hljs-keyword">else</span> {
    update.next = pending.next;
    pending.next = update;
  }
  updateQueue.shared.pending = update;
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getStateFromUpdate</span>(<span class="hljs-params">update, prevState</span>) </span>{
  <span class="hljs-keyword">switch</span> (update.tag) {
    <span class="hljs-keyword">case</span> UpdateState: {
      <span class="hljs-keyword">const</span> { payload } = update;
      <span class="hljs-keyword">const</span> partialState = payload;
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.assign({}, prevState, partialState);
    }
    <span class="hljs-attr">default</span>:
      <span class="hljs-keyword">return</span> prevState;
  }
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">processUpdateQueue</span>(<span class="hljs-params">workInProgress</span>) </span>{
  <span class="hljs-keyword">const</span> queue = workInProgress.updateQueue;
  <span class="hljs-keyword">const</span> pendingQueue = queue.shared.pending;
  <span class="hljs-keyword">if</span> (pendingQueue !== <span class="hljs-literal">null</span>) {
    queue.shared.pending = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">const</span> lastPendingUpdate = pendingQueue;
    <span class="hljs-keyword">const</span> firstPendingUpdate = lastPendingUpdate.next;
    lastPendingUpdate.next = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">let</span> newState = workInProgress.memoizedState;
    <span class="hljs-keyword">let</span> update = firstPendingUpdate;
    <span class="hljs-keyword">while</span> (update) {
      newState = getStateFromUpdate(update, newState);
      update = update.next;
    }
    workInProgress.memoizedState = newState;
  }
}
<span class="hljs-keyword">let</span> fiber = { <span class="hljs-attr">memoizedState</span>: { <span class="hljs-attr">id</span>: <span class="hljs-number">1</span> } };
initializeUpdateQueue(fiber);
<span class="hljs-keyword">let</span> update1 = createUpdate();
update1.payload = { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;zhufeng&quot;</span> };
enqueueUpdate(fiber, update1);
<span class="hljs-keyword">let</span> update2 = createUpdate();
update2.payload = { <span class="hljs-attr">age</span>: <span class="hljs-number">14</span> };
enqueueUpdate(fiber, update2);
processUpdateQueue(fiber);
<span class="hljs-built_in">console</span>.log(fiber);
</code></pre>
<h3 id="t161.5 fiber">1.5 fiber <a href="#t161.5 fiber"> # </a></h3>
<h4 id="t171.5.1 &#x6027;&#x80FD;&#x74F6;&#x9888;">1.5.1 &#x6027;&#x80FD;&#x74F6;&#x9888; <a href="#t171.5.1 &#x6027;&#x80FD;&#x74F6;&#x9888;"> # </a></h4>
<ul>
<li>JS &#x4EFB;&#x52A1;&#x6267;&#x884C;&#x65F6;&#x95F4;&#x8FC7;&#x957F;<ul>
<li>&#x6D4F;&#x89C8;&#x5668;&#x5237;&#x65B0;&#x9891;&#x7387;&#x4E3A; 60Hz,&#x5927;&#x6982; 16.6 &#x6BEB;&#x79D2;&#x6E32;&#x67D3;&#x4E00;&#x6B21;&#xFF0C;&#x800C; JS &#x7EBF;&#x7A0B;&#x548C;&#x6E32;&#x67D3;&#x7EBF;&#x7A0B;&#x662F;&#x4E92;&#x65A5;&#x7684;&#xFF0C;&#x6240;&#x4EE5;&#x5982;&#x679C; JS &#x7EBF;&#x7A0B;&#x6267;&#x884C;&#x4EFB;&#x52A1;&#x65F6;&#x95F4;&#x8D85;&#x8FC7; 16.6ms &#x7684;&#x8BDD;&#xFF0C;&#x5C31;&#x4F1A;&#x5BFC;&#x81F4;&#x6389;&#x5E27;&#xFF0C;&#x5BFC;&#x81F4;&#x5361;&#x987F;&#xFF0C;&#x89E3;&#x51B3;&#x65B9;&#x6848;&#x5C31;&#x662F; React &#x5229;&#x7528;&#x7A7A;&#x95F2;&#x7684;&#x65F6;&#x95F4;&#x8FDB;&#x884C;&#x66F4;&#x65B0;&#xFF0C;&#x4E0D;&#x5F71;&#x54CD;&#x6E32;&#x67D3;&#x8FDB;&#x884C;&#x7684;&#x6E32;&#x67D3;</li>
<li>&#x628A;&#x4E00;&#x4E2A;&#x8017;&#x65F6;&#x4EFB;&#x52A1;&#x5207;&#x5206;&#x6210;&#x4E00;&#x4E2A;&#x4E2A;&#x5C0F;&#x4EFB;&#x52A1;&#xFF0C;&#x5206;&#x5E03;&#x5728;&#x6BCF;&#x4E00;&#x5E27;&#x91CC;&#x7684;&#x65B9;&#x5F0F;&#x5C31;&#x53EB;&#x65F6;&#x95F4;&#x5207;&#x7247;</li>
</ul>
</li>
</ul>
<h4 id="t181.5.2 &#x5C4F;&#x5E55;&#x5237;&#x65B0;&#x7387;">1.5.2 &#x5C4F;&#x5E55;&#x5237;&#x65B0;&#x7387; <a href="#t181.5.2 &#x5C4F;&#x5E55;&#x5237;&#x65B0;&#x7387;"> # </a></h4>
<ul>
<li>&#x76EE;&#x524D;&#x5927;&#x591A;&#x6570;&#x8BBE;&#x5907;&#x7684;&#x5C4F;&#x5E55;&#x5237;&#x65B0;&#x7387;&#x4E3A; 60 &#x6B21;/&#x79D2;</li>
<li>&#x6D4F;&#x89C8;&#x5668;&#x6E32;&#x67D3;&#x52A8;&#x753B;&#x6216;&#x9875;&#x9762;&#x7684;&#x6BCF;&#x4E00;&#x5E27;&#x7684;&#x901F;&#x7387;&#x4E5F;&#x9700;&#x8981;&#x8DDF;&#x8BBE;&#x5907;&#x5C4F;&#x5E55;&#x7684;&#x5237;&#x65B0;&#x7387;&#x4FDD;&#x6301;&#x4E00;&#x81F4;</li>
<li>&#x9875;&#x9762;&#x662F;&#x4E00;&#x5E27;&#x4E00;&#x5E27;&#x7ED8;&#x5236;&#x51FA;&#x6765;&#x7684;&#xFF0C;&#x5F53;&#x6BCF;&#x79D2;&#x7ED8;&#x5236;&#x7684;&#x5E27;&#x6570;&#xFF08;FPS&#xFF09;&#x8FBE;&#x5230; 60 &#x65F6;&#xFF0C;&#x9875;&#x9762;&#x662F;&#x6D41;&#x7545;&#x7684;,&#x5C0F;&#x4E8E;&#x8FD9;&#x4E2A;&#x503C;&#x65F6;&#xFF0C;&#x7528;&#x6237;&#x4F1A;&#x611F;&#x89C9;&#x5230;&#x5361;&#x987F;</li>
<li>&#x6BCF;&#x4E2A;&#x5E27;&#x7684;&#x9884;&#x7B97;&#x65F6;&#x95F4;&#x662F; 16.66 &#x6BEB;&#x79D2; (1 &#x79D2;/60)</li>
<li>1s 60 &#x5E27;&#xFF0C;&#x6240;&#x4EE5;&#x6BCF;&#x4E00;&#x5E27;&#x5206;&#x5230;&#x7684;&#x65F6;&#x95F4;&#x662F; 1000/60 &#x2248; 16 ms,&#x6240;&#x4EE5;&#x6211;&#x4EEC;&#x4E66;&#x5199;&#x4EE3;&#x7801;&#x65F6;&#x529B;&#x6C42;&#x4E0D;&#x8BA9;&#x4E00;&#x5E27;&#x7684;&#x5DE5;&#x4F5C;&#x91CF;&#x8D85;&#x8FC7; 16ms</li>
</ul>
<h4 id="t191.5.3 &#x5E27;">1.5.3 &#x5E27; <a href="#t191.5.3 &#x5E27;"> # </a></h4>
<ul>
<li>&#x6BCF;&#x4E2A;&#x5E27;&#x7684;&#x5F00;&#x5934;&#x5305;&#x62EC;&#x6837;&#x5F0F;&#x8BA1;&#x7B97;&#x3001;&#x5E03;&#x5C40;&#x548C;&#x7ED8;&#x5236;</li>
<li>JavaScript &#x6267;&#x884C; Javascript &#x5F15;&#x64CE;&#x548C;&#x9875;&#x9762;&#x6E32;&#x67D3;&#x5F15;&#x64CE;&#x5728;&#x540C;&#x4E00;&#x4E2A;&#x6E32;&#x67D3;&#x7EBF;&#x7A0B;,GUI &#x6E32;&#x67D3;&#x548C; Javascript &#x6267;&#x884C;&#x4E24;&#x8005;&#x662F;&#x4E92;&#x65A5;&#x7684;</li>
<li>&#x5982;&#x679C;&#x67D0;&#x4E2A;&#x4EFB;&#x52A1;&#x6267;&#x884C;&#x65F6;&#x95F4;&#x8FC7;&#x957F;&#xFF0C;&#x6D4F;&#x89C8;&#x5668;&#x4F1A;&#x63A8;&#x8FDF;&#x6E32;&#x67D3;</li>
</ul>
<p><img src="./assets/img/ecc3288a124b11554ab7d65043315fbe.jpg" alt="lifeofframe"></p>
<h4 id="t201.5.4 requestIdleCallback">1.5.4 requestIdleCallback <a href="#t201.5.4 requestIdleCallback"> # </a></h4>
<ul>
<li>&#x6211;&#x4EEC;&#x5E0C;&#x671B;&#x5FEB;&#x901F;&#x54CD;&#x5E94;&#x7528;&#x6237;&#xFF0C;&#x8BA9;&#x7528;&#x6237;&#x89C9;&#x5F97;&#x591F;&#x5FEB;&#xFF0C;&#x4E0D;&#x80FD;&#x963B;&#x585E;&#x7528;&#x6237;&#x7684;&#x4EA4;&#x4E92;</li>
<li><code>requestIdleCallback</code> &#x4F7F;&#x5F00;&#x53D1;&#x8005;&#x80FD;&#x591F;&#x5728;&#x4E3B;&#x4E8B;&#x4EF6;&#x5FAA;&#x73AF;&#x4E0A;&#x6267;&#x884C;&#x540E;&#x53F0;&#x548C;&#x4F4E;&#x4F18;&#x5148;&#x7EA7;&#x5DE5;&#x4F5C;&#xFF0C;&#x800C;&#x4E0D;&#x4F1A;&#x5F71;&#x54CD;&#x5EF6;&#x8FDF;&#x5173;&#x952E;&#x4E8B;&#x4EF6;&#xFF0C;&#x5982;&#x52A8;&#x753B;&#x548C;&#x8F93;&#x5165;&#x54CD;&#x5E94;</li>
<li>&#x6B63;&#x5E38;&#x5E27;&#x4EFB;&#x52A1;&#x5B8C;&#x6210;&#x540E;&#x6CA1;&#x8D85;&#x8FC7; 16 ms,&#x8BF4;&#x660E;&#x65F6;&#x95F4;&#x6709;&#x5BCC;&#x4F59;&#xFF0C;&#x6B64;&#x65F6;&#x5C31;&#x4F1A;&#x6267;&#x884C; <code>requestIdleCallback</code> &#x91CC;&#x6CE8;&#x518C;&#x7684;&#x4EFB;&#x52A1;</li>
</ul>
<p><img src="./assets/img/b3a9873b4b84d60bc2237d43ad3ab8df.jpg" alt="cooperativescheduling2"></p>
<pre><code class="lang-html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sleep</span>(<span class="hljs-params">d</span>) </span>{
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> t = <span class="hljs-built_in">Date</span>.now(); <span class="hljs-built_in">Date</span>.now() - t &lt;= d; );
      }
      <span class="hljs-keyword">const</span> works = [
        <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
          <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;&#x7B2C;1&#x4E2A;&#x4EFB;&#x52A1;&#x5F00;&#x59CB;&quot;</span>);
          sleep(<span class="hljs-number">20</span>); <span class="hljs-comment">//sleep(20);</span>
          <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;&#x7B2C;1&#x4E2A;&#x4EFB;&#x52A1;&#x7ED3;&#x675F;&quot;</span>);
        },
        () =&gt; {
          <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;&#x7B2C;2&#x4E2A;&#x4EFB;&#x52A1;&#x5F00;&#x59CB;&quot;</span>);
          sleep(<span class="hljs-number">20</span>); <span class="hljs-comment">//sleep(20);</span>
          <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;&#x7B2C;2&#x4E2A;&#x4EFB;&#x52A1;&#x7ED3;&#x675F;&quot;</span>);
        },
        () =&gt; {
          <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;&#x7B2C;3&#x4E2A;&#x4EFB;&#x52A1;&#x5F00;&#x59CB;&quot;</span>);
          sleep(<span class="hljs-number">20</span>); <span class="hljs-comment">//sleep(20);</span>
          <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;&#x7B2C;3&#x4E2A;&#x4EFB;&#x52A1;&#x7ED3;&#x675F;&quot;</span>);
        },
      ];

      requestIdleCallback(workLoop);
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">workLoop</span>(<span class="hljs-params">deadline</span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;&#x672C;&#x5E27;&#x5269;&#x4F59;&#x65F6;&#x95F4;&quot;</span>, <span class="hljs-built_in">parseInt</span>(deadline.timeRemaining()));
        <span class="hljs-keyword">while</span> (deadline.timeRemaining() &gt; <span class="hljs-number">1</span> &amp;&amp; works.length &gt; <span class="hljs-number">0</span>) {
          performUnitOfWork();
        }
        <span class="hljs-keyword">if</span> (works.length &gt; <span class="hljs-number">0</span>) {
          <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`&#x53EA;&#x5269;&#x4E0B;<span class="hljs-subst">${<span class="hljs-built_in">parseInt</span>(deadline.timeRemaining())}</span>ms,&#x65F6;&#x95F4;&#x7247;&#x5230;&#x4E86;&#x7B49;&#x5F85;&#x4E0B;&#x6B21;&#x7A7A;&#x95F2;&#x65F6;&#x95F4;&#x7684;&#x8C03;&#x5EA6;`</span>);
          requestIdleCallback(workLoop);
        }
      }
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">performUnitOfWork</span>(<span class="hljs-params"></span>) </span>{
        works.shift()();
      }
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>
<h4 id="t211.5.5 fiber">1.5.5 fiber <a href="#t211.5.5 fiber"> # </a></h4>
<ul>
<li>&#x6211;&#x4EEC;&#x53EF;&#x4EE5;&#x901A;&#x8FC7;&#x67D0;&#x4E9B;&#x8C03;&#x5EA6;&#x7B56;&#x7565;&#x5408;&#x7406;&#x5206;&#x914D; CPU &#x8D44;&#x6E90;&#xFF0C;&#x4ECE;&#x800C;&#x63D0;&#x9AD8;&#x7528;&#x6237;&#x7684;&#x54CD;&#x5E94;&#x901F;&#x5EA6;</li>
<li>&#x901A;&#x8FC7; Fiber &#x67B6;&#x6784;&#xFF0C;&#x8BA9;&#x81EA;&#x5DF1;&#x7684;&#x8C03;&#x548C;&#x8FC7;&#x7A0B;&#x53D8;&#x6210;&#x53EF;&#x88AB;&#x4E2D;&#x65AD;&#x3002; &#x9002;&#x65F6;&#x5730;&#x8BA9;&#x51FA; CPU &#x6267;&#x884C;&#x6743;&#xFF0C;&#x9664;&#x4E86;&#x53EF;&#x4EE5;&#x8BA9;&#x6D4F;&#x89C8;&#x5668;&#x53CA;&#x65F6;&#x5730;&#x54CD;&#x5E94;&#x7528;&#x6237;&#x7684;&#x4EA4;&#x4E92;</li>
</ul>
<h5 id="t221.5.5.1 Fiber &#x662F;&#x4E00;&#x4E2A;&#x6267;&#x884C;&#x5355;&#x5143;">1.5.5.1 Fiber &#x662F;&#x4E00;&#x4E2A;&#x6267;&#x884C;&#x5355;&#x5143; <a href="#t221.5.5.1 Fiber &#x662F;&#x4E00;&#x4E2A;&#x6267;&#x884C;&#x5355;&#x5143;"> # </a></h5>
<ul>
<li>Fiber &#x662F;&#x4E00;&#x4E2A;&#x6267;&#x884C;&#x5355;&#x5143;,&#x6BCF;&#x6B21;&#x6267;&#x884C;&#x5B8C;&#x4E00;&#x4E2A;&#x6267;&#x884C;&#x5355;&#x5143;, React &#x5C31;&#x4F1A;&#x68C0;&#x67E5;&#x73B0;&#x5728;&#x8FD8;&#x5269;&#x591A;&#x5C11;&#x65F6;&#x95F4;&#xFF0C;&#x5982;&#x679C;&#x6CA1;&#x6709;&#x65F6;&#x95F4;&#x5C31;&#x5C06;&#x63A7;&#x5236;&#x6743;&#x8BA9;&#x51FA;&#x53BB;</li>
</ul>
<p><img src="./assets/img/1d905da2bf71423fcd9e52074b776c2f.jpg" alt="fiberflow"></p>
<h5 id="t231.5.5.2 Fiber &#x662F;&#x4E00;&#x79CD;&#x6570;&#x636E;&#x7ED3;&#x6784;">1.5.5.2 Fiber &#x662F;&#x4E00;&#x79CD;&#x6570;&#x636E;&#x7ED3;&#x6784; <a href="#t231.5.5.2 Fiber &#x662F;&#x4E00;&#x79CD;&#x6570;&#x636E;&#x7ED3;&#x6784;"> # </a></h5>
<ul>
<li>React &#x76EE;&#x524D;&#x7684;&#x505A;&#x6CD5;&#x662F;&#x4F7F;&#x7528;&#x94FE;&#x8868;, &#x6BCF;&#x4E2A;&#x865A;&#x62DF;&#x8282;&#x70B9;&#x5185;&#x90E8;&#x8868;&#x793A;&#x4E3A;&#x4E00;&#x4E2A;<code>Fiber</code></li>
<li>&#x4ECE;&#x9876;&#x70B9;&#x5F00;&#x59CB;&#x904D;&#x5386;</li>
<li>&#x5982;&#x679C;&#x6709;&#x7B2C;&#x4E00;&#x4E2A;&#x513F;&#x5B50;&#xFF0C;&#x5148;&#x904D;&#x5386;&#x7B2C;&#x4E00;&#x4E2A;&#x513F;&#x5B50;</li>
<li>&#x5982;&#x679C;&#x6CA1;&#x6709;&#x7B2C;&#x4E00;&#x4E2A;&#x513F;&#x5B50;&#xFF0C;&#x6807;&#x5FD7;&#x7740;&#x6B64;&#x8282;&#x70B9;&#x904D;&#x5386;&#x5B8C;&#x6210;</li>
<li>&#x5982;&#x679C;&#x6709;&#x5F1F;&#x5F1F;&#x904D;&#x5386;&#x5F1F;&#x5F1F;</li>
<li>&#x5982;&#x679C;&#x6709;&#x6CA1;&#x6709;&#x4E0B;&#x4E00;&#x4E2A;&#x5F1F;&#x5F1F;&#xFF0C;&#x8FD4;&#x56DE;&#x7236;&#x8282;&#x70B9;&#x6807;&#x8BC6;&#x5B8C;&#x6210;&#x7236;&#x8282;&#x70B9;&#x904D;&#x5386;&#xFF0C;&#x5982;&#x679C;&#x6709;&#x53D4;&#x53D4;&#x904D;&#x5386;&#x53D4;&#x53D4;</li>
<li>&#x6CA1;&#x6709;&#x7236;&#x8282;&#x70B9;&#x904D;&#x5386;&#x7ED3;&#x675F;</li>
</ul>
<p><img src="./assets/img/b3ccdd3e976e831e8430b3bd663212ed.jpg" alt></p>
<h5 id="t241.5.5.3 &#x9012;&#x5F52;&#x6784;&#x5EFA; fiber &#x6811;">1.5.5.3 &#x9012;&#x5F52;&#x6784;&#x5EFA; fiber &#x6811; <a href="#t241.5.5.3 &#x9012;&#x5F52;&#x6784;&#x5EFA; fiber &#x6811;"> # </a></h5>
<p><img src="./assets/img/1bf3a1e2c8289fec732e47cb991ee9e6.jpg" alt></p>
<h3 id="t251.6 &#x6811;&#x7684;&#x904D;&#x5386;">1.6 &#x6811;&#x7684;&#x904D;&#x5386; <a href="#t251.6 &#x6811;&#x7684;&#x904D;&#x5386;"> # </a></h3>
<p><img src="./assets/img/0b577bfe0f6ce121a858a5904728f605.jpg" alt></p>
<h4 id="t261.6.1 &#x6DF1;&#x5EA6;&#x4F18;&#x5148;(DFS)">1.6.1 &#x6DF1;&#x5EA6;&#x4F18;&#x5148;(DFS) <a href="#t261.6.1 &#x6DF1;&#x5EA6;&#x4F18;&#x5148;(DFS)"> # </a></h4>
<ul>
<li>&#x6DF1;&#x5EA6;&#x4F18;&#x5148;&#x641C;&#x7D22;&#x82F1;&#x6587;&#x7F29;&#x5199;&#x4E3A; DFS &#x5373;<code>Depth First Search</code></li>
<li>&#x5176;&#x8FC7;&#x7A0B;&#x7B80;&#x8981;&#x6765;&#x8BF4;&#x662F;&#x5BF9;&#x6BCF;&#x4E00;&#x4E2A;&#x53EF;&#x80FD;&#x7684;&#x5206;&#x652F;&#x8DEF;&#x5F84;&#x6DF1;&#x5165;&#x5230;&#x4E0D;&#x80FD;&#x518D;&#x6DF1;&#x5165;&#x4E3A;&#x6B62;&#xFF0C;&#x800C;&#x4E14;&#x6BCF;&#x4E2A;&#x8282;&#x70B9;&#x53EA;&#x80FD;&#x8BBF;&#x95EE;&#x4E00;&#x6B21;</li>
<li>&#x5E94;&#x7528;&#x573A;&#x666F;<ul>
<li>React &#x865A;&#x62DF; DOM &#x7684;&#x6784;&#x5EFA;</li>
<li>React &#x7684; fiber &#x6811;&#x6784;&#x5EFA;</li>
</ul>
</li>
</ul>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dfs</span>(<span class="hljs-params">node</span>) </span>{
  <span class="hljs-built_in">console</span>.log(node.name);
  node.children &amp;&amp;
    node.children.forEach(<span class="hljs-function">(<span class="hljs-params">child</span>) =&gt;</span> {
      dfs(child);
    });
}
<span class="hljs-keyword">let</span> root = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;A&quot;</span>,
  <span class="hljs-attr">children</span>: [
    {
      <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;B&quot;</span>,
      <span class="hljs-attr">children</span>: [{ <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;B1&quot;</span> }, { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;B2&quot;</span> }],
    },
    {
      <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;C&quot;</span>,
      <span class="hljs-attr">children</span>: [{ <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;C1&quot;</span> }, { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;C2&quot;</span> }],
    },
  ],
};
dfs(root);
</code></pre>
<h4 id="t271.6.2 &#x5E7F;&#x5EA6;&#x4F18;&#x5148;(BFS)">1.6.2 &#x5E7F;&#x5EA6;&#x4F18;&#x5148;(BFS) <a href="#t271.6.2 &#x5E7F;&#x5EA6;&#x4F18;&#x5148;(BFS)"> # </a></h4>
<ul>
<li>&#x5BBD;&#x5EA6;&#x4F18;&#x5148;&#x641C;&#x7D22;&#x7B97;&#x6CD5;&#xFF08;&#x53C8;&#x79F0;&#x5E7F;&#x5EA6;&#x4F18;&#x5148;&#x641C;&#x7D22;&#xFF09;&#xFF0C;&#x5176;&#x82F1;&#x6587;&#x5168;&#x79F0;&#x662F; Breadth First Search</li>
<li>&#x7B97;&#x6CD5;&#x9996;&#x5148;&#x641C;&#x7D22;&#x8DDD;&#x79BB;&#x4E3A;<code>k</code>&#x7684;&#x6240;&#x6709;&#x9876;&#x70B9;&#xFF0C;&#x7136;&#x540E;&#x518D;&#x53BB;&#x641C;&#x7D22;&#x8DDD;&#x79BB;&#x4E3A;<code>k+l</code>&#x7684;&#x5176;&#x4ED6;&#x9876;&#x70B9;</li>
</ul>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bfs</span>(<span class="hljs-params">node</span>) </span>{
  <span class="hljs-keyword">const</span> stack = [];
  stack.push(node);
  <span class="hljs-keyword">let</span> current;
  <span class="hljs-keyword">while</span> ((current = stack.shift())) {
    <span class="hljs-built_in">console</span>.log(current.name);
    current.children &amp;&amp;
      current.children.forEach(<span class="hljs-function">(<span class="hljs-params">child</span>) =&gt;</span> {
        stack.push(child);
      });
  }
}
<span class="hljs-keyword">let</span> root = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;A&quot;</span>,
  <span class="hljs-attr">children</span>: [
    {
      <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;B&quot;</span>,
      <span class="hljs-attr">children</span>: [{ <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;B1&quot;</span> }, { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;B2&quot;</span> }],
    },
    {
      <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;C&quot;</span>,
      <span class="hljs-attr">children</span>: [{ <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;C1&quot;</span> }, { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;C2&quot;</span> }],
    },
  ],
};
bfs(root);
</code></pre>
<h4 id="t281.6.3 &#x6808;">1.6.3 &#x6808; <a href="#t281.6.3 &#x6808;"> # </a></h4>
<ul>
<li>&#x6808;&#xFF08;stack&#xFF09;&#x53C8;&#x540D;&#x5806;&#x6808;&#xFF0C;&#x5B83;&#x662F;&#x4E00;&#x79CD;&#x8FD0;&#x7B97;&#x53D7;&#x9650;&#x7684;&#x7EBF;&#x6027;&#x8868;</li>
<li>&#x9650;&#x5B9A;&#x4EC5;&#x5728;&#x8868;&#x5C3E;&#x8FDB;&#x884C;&#x63D2;&#x5165;&#x548C;&#x5220;&#x9664;&#x64CD;&#x4F5C;&#x7684;&#x7EBF;&#x6027;&#x8868;&#xFF0C;&#x8FD9;&#x4E00;&#x7AEF;&#x88AB;&#x79F0;&#x4E3A;&#x6808;&#x9876;&#xFF0C;&#x76F8;&#x5BF9;&#x5730;&#xFF0C;&#x628A;&#x53E6;&#x4E00;&#x7AEF;&#x79F0;&#x4E3A;&#x6808;&#x5E95;</li>
<li>&#x5411;&#x4E00;&#x4E2A;&#x6808;&#x63D2;&#x5165;&#x65B0;&#x5143;&#x7D20;&#x53C8;&#x79F0;&#x4F5C;&#x8FDB;&#x6808;&#x3001;&#x5165;&#x6808;&#x6216;&#x538B;&#x6808;&#xFF0C;&#x5B83;&#x662F;&#x628A;&#x65B0;&#x5143;&#x7D20;&#x653E;&#x5230;&#x6808;&#x9876;&#x5143;&#x7D20;&#x7684;&#x4E0A;&#x9762;&#xFF0C;&#x4F7F;&#x4E4B;&#x6210;&#x4E3A;&#x65B0;&#x7684;&#x6808;&#x9876;&#x5143;&#x7D20;</li>
<li>&#x4ECE;&#x4E00;&#x4E2A;&#x6808;&#x5220;&#x9664;&#x5143;&#x7D20;&#x53C8;&#x79F0;&#x4F5C;&#x51FA;&#x6808;&#x6216;&#x9000;&#x6808;&#xFF0C;&#x5B83;&#x662F;&#x628A;&#x6808;&#x9876;&#x5143;&#x7D20;&#x5220;&#x9664;&#x6389;&#xFF0C;&#x4F7F;&#x5176;&#x76F8;&#x90BB;&#x7684;&#x5143;&#x7D20;&#x6210;&#x4E3A;&#x65B0;&#x7684;&#x6808;&#x9876;&#x5143;&#x7D20;</li>
</ul>
<p><img src="./assets/img/9176d56a6015ea48d073858f8f017e04.png" alt></p>
<pre><code class="lang-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Stack</span> </span>{
  <span class="hljs-keyword">constructor</span>() {
    <span class="hljs-keyword">this</span>.data = [];
    <span class="hljs-keyword">this</span>.top = <span class="hljs-number">0</span>;
  }
  push(node) {
    <span class="hljs-keyword">this</span>.data[<span class="hljs-keyword">this</span>.top++] = node;
  }
  pop() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.data[--<span class="hljs-keyword">this</span>.top];
  }
  peek() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.data[<span class="hljs-keyword">this</span>.top - <span class="hljs-number">1</span>];
  }
  size() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.top;
  }
  clear() {
    <span class="hljs-keyword">this</span>.top = <span class="hljs-number">0</span>;
  }
}

<span class="hljs-keyword">const</span> stack = <span class="hljs-keyword">new</span> Stack();
stack.push(<span class="hljs-string">&quot;1&quot;</span>);
stack.push(<span class="hljs-string">&quot;2&quot;</span>);
stack.push(<span class="hljs-string">&quot;3&quot;</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;stack.size()&quot;</span>, stack.size());
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;stack.peek&quot;</span>, stack.peek());
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;stack.pop()&quot;</span>, stack.pop());
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;stack.peek()&quot;</span>, stack.peek());
stack.push(<span class="hljs-string">&quot;4&quot;</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;stack.peek&quot;</span>, stack.peek());
stack.clear();
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;stack.size&quot;</span>, stack.size());
stack.push(<span class="hljs-string">&quot;5&quot;</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;stack.peek&quot;</span>, stack.peek());
</code></pre>
<h3 id="t291.7 &#x4F4D;&#x8FD0;&#x7B97;">1.7 &#x4F4D;&#x8FD0;&#x7B97; <a href="#t291.7 &#x4F4D;&#x8FD0;&#x7B97;"> # </a></h3>
<h4 id="t301.7.1 &#x6BD4;&#x7279;">1.7.1 &#x6BD4;&#x7279; <a href="#t301.7.1 &#x6BD4;&#x7279;"> # </a></h4>
<ul>
<li>&#x6BD4;&#x7279;(bit)&#x662F;&#x8868;&#x793A;&#x4FE1;&#x606F;&#x7684;&#x6700;&#x5C0F;&#x5355;&#x4F4D;</li>
<li>&#x6BD4;&#x7279;(bit)&#x662F;&#x4E8C;&#x8FDB;&#x5236;&#x5355;&#x4F4D;(binary unit)&#x7684;&#x7F29;&#x5199;</li>
<li>&#x6BD4;&#x7279;(bit)&#x53EA;&#x6709;&#x4E24;&#x79CD;&#x72B6;&#x6001;&#xFF1A;0 &#x548C; 1</li>
<li>&#x4E00;&#x822C;&#x6765;&#x8BF4; n &#x6BD4;&#x7279;&#x7684;&#x4FE1;&#x606F;&#x91CF;&#x53EF;&#x4EE5;&#x8868;&#x793A;&#x51FA; 2 &#x7684; n &#x6B21;&#x65B9;&#x79CD;&#x9009;&#x62E9;</li>
</ul>
<p><img src="./assets/img/fc904d57e3ecbb7aac516c10caa5e9d1.png" alt="bit"></p>
<pre><code class="lang-js"><span class="hljs-number">0b1000</span>=<span class="hljs-number">2</span>*<span class="hljs-number">2</span>*<span class="hljs-number">2</span>=<span class="hljs-built_in">Math</span>.pow(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)=<span class="hljs-number">8</span>
</code></pre>
<h4 id="t311.7.2 &#x4F4D;&#x8FD0;&#x7B97;">1.7.2 &#x4F4D;&#x8FD0;&#x7B97; <a href="#t311.7.2 &#x4F4D;&#x8FD0;&#x7B97;"> # </a></h4>
<ul>
<li><a href="https://262.ecma-international.org/5.1/#sec-11.10">Binary Bitwise Operators</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Bitwise_AND">&#x6309;&#x4F4D;&#x4E0E;</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Bitwise_OR">&#x6309;&#x4F4D;&#x6216;</a></li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">&#x8FD0;&#x7B97;</th>
<th style="text-align:left">&#x4F7F;&#x7528;</th>
<th style="text-align:left">&#x8BF4;&#x660E;</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">&#x6309;&#x4F4D;&#x4E0E;(&amp;)</td>
<td style="text-align:left">x &amp; y</td>
<td style="text-align:left">&#x6BCF;&#x4E00;&#x4E2A;&#x6BD4;&#x7279;&#x4F4D;&#x90FD;&#x4E3A; 1 &#x65F6;&#xFF0C;&#x7ED3;&#x679C;&#x4E3A; 1&#xFF0C;&#x5426;&#x5219;&#x4E3A; 0</td>
</tr>
<tr>
<td style="text-align:left">&#x6309;&#x4F4D;&#x6216;(<img src="./assets/img/a055c887ea9e7b6fd8eaf97b7e617e51.png" alt>)</td>
<td style="text-align:left">x <img src="./assets/img/a055c887ea9e7b6fd8eaf97b7e617e51.png" alt> y</td>
<td style="text-align:left">&#x6BCF;&#x4E00;&#x4E2A;&#x6BD4;&#x7279;&#x4F4D;&#x90FD;&#x4E3A; 0 &#x65F6;&#xFF0C;&#x7ED3;&#x679C;&#x4E3A; 0&#xFF0C;&#x5426;&#x5219;&#x4E3A; 1</td>
</tr>
</tbody>
</table>
<h4 id="t321.7.3 &#x4F7F;&#x7528;">1.7.3 &#x4F7F;&#x7528; <a href="#t321.7.3 &#x4F7F;&#x7528;"> # </a></h4>
<pre><code class="lang-js"><span class="hljs-comment">//&#x5B9A;&#x4E49;&#x5E38;&#x91CF;</span>
<span class="hljs-keyword">const</span> Placement = <span class="hljs-number">0b001</span>; <span class="hljs-comment">// 0b001</span>
<span class="hljs-keyword">const</span> Update = <span class="hljs-number">0b010</span>; <span class="hljs-comment">// 0b010</span>
<span class="hljs-comment">//&#x5B9A;&#x4E49;&#x64CD;&#x4F5C;</span>
<span class="hljs-keyword">let</span> flags = <span class="hljs-number">0b000</span>;
<span class="hljs-comment">//&#x589E;&#x52A0;&#x64CD;&#x4F5C;</span>
flags |= Placement;
flags |= Update;
<span class="hljs-built_in">console</span>.log(flags.toString(<span class="hljs-number">2</span>)); <span class="hljs-comment">//0b11</span>
<span class="hljs-comment">//&#x5220;&#x9664;&#x64CD;&#x4F5C;</span>
flags = flags &amp; ~Placement;
<span class="hljs-built_in">console</span>.log(flags.toString(<span class="hljs-number">2</span>)); <span class="hljs-comment">//0b10</span>
<span class="hljs-comment">//&#x5224;&#x65AD;&#x5305;&#x542B;</span>
<span class="hljs-built_in">console</span>.log((flags &amp; Placement) === Placement);
<span class="hljs-built_in">console</span>.log((flags &amp; Update) === Update);
<span class="hljs-comment">//&#x5224;&#x65AD;&#x4E0D;&#x5305;&#x542B;</span>
<span class="hljs-built_in">console</span>.log((flags &amp; Placement) === <span class="hljs-number">0</span>);
<span class="hljs-built_in">console</span>.log((flags &amp; Update) === <span class="hljs-number">0</span>);
</code></pre>
<h3 id="t331.8 &#x4E8B;&#x4EF6;">1.8 &#x4E8B;&#x4EF6; <a href="#t331.8 &#x4E8B;&#x4EF6;"> # </a></h3>
<ul>
<li>&#x4E8B;&#x4EF6;&#x662F;&#x7528;&#x6237;&#x6216;&#x6D4F;&#x89C8;&#x5668;&#x81EA;&#x8EAB;&#x6267;&#x884C;&#x7684;&#x67D0;&#x79CD;&#x52A8;&#x4F5C;&#xFF0C;&#x800C;&#x54CD;&#x5E94;&#x67D0;&#x4E2A;&#x4E8B;&#x4EF6;&#x7684;&#x51FD;&#x6570;&#x53EB;&#x505A;&#x4E8B;&#x4EF6;&#x5904;&#x7406;&#x7A0B;&#x5E8F;</li>
</ul>
<h4 id="t341.8.1 DOM &#x4E8B;&#x4EF6;&#x6D41;">1.8.1 DOM &#x4E8B;&#x4EF6;&#x6D41; <a href="#t341.8.1 DOM &#x4E8B;&#x4EF6;&#x6D41;"> # </a></h4>
<p><img src="./assets/img/28cea27dea871132744000a586104cb6.jpg" alt="eventflow"></p>
<ul>
<li>&#x4E8B;&#x4EF6;&#x6D41;&#x5305;&#x542B;&#x4E09;&#x4E2A;&#x9636;&#x6BB5;<ul>
<li>&#x4E8B;&#x4EF6;&#x6355;&#x83B7;&#x9636;&#x6BB5;</li>
<li>&#x5904;&#x4E8E;&#x76EE;&#x6807;&#x9636;&#x6BB5;</li>
<li>&#x4E8B;&#x4EF6;&#x5192;&#x6CE1;&#x9636;&#x6BB5;</li>
</ul>
</li>
<li>&#x9996;&#x5148;&#x53D1;&#x751F;&#x7684;&#x662F;&#x4E8B;&#x4EF6;&#x6355;&#x83B7;&#xFF0C;&#x7136;&#x540E;&#x662F;&#x5B9E;&#x9645;&#x7684;&#x76EE;&#x6807;&#x63A5;&#x6536;&#x5230;&#x4E8B;&#x4EF6;&#xFF0C;&#x6700;&#x540E;&#x9636;&#x6BB5;&#x662F;&#x5192;&#x6CE1;&#x9636;&#x6BB5;</li>
</ul>
<h4 id="t351.8.2 &#x4E8B;&#x4EF6;&#x6355;&#x83B7;">1.8.2 &#x4E8B;&#x4EF6;&#x6355;&#x83B7; <a href="#t351.8.2 &#x4E8B;&#x4EF6;&#x6355;&#x83B7;"> # </a></h4>
<ul>
<li>&#x662F;&#x5148;&#x7531;&#x6700;&#x4E0A;&#x4E00;&#x7EA7;&#x7684;&#x8282;&#x70B9;&#x5148;&#x63A5;&#x6536;&#x4E8B;&#x4EF6;,&#x7136;&#x540E;&#x5411;&#x4E0B;&#x4F20;&#x64AD;&#x5230;&#x5177;&#x4F53;&#x7684;&#x8282;&#x70B9; <code>document-&gt;body-&gt;div-&gt;button</code></li>
</ul>
<h4 id="t361.8.3 &#x76EE;&#x6807;&#x9636;&#x6BB5;">1.8.3 &#x76EE;&#x6807;&#x9636;&#x6BB5; <a href="#t361.8.3 &#x76EE;&#x6807;&#x9636;&#x6BB5;"> # </a></h4>
<ul>
<li>&#x5728;&#x76EE;&#x6807;&#x8282;&#x70B9;&#x4E0A;&#x89E6;&#x53D1;,&#x79F0;&#x4E3A;&#x76EE;&#x6807;&#x9636;&#x6BB5;</li>
<li>&#x4E8B;&#x4EF6;&#x76EE;&#x6807;&#x662F;&#x771F;&#x6B63;&#x89E6;&#x53D1;&#x4E8B;&#x4EF6;&#x7684;&#x5BF9;&#x8C61;</li>
</ul>
<pre><code class="lang-js"><span class="hljs-comment">//w3c&#x6D4F;&#x89C8;&#x5668;&#xFF1A;event.target</span>
<span class="hljs-comment">//IE6&#x3001;7&#x3001;8&#xFF1A; event.srcElement</span>
<span class="hljs-keyword">let</span> target = event.target || event.srcElement;
</code></pre>
<h4 id="t371.8.4 &#x4E8B;&#x4EF6;&#x5192;&#x6CE1;">1.8.4 &#x4E8B;&#x4EF6;&#x5192;&#x6CE1; <a href="#t371.8.4 &#x4E8B;&#x4EF6;&#x5192;&#x6CE1;"> # </a></h4>
<ul>
<li>&#x4E8B;&#x4EF6;&#x5F00;&#x59CB;&#x65F6;&#x7531;&#x6700;&#x5177;&#x4F53;&#x7684;&#x5143;&#x7D20;(&#x6587;&#x6863;&#x4E2D;&#x5D4C;&#x5957;&#x5C42;&#x6B21;&#x6700;&#x6DF1;&#x7684;&#x90A3;&#x4E2A;&#x8282;&#x70B9;)&#x63A5;&#x6536;,&#x7136;&#x540E;&#x9010;&#x7EA7;&#x5411;&#x4E0A;&#x4F20;&#x64AD; <code>button-&gt;div-&gt;body-&gt;document</code></li>
</ul>
<h4 id="t381.8.5 addEventListener">1.8.5 addEventListener <a href="#t381.8.5 addEventListener"> # </a></h4>
<ul>
<li>&#x4EFB;&#x4F55;&#x53D1;&#x751F;&#x5728; W3C &#x4E8B;&#x4EF6;&#x6A21;&#x578B;&#x4E2D;&#x7684;&#x4E8B;&#x4EF6;&#xFF0C;&#x9996;&#x662F;&#x8FDB;&#x5165;&#x6355;&#x83B7;&#x9636;&#x6BB5;&#xFF0C;&#x76F4;&#x5230;&#x8FBE;&#x5230;&#x76EE;&#x6807;&#x5143;&#x7D20;&#xFF0C;&#x518D;&#x8FDB;&#x5165;&#x5192;&#x6CE1;&#x9636;&#x6BB5;</li>
<li>&#x53EF;&#x4EE5;&#x9009;&#x62E9;&#x662F;&#x5728;&#x6355;&#x83B7;&#x9636;&#x6BB5;&#x8FD8;&#x662F;&#x5192;&#x6CE1;&#x9636;&#x6BB5;&#x7ED1;&#x5B9A;&#x4E8B;&#x4EF6;&#x5904;&#x7406;&#x51FD;&#x6570;</li>
<li><code>useCapture</code>&#x53C2;&#x6570;&#x662F;<code>true</code>&#xFF0C;&#x5219;&#x5728;&#x6355;&#x83B7;&#x9636;&#x6BB5;&#x7ED1;&#x5B9A;&#x51FD;&#x6570;&#xFF0C;&#x53CD;&#x4E4B;<code>false</code>&#xFF0C;&#x5728;&#x5192;&#x6CE1;&#x9636;&#x6BB5;&#x7ED1;&#x5B9A;&#x51FD;&#x6570;</li>
</ul>
<pre><code class="lang-js">element.addEventListener(event, <span class="hljs-function"><span class="hljs-keyword">function</span>, <span class="hljs-title">useCapture</span>)
</span></code></pre>
<h4 id="t391.8.6 &#x963B;&#x6B62;&#x5192;&#x6CE1;">1.8.6 &#x963B;&#x6B62;&#x5192;&#x6CE1; <a href="#t391.8.6 &#x963B;&#x6B62;&#x5192;&#x6CE1;"> # </a></h4>
<ul>
<li>&#x5982;&#x679C;&#x60F3;&#x8981;&#x963B;&#x6B62;&#x4E8B;&#x4EF6;&#x7684;&#x4F20;&#x64AD;<ul>
<li>&#x5728;&#x5FAE;&#x8F6F;&#x7684;&#x6A21;&#x578B;&#x4E2D;&#x4F60;&#x5FC5;&#x987B;&#x8BBE;&#x7F6E;&#x4E8B;&#x4EF6;&#x7684;<code>cancelBubble</code>&#x7684;&#x5C5E;&#x6027;&#x4E3A; true</li>
<li>&#x5728; W3C &#x6A21;&#x578B;&#x4E2D;&#x4F60;&#x5FC5;&#x987B;&#x8C03;&#x7528;&#x4E8B;&#x4EF6;&#x7684;<code>stopPropagation()</code>&#x65B9;&#x6CD5;</li>
</ul>
</li>
</ul>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">stopPropagation</span>(<span class="hljs-params">event</span>) </span>{
  <span class="hljs-keyword">if</span> (!event) {
    <span class="hljs-built_in">window</span>.event.cancelBubble = <span class="hljs-literal">true</span>;
  }
  <span class="hljs-keyword">if</span> (event.stopPropagation) {
    event.stopPropagation();
  }
}
</code></pre>
<h4 id="t401.8.7 &#x963B;&#x6B62;&#x9ED8;&#x8BA4;&#x884C;&#x4E3A;">1.8.7 &#x963B;&#x6B62;&#x9ED8;&#x8BA4;&#x884C;&#x4E3A; <a href="#t401.8.7 &#x963B;&#x6B62;&#x9ED8;&#x8BA4;&#x884C;&#x4E3A;"> # </a></h4>
<ul>
<li>&#x53D6;&#x6D88;&#x9ED8;&#x8BA4;&#x4E8B;&#x4EF6;</li>
</ul>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">preventDefault</span>(<span class="hljs-params">event</span>) </span>{
  <span class="hljs-keyword">if</span> (!event) {
    <span class="hljs-built_in">window</span>.event.returnValue = <span class="hljs-literal">false</span>;
  }
  <span class="hljs-keyword">if</span> (event.preventDefault) {
    event.preventDefault();
  }
}
</code></pre>
<h4 id="t411.8.8 &#x4E8B;&#x4EF6;&#x4EE3;&#x7406;">1.8.8 &#x4E8B;&#x4EF6;&#x4EE3;&#x7406; <a href="#t411.8.8 &#x4E8B;&#x4EF6;&#x4EE3;&#x7406;"> # </a></h4>
<ul>
<li>&#x4E8B;&#x4EF6;&#x4EE3;&#x7406;&#x53C8;&#x79F0;&#x4E4B;&#x4E3A;&#x4E8B;&#x4EF6;&#x59D4;&#x6258;</li>
<li>&#x4E8B;&#x4EF6;&#x4EE3;&#x7406;&#x662F;&#x628A;&#x539F;&#x672C;&#x9700;&#x8981;&#x7ED1;&#x5B9A;&#x5728;<code>&#x5B50;&#x5143;&#x7D20;</code>&#x7684;&#x4E8B;&#x4EF6;&#x59D4;&#x6258;&#x7ED9;<code>&#x7236;&#x5143;&#x7D20;</code>&#xFF0C;&#x8BA9;&#x7236;&#x5143;&#x7D20;&#x8D1F;&#x8D23;&#x4E8B;&#x4EF6;&#x76D1;&#x542C;</li>
<li>&#x4E8B;&#x4EF6;&#x4EE3;&#x7406;&#x662F;&#x5229;&#x7528;<code>&#x4E8B;&#x4EF6;&#x5192;&#x6CE1;</code>&#x6765;&#x5B9E;&#x73B0;&#x7684;</li>
<li>&#x4F18;&#x70B9;<ul>
<li>&#x53EF;&#x4EE5;&#x5927;&#x91CF;&#x8282;&#x7701;&#x5185;&#x5B58;&#x5360;&#x7528;&#xFF0C;&#x51CF;&#x5C11;&#x4E8B;&#x4EF6;&#x6CE8;&#x518C;</li>
<li>&#x5F53;&#x65B0;&#x589E;&#x5B50;&#x5BF9;&#x8C61;&#x65F6;&#x65E0;&#x9700;&#x518D;&#x6B21;&#x5BF9;&#x5176;&#x7ED1;&#x5B9A;</li>
</ul>
</li>
</ul>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;list&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;show(event)&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>item 1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>item 2<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>item 3<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>item n<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="actionscript">
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">show</span><span class="hljs-params">(event)</span> </span>{
      alert(event.target.innerHTML);
    }
  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
</code></pre>
<h4 id="t421.8.9 &#x4E8B;&#x4EF6;&#x7CFB;&#x7EDF;">1.8.9 &#x4E8B;&#x4EF6;&#x7CFB;&#x7EDF; <a href="#t421.8.9 &#x4E8B;&#x4EF6;&#x7CFB;&#x7EDF;"> # </a></h4>
<ul>
<li>&#x5408;&#x6210;&#x4E8B;&#x4EF6;&#x662F;&#x56F4;&#x7ED5;&#x6D4F;&#x89C8;&#x5668;&#x539F;&#x751F;&#x4E8B;&#x4EF6;&#x5145;&#x5F53;&#x8DE8;&#x6D4F;&#x89C8;&#x5668;&#x5305;&#x88C5;&#x5668;&#x7684;&#x5BF9;&#x8C61;,&#x5B83;&#x4EEC;&#x5C06;&#x4E0D;&#x540C;&#x6D4F;&#x89C8;&#x5668;&#x7684;&#x884C;&#x4E3A;&#x5408;&#x5E76;&#x4E3A;&#x4E00;&#x4E2A; API,&#x8FD9;&#x6837;&#x505A;&#x662F;&#x4E3A;&#x4E86;&#x786E;&#x4FDD;&#x4E8B;&#x4EF6;&#x5728;&#x4E0D;&#x540C;&#x6D4F;&#x89C8;&#x5668;&#x4E2D;&#x663E;&#x793A;&#x4E00;&#x81F4;&#x7684;&#x5C5E;&#x6027;</li>
</ul>
<h5 id="t431.8.10.1 &#x4F7F;&#x7528;">1.8.10.1 &#x4F7F;&#x7528; <a href="#t431.8.10.1 &#x4F7F;&#x7528;"> # </a></h5>
<p><img src="./assets/img/2212a210820d242763044d7d5fc76374.jpg" alt="eventuse"></p>
<pre><code class="lang-js"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-dom&quot;</span>;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  parentRef = React.createRef();
  childRef = React.createRef();
  componentDidMount() {
    <span class="hljs-keyword">this</span>.parentRef.current.addEventListener(
      <span class="hljs-string">&quot;click&quot;</span>,
      () =&gt; {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;&#x7236;&#x5143;&#x7D20;&#x539F;&#x751F;&#x6355;&#x83B7;&quot;</span>);
      },
      <span class="hljs-literal">true</span>
    );
    <span class="hljs-keyword">this</span>.parentRef.current.addEventListener(<span class="hljs-string">&quot;click&quot;</span>, () =&gt; {
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;&#x7236;&#x5143;&#x7D20;&#x539F;&#x751F;&#x5192;&#x6CE1;&quot;</span>);
    });
    <span class="hljs-keyword">this</span>.childRef.current.addEventListener(
      <span class="hljs-string">&quot;click&quot;</span>,
      () =&gt; {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;&#x5B50;&#x5143;&#x7D20;&#x539F;&#x751F;&#x6355;&#x83B7;&quot;</span>);
      },
      <span class="hljs-literal">true</span>
    );
    <span class="hljs-keyword">this</span>.childRef.current.addEventListener(<span class="hljs-string">&quot;click&quot;</span>, () =&gt; {
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;&#x5B50;&#x5143;&#x7D20;&#x539F;&#x751F;&#x5192;&#x6CE1;&quot;</span>);
    });
    <span class="hljs-built_in">document</span>.addEventListener(
      <span class="hljs-string">&quot;click&quot;</span>,
      () =&gt; {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;document&#x539F;&#x751F;&#x6355;&#x83B7;&quot;</span>);
      },
      <span class="hljs-literal">true</span>
    );
    <span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&quot;click&quot;</span>, () =&gt; {
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;document&#x539F;&#x751F;&#x5192;&#x6CE1;&quot;</span>);
    });
  }
  parentBubble = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;&#x7236;&#x5143;&#x7D20;React&#x4E8B;&#x4EF6;&#x5192;&#x6CE1;&quot;</span>);
  };
  childBubble = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;&#x5B50;&#x5143;&#x7D20;React&#x4E8B;&#x4EF6;&#x5192;&#x6CE1;&quot;</span>);
  };
  parentCapture = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;&#x7236;&#x5143;&#x7D20;React&#x4E8B;&#x4EF6;&#x6355;&#x83B7;&quot;</span>);
  };
  childCapture = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;&#x5B50;&#x5143;&#x7D20;React&#x4E8B;&#x4EF6;&#x6355;&#x83B7;&quot;</span>);
  };
  render() {
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">{this.parentRef}</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{this.parentBubble}</span> <span class="hljs-attr">onClickCapture</span>=<span class="hljs-string">{this.parentCapture}</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">{this.childRef}</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{this.childBubble}</span> <span class="hljs-attr">onClickCapture</span>=<span class="hljs-string">{this.childCapture}</span>&gt;</span>
          &#x4E8B;&#x4EF6;&#x6267;&#x884C;&#x987A;&#x5E8F;
        <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
    );
  }
}
ReactDOM.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span>, <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;root&quot;</span>));
<span class="hljs-comment">/**
document&#x539F;&#x751F;&#x6355;&#x83B7;
&#x7236;&#x5143;&#x7D20;React&#x4E8B;&#x4EF6;&#x6355;&#x83B7;
&#x5B50;&#x5143;&#x7D20;React&#x4E8B;&#x4EF6;&#x6355;&#x83B7;
&#x7236;&#x5143;&#x7D20;&#x539F;&#x751F;&#x6355;&#x83B7;
&#x5B50;&#x5143;&#x7D20;&#x539F;&#x751F;&#x6355;&#x83B7;
&#x5B50;&#x5143;&#x7D20;&#x539F;&#x751F;&#x5192;&#x6CE1;
&#x7236;&#x5143;&#x7D20;&#x539F;&#x751F;&#x5192;&#x6CE1;
&#x5B50;&#x5143;&#x7D20;React&#x4E8B;&#x4EF6;&#x5192;&#x6CE1;
&#x7236;&#x5143;&#x7D20;React&#x4E8B;&#x4EF6;&#x5192;&#x6CE1;
document&#x539F;&#x751F;&#x5192;&#x6CE1;
 */</span>
</code></pre>
<h5 id="t441.8.10.2 &#x7B80;&#x6613;&#x5B9E;&#x73B0;">1.8.10.2 &#x7B80;&#x6613;&#x5B9E;&#x73B0; <a href="#t441.8.10.2 &#x7B80;&#x6613;&#x5B9E;&#x73B0;"> # </a></h5>
<pre><code class="lang-html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>event<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;root&quot;</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;parent&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;child&quot;</span>&gt;</span>&#x70B9;&#x51FB;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
      <span class="hljs-keyword">let</span> root = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;root&quot;</span>);
      <span class="hljs-keyword">let</span> parent = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;parent&quot;</span>);
      <span class="hljs-keyword">let</span> child = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;child&quot;</span>);
      <span class="hljs-comment">//listenToNativeEvent(&apos;click&apos;,false,root);</span>
      <span class="hljs-comment">//listenToNativeEvent( &apos;click&apos;,true,root);</span>

      <span class="hljs-comment">//root&#x7684;&#x6355;&#x83B7;&#x9636;&#x6BB5;&#x7684;&#x5904;&#x7406;&#x51FD;&#x6570;</span>
      root.addEventListener(<span class="hljs-string">&quot;click&quot;</span>, (event) =&gt; dispatchEvent(event, <span class="hljs-literal">true</span>), <span class="hljs-literal">true</span>);
      <span class="hljs-comment">//root&#x7684;&#x5192;&#x6CE1;&#x9636;&#x6BB5;&#x7684;&#x5904;&#x7406;&#x51FD;&#x6570;</span>
      root.addEventListener(<span class="hljs-string">&quot;click&quot;</span>, (event) =&gt; dispatchEvent(event, <span class="hljs-literal">false</span>), <span class="hljs-literal">false</span>);
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dispatchEvent</span>(<span class="hljs-params">event, isCapture</span>) </span>{
        <span class="hljs-comment">//console.log(event,isCapture);</span>
        <span class="hljs-keyword">let</span> paths = []; <span class="hljs-comment">//&#x4E8B;&#x4EF6;&#x7684;&#x4F20;&#x64AD;&#x8DEF;&#x5F84;&#x6570;&#x7EC4;[child,parent,root,body,document]</span>
        <span class="hljs-keyword">let</span> currentTarget = event.target; <span class="hljs-comment">//&#x4E8B;&#x4EF6;&#x6E90;</span>
        <span class="hljs-keyword">while</span> (currentTarget) {
          paths.push(currentTarget);
          currentTarget = currentTarget.parentNode;
        }
        <span class="hljs-keyword">if</span> (isCapture) {
          <span class="hljs-comment">//&#x5982;&#x679C;&#x5F53;&#x524D;&#x662F;&#x6355;&#x83B7;&#x9636;&#x6BB5;</span>
          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = paths.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) {
            <span class="hljs-comment">//[document,body,root,parent.child]</span>
            <span class="hljs-keyword">let</span> handler = paths[i].onClickCapture; <span class="hljs-comment">//react&#x6355;&#x83B7;&#x4E8B;&#x4EF6;</span>
            handler &amp;&amp; handler();
          }
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; paths.length; i++) {
            <span class="hljs-comment">//[child,parent,root,body,document]</span>
            <span class="hljs-keyword">let</span> handler = paths[i].onClick; <span class="hljs-comment">//react&#x5192;&#x6CE1;&#x4E8B;&#x4EF6;</span>
            handler &amp;&amp; handler();
          }
        }
      }
      root.addEventListener(<span class="hljs-string">&quot;click&quot;</span>, (event) =&gt; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;&#x6839;&#x5143;&#x7D20;&#x539F;&#x751F;&#x4E8B;&#x4EF6;&#x6355;&#x83B7;&quot;</span>), <span class="hljs-literal">true</span>);
      root.addEventListener(<span class="hljs-string">&quot;click&quot;</span>, (event) =&gt; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;&#x6839;&#x5143;&#x7D20;&#x539F;&#x751F;&#x4E8B;&#x4EF6;&#x5192;&#x6CE1;&quot;</span>), <span class="hljs-literal">false</span>);
      parent.addEventListener(
        <span class="hljs-string">&quot;click&quot;</span>,
        () =&gt; {
          <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;&#x7236;&#x5143;&#x7D20;&#x539F;&#x751F;&#x4E8B;&#x4EF6;&#x6355;&#x83B7;&quot;</span>);
        },
        <span class="hljs-literal">true</span>
      );
      parent.addEventListener(
        <span class="hljs-string">&quot;click&quot;</span>,
        () =&gt; {
          <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;&#x7236;&#x5143;&#x7D20;&#x539F;&#x751F;&#x4E8B;&#x4EF6;&#x5192;&#x6CE1;&quot;</span>);
        },
        <span class="hljs-literal">false</span>
      );
      child.addEventListener(
        <span class="hljs-string">&quot;click&quot;</span>,
        () =&gt; {
          <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;&#x5B50;&#x5143;&#x7D20;&#x539F;&#x751F;&#x4E8B;&#x4EF6;&#x6355;&#x83B7;&quot;</span>);
        },
        <span class="hljs-literal">true</span>
      );
      child.addEventListener(
        <span class="hljs-string">&quot;click&quot;</span>,
        () =&gt; {
          <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;&#x5B50;&#x5143;&#x7D20;&#x539F;&#x751F;&#x4E8B;&#x4EF6;&#x5192;&#x6CE1;&quot;</span>);
        },
        <span class="hljs-literal">false</span>
      );
      parent.onClick = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;React:&#x7236;&#x5143;&#x7D20;React&#x4E8B;&#x4EF6;&#x5192;&#x6CE1;&quot;</span>);
      };
      parent.onClickCapture = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;React:&#x7236;&#x5143;&#x7D20;React&#x4E8B;&#x4EF6;&#x6355;&#x83B7;&quot;</span>);
      };
      child.onClick = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;React:&#x5B50;&#x5143;&#x7D20;React&#x4E8B;&#x4EF6;&#x5192;&#x6CE1;&quot;</span>);
      };
      child.onClickCapture = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;React:&#x5B50;&#x5143;&#x7D20;React&#x4E8B;&#x4EF6;&#x6355;&#x83B7;&quot;</span>);
      };
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>
<h3 id="t451.9 &#x6700;&#x5C0F;&#x5806;">1.9 &#x6700;&#x5C0F;&#x5806; <a href="#t451.9 &#x6700;&#x5C0F;&#x5806;"> # </a></h3>
<p><img src="./assets/img/e804e6500867838ed4956d0c3180e429.png" style="width:20%"></p>
<h4 id="t461.9.1 &#x4E8C;&#x53C9;&#x6811;">1.9.1 &#x4E8C;&#x53C9;&#x6811; <a href="#t461.9.1 &#x4E8C;&#x53C9;&#x6811;"> # </a></h4>
<ul>
<li>&#x6BCF;&#x4E2A;&#x8282;&#x70B9;&#x6700;&#x591A;&#x6709;&#x4E24;&#x4E2A;&#x5B50;&#x8282;&#x70B9;</li>
</ul>
<p><img src="./assets/img/6a8f8c54bef310f54b03975aa4b3abd2.jpg" alt></p>
<h4 id="t471.9.2 &#x6EE1;&#x4E8C;&#x53C9;&#x6811;">1.9.2 &#x6EE1;&#x4E8C;&#x53C9;&#x6811; <a href="#t471.9.2 &#x6EE1;&#x4E8C;&#x53C9;&#x6811;"> # </a></h4>
<ul>
<li>&#x9664;&#x6700;&#x540E;&#x4E00;&#x5C42;&#x65E0;&#x4EFB;&#x4F55;&#x5B50;&#x8282;&#x70B9;&#x5916;&#xFF0C;&#x6BCF;&#x4E00;&#x5C42;&#x4E0A;&#x7684;&#x6240;&#x6709;&#x7ED3;&#x70B9;&#x90FD;&#x6709;&#x4E24;&#x4E2A;&#x5B50;&#x7ED3;&#x70B9;&#x7684;&#x4E8C;&#x53C9;&#x6811;</li>
</ul>
<p><img src="./assets/img/75dab6680a055d82134e948b5f63f0aa.jpg" alt></p>
<h4 id="t481.9.3 &#x5B8C;&#x5168;&#x4E8C;&#x53C9;&#x6811;">1.9.3 &#x5B8C;&#x5168;&#x4E8C;&#x53C9;&#x6811; <a href="#t481.9.3 &#x5B8C;&#x5168;&#x4E8C;&#x53C9;&#x6811;"> # </a></h4>
<ul>
<li>&#x53F6;&#x5B50;&#x7ED3;&#x70B9;&#x53EA;&#x80FD;&#x51FA;&#x73B0;&#x5728;&#x6700;&#x4E0B;&#x5C42;&#x548C;&#x6B21;&#x4E0B;&#x5C42;</li>
<li>&#x4E14;&#x6700;&#x4E0B;&#x5C42;&#x7684;&#x53F6;&#x5B50;&#x7ED3;&#x70B9;&#x96C6;&#x4E2D;&#x5728;&#x6811;&#x7684;&#x5DE6;&#x90E8;</li>
</ul>
<p><img src="./assets/img/f60da665d8426655f6bd40aa052cfa88.jpg" alt></p>
<h4 id="t491.9.4 &#x6700;&#x5C0F;&#x5806;">1.9.4 &#x6700;&#x5C0F;&#x5806; <a href="#t491.9.4 &#x6700;&#x5C0F;&#x5806;"> # </a></h4>
<ul>
<li><a href="https://www.processon.com/diagraming/61f26156e0b34d06c3b5bf48">processon</a></li>
<li>&#x6700;&#x5C0F;&#x5806;&#x662F;&#x4E00;&#x79CD;&#x7ECF;&#x8FC7;&#x6392;&#x5E8F;&#x7684;&#x5B8C;&#x5168;&#x4E8C;&#x53C9;&#x6811;</li>
<li>&#x5176;&#x4E2D;&#x4EFB;&#x4E00;&#x975E;&#x7EC8;&#x7AEF;&#x8282;&#x70B9;&#x7684;&#x6570;&#x636E;&#x503C;&#x5747;&#x4E0D;&#x5927;&#x4E8E;&#x5176;&#x5DE6;&#x5B50;&#x8282;&#x70B9;&#x548C;&#x53F3;&#x5B50;&#x8282;&#x70B9;&#x7684;&#x503C;</li>
<li>&#x6839;&#x7ED3;&#x70B9;&#x503C;&#x662F;&#x6240;&#x6709;&#x5806;&#x7ED3;&#x70B9;&#x503C;&#x4E2D;&#x6700;&#x5C0F;&#x8005;</li>
<li>&#x7F16;&#x53F7;&#x5173;&#x7CFB;<ul>
<li>&#x5DE6;&#x5B50;&#x8282;&#x70B9;&#x7F16;&#x53F7;=&#x7236;&#x8282;&#x70B9;&#x7F16;&#x53F7;<em>2  1</em>2=2</li>
<li>&#x53F3;&#x5B50;&#x8282;&#x70B9;&#x7F16;&#x53F7;=&#x5DE6;&#x5B50;&#x8282;&#x70B9;&#x7F16;&#x53F7;+1</li>
<li>&#x7236;&#x8282;&#x70B9;&#x7F16;&#x53F7;=&#x5B50;&#x8282;&#x70B9;&#x7F16;&#x53F7;/2 2/2=1</li>
</ul>
</li>
<li>&#x7D22;&#x5F15;&#x5173;&#x7CFB;<ul>
<li>&#x5DE6;&#x5B50;&#x8282;&#x70B9;&#x7D22;&#x5F15;=(&#x7236;&#x8282;&#x70B9;&#x7D22;&#x5F15;+1)<em>2-1 (0+1)</em>2-1=1</li>
<li>&#x53F3;&#x5B50;&#x8282;&#x70B9;&#x7D22;&#x5F15;=&#x5DE6;&#x5B50;&#x8282;&#x70B9;&#x7D22;&#x5F15;+1 </li>
<li>&#x7236;&#x8282;&#x70B9;&#x7D22;&#x5F15;=(&#x5B50;&#x8282;&#x70B9;&#x7D22;&#x5F15;-1)/2 (1-1)/2=0</li>
</ul>
</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Unsigned_right_shift">Unsigned_right_shift</a></li>
</ul>
<p><img src="./assets/img/ca5181545f40636300463011c8916bff.jpg" alt></p>
<h4 id="t501.9.5 SchedulerMinHeap.js">1.9.5 SchedulerMinHeap.js <a href="#t501.9.5 SchedulerMinHeap.js"> # </a></h4>
<ul>
<li>peek() &#x67E5;&#x770B;&#x5806;&#x7684;&#x9876;&#x70B9;</li>
<li>pop() &#x5F39;&#x51FA;&#x5806;&#x7684;&#x5B9A;&#x70B9;&#x540E;&#x9700;&#x8981;&#x8C03;&#x7528;<code>siftDown</code>&#x51FD;&#x6570;&#x5411;&#x4E0B;&#x8C03;&#x6574;&#x5806;</li>
<li>push() &#x6DFB;&#x52A0;&#x65B0;&#x8282;&#x70B9;&#x540E;&#x9700;&#x8981;&#x8C03;&#x7528;<code>siftUp</code>&#x51FD;&#x6570;&#x5411;&#x4E0A;&#x8C03;&#x6574;&#x5806;</li>
<li>siftDown() &#x5411;&#x4E0B;&#x8C03;&#x6574;&#x5806;&#x7ED3;&#x6784;, &#x4FDD;&#x8BC1;&#x6700;&#x5C0F;&#x5806;</li>
<li>siftUp() &#x9700;&#x8981;&#x5411;&#x4E0A;&#x8C03;&#x6574;&#x5806;&#x7ED3;&#x6784;, &#x4FDD;&#x8BC1;&#x6700;&#x5C0F;&#x5806;</li>
</ul>
<p>react\packages\scheduler\src\SchedulerMinHeap.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">push</span>(<span class="hljs-params">heap, node</span>) </span>{
  <span class="hljs-keyword">const</span> index = heap.length;
  heap.push(node);
  siftUp(heap, node, index);
}
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">peek</span>(<span class="hljs-params">heap</span>) </span>{
  <span class="hljs-keyword">const</span> first = heap[<span class="hljs-number">0</span>];
  <span class="hljs-keyword">return</span> first === <span class="hljs-literal">undefined</span> ? <span class="hljs-literal">null</span> : first;
}
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pop</span>(<span class="hljs-params">heap</span>) </span>{
  <span class="hljs-keyword">const</span> first = heap[<span class="hljs-number">0</span>];
  <span class="hljs-keyword">if</span> (first !== <span class="hljs-literal">undefined</span>) {
    <span class="hljs-keyword">const</span> last = heap.pop();
    <span class="hljs-keyword">if</span> (last !== first) {
      heap[<span class="hljs-number">0</span>] = last;
      siftDown(heap, last, <span class="hljs-number">0</span>);
    }
    <span class="hljs-keyword">return</span> first;
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">siftUp</span>(<span class="hljs-params">heap, node, i</span>) </span>{
  <span class="hljs-keyword">let</span> index = i;
  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
    <span class="hljs-keyword">const</span> parentIndex = index - <span class="hljs-number">1</span> &gt;&gt;&gt; <span class="hljs-number">1</span>;
    <span class="hljs-keyword">const</span> parent = heap[parentIndex];
    <span class="hljs-keyword">if</span> (parent !== <span class="hljs-literal">undefined</span> &amp;&amp; compare(parent, node) &gt; <span class="hljs-number">0</span>) {
      heap[parentIndex] = node;
      heap[index] = parent;
      index = parentIndex;
    } <span class="hljs-keyword">else</span> {

      <span class="hljs-keyword">return</span>;
    }
  }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">siftDown</span>(<span class="hljs-params">heap, node, i</span>) </span>{
  <span class="hljs-keyword">let</span> index = i;
  <span class="hljs-keyword">const</span> length = heap.length;
  <span class="hljs-keyword">while</span> (index &lt; length) {
    <span class="hljs-keyword">const</span> leftIndex = (index + <span class="hljs-number">1</span>) * <span class="hljs-number">2</span> - <span class="hljs-number">1</span>;
    <span class="hljs-keyword">const</span> left = heap[leftIndex];
    <span class="hljs-keyword">const</span> rightIndex = leftIndex + <span class="hljs-number">1</span>;
    <span class="hljs-keyword">const</span> right = heap[rightIndex]; 
    <span class="hljs-keyword">if</span> (left !== <span class="hljs-literal">undefined</span> &amp;&amp; compare(left, node) &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">if</span> (right !== <span class="hljs-literal">undefined</span> &amp;&amp; compare(right, left) &lt; <span class="hljs-number">0</span>) {
        heap[index] = right;
        heap[rightIndex] = node;
        index = rightIndex;
      } <span class="hljs-keyword">else</span> {
        heap[index] = left;
        heap[leftIndex] = node;
        index = leftIndex;
      }
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (right !== <span class="hljs-literal">undefined</span> &amp;&amp; compare(right, node) &lt; <span class="hljs-number">0</span>) {
      heap[index] = right;
      heap[rightIndex] = node;
      index = rightIndex;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span>;
    }
  }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">compare</span>(<span class="hljs-params">a, b</span>) </span>{
  <span class="hljs-keyword">const</span> diff = a.sortIndex - b.sortIndex;
  <span class="hljs-keyword">return</span> diff !== <span class="hljs-number">0</span> ? diff : a.id - b.id;
}
</code></pre>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> { push, pop, peek } = <span class="hljs-built_in">require</span>(<span class="hljs-string">&apos;./SchedulerMinHeap&apos;</span>);
<span class="hljs-keyword">let</span> heap = [];
push(heap, { <span class="hljs-attr">sortIndex</span>: <span class="hljs-number">1</span> });
push(heap, { <span class="hljs-attr">sortIndex</span>: <span class="hljs-number">2</span> });
push(heap, { <span class="hljs-attr">sortIndex</span>: <span class="hljs-number">3</span> });
<span class="hljs-built_in">console</span>.log(peek(heap));
push(heap, { <span class="hljs-attr">sortIndex</span>: <span class="hljs-number">4</span> });
push(heap, { <span class="hljs-attr">sortIndex</span>: <span class="hljs-number">5</span> });
push(heap, { <span class="hljs-attr">sortIndex</span>: <span class="hljs-number">6</span> });
push(heap, { <span class="hljs-attr">sortIndex</span>: <span class="hljs-number">7</span> });
<span class="hljs-built_in">console</span>.log(peek(heap));
pop(heap);
<span class="hljs-built_in">console</span>.log(peek(heap));
</code></pre>
<h3 id="t511.10 MessageChannel">1.10 MessageChannel <a href="#t511.10 MessageChannel"> # </a></h3>
<ul>
<li>&#x76EE;&#x524D; <code>requestIdleCallback</code> &#x76EE;&#x524D;&#x53EA;&#x6709;Chrome&#x652F;&#x6301;</li>
<li>&#x6240;&#x4EE5;&#x76EE;&#x524D; React&#x5229;&#x7528; <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MessageChannel">MessageChannel</a>&#x6A21;&#x62DF;&#x4E86;requestIdleCallback&#xFF0C;&#x5C06;&#x56DE;&#x8C03;&#x5EF6;&#x8FDF;&#x5230;&#x7ED8;&#x5236;&#x64CD;&#x4F5C;&#x4E4B;&#x540E;&#x6267;&#x884C;</li>
<li>MessageChannel API&#x5141;&#x8BB8;&#x6211;&#x4EEC;&#x521B;&#x5EFA;&#x4E00;&#x4E2A;&#x65B0;&#x7684;&#x6D88;&#x606F;&#x901A;&#x9053;&#xFF0C;&#x5E76;&#x901A;&#x8FC7;&#x5B83;&#x7684;&#x4E24;&#x4E2A;MessagePort&#x5C5E;&#x6027;&#x53D1;&#x9001;&#x6570;&#x636E;</li>
<li>MessageChannel&#x521B;&#x5EFA;&#x4E86;&#x4E00;&#x4E2A;&#x901A;&#x4FE1;&#x7684;&#x7BA1;&#x9053;&#xFF0C;&#x8FD9;&#x4E2A;&#x7BA1;&#x9053;&#x6709;&#x4E24;&#x4E2A;&#x7AEF;&#x53E3;&#xFF0C;&#x6BCF;&#x4E2A;&#x7AEF;&#x53E3;&#x90FD;&#x53EF;&#x4EE5;&#x901A;&#x8FC7;postMessage&#x53D1;&#x9001;&#x6570;&#x636E;&#xFF0C;&#x800C;&#x4E00;&#x4E2A;&#x7AEF;&#x53E3;&#x53EA;&#x8981;&#x7ED1;&#x5B9A;&#x4E86;onmessage&#x56DE;&#x8C03;&#x65B9;&#x6CD5;&#xFF0C;&#x5C31;&#x53EF;&#x4EE5;&#x63A5;&#x6536;&#x4ECE;&#x53E6;&#x4E00;&#x4E2A;&#x7AEF;&#x53E3;&#x4F20;&#x8FC7;&#x6765;&#x7684;&#x6570;&#x636E;</li>
<li>MessageChannel&#x662F;&#x4E00;&#x4E2A;&#x5B8F;&#x4EFB;&#x52A1;</li>
</ul>
<p><img src="./assets/img/dd766c700a84587c359320a54b2f9e3d.jpg" alt></p>
<pre><code class="lang-js"><span class="hljs-keyword">var</span> channel = <span class="hljs-keyword">new</span> MessageChannel();
<span class="hljs-comment">//channel.port1</span>
<span class="hljs-comment">//channel.port2</span>
</code></pre>
<pre><code class="lang-js"><span class="hljs-keyword">var</span> channel = <span class="hljs-keyword">new</span> MessageChannel();
<span class="hljs-keyword">var</span> port1 = channel.port1;
<span class="hljs-keyword">var</span> port2 = channel.port2
port1.onmessage = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;port1&#x6536;&#x5230;&#x6765;&#x81EA;port2&#x7684;&#x6570;&#x636E;&#xFF1A;&quot;</span> + event.data);
}
port2.onmessage = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;port2&#x6536;&#x5230;&#x6765;&#x81EA;port1&#x7684;&#x6570;&#x636E;&#xFF1A;&quot;</span> + event.data);
}
port1.postMessage(<span class="hljs-string">&quot;&#x53D1;&#x9001;&#x7ED9;port2&quot;</span>);
port2.postMessage(<span class="hljs-string">&quot;&#x53D1;&#x9001;&#x7ED9;port1&quot;</span>);
</code></pre>
<h3 id="t521.11 &#x4E8C;&#x8FDB;&#x5236;">1.11 &#x4E8C;&#x8FDB;&#x5236; <a href="#t521.11 &#x4E8C;&#x8FDB;&#x5236;"> # </a></h3>
<ul>
<li>&#x8BA1;&#x7B97;&#x673A;&#x7528;&#x4E8C;&#x8FDB;&#x5236;&#x6765;&#x5B58;&#x50A8;&#x6570;&#x5B57;</li>
<li>&#x4E3A;&#x4E86;&#x7B80;&#x5316;&#x8FD0;&#x7B97;&#xFF0C;&#x4E8C;&#x8FDB;&#x5236;&#x6570;&#x90FD;&#x662F;&#x7528;&#x4E00;&#x4E2A;&#x5B57;&#x8282;(8&#x4E2A;&#x4E8C;&#x8FDB;&#x5236;&#x4F4D;)&#x6765;&#x7B80;&#x5316;&#x8BF4;&#x660E;</li>
<li><a href="unit.html">&#x5728;&#x7EBF;&#x5DE5;&#x5177;</a></li>
</ul>
<h4 id="t531.11.1 ES5&#x89C4;&#x8303;">1.11.1 ES5&#x89C4;&#x8303; <a href="#t531.11.1 ES5&#x89C4;&#x8303;"> # </a></h4>
<ul>
<li><a href="https://262.ecma-international.org/5.1/#sec-11.10">Binary Bitwise Operators</a></li>
<li><a href="https://262.ecma-international.org/5.1/#sec-9.5">ToInt32: (Signed 32 Bit Integer)</a></li>
<li>&#x4F4D;&#x8FD0;&#x7B97;&#x53EA;&#x652F;&#x6301;&#x6574;&#x6570;&#x8FD0;&#x7B97;</li>
<li>&#x4F4D;&#x8FD0;&#x7B97;&#x4E2D;&#x7684;&#x5DE6;&#x53F3;&#x64CD;&#x4F5C;&#x6570;&#x90FD;&#x4F1A;&#x8F6C;&#x6362;&#x4E3A;&#x6709;&#x7B26;&#x53F7;32&#x4F4D;&#x6574;&#x578B;, &#x4E14;&#x8FD4;&#x56DE;&#x7ED3;&#x679C;&#x4E5F;&#x662F;&#x6709;&#x7B26;&#x53F7;32&#x4F4D;&#x6574;&#x578B;</li>
<li>&#x64CD;&#x4F5C;&#x6570;&#x7684;&#x5927;&#x5C0F;&#x8D85;&#x8FC7;Int32&#x8303;&#x56F4;(-2^31 ~ 2^31-1). &#x8D85;&#x8FC7;&#x8303;&#x56F4;&#x7684;&#x4E8C;&#x8FDB;&#x5236;&#x4F4D;&#x4F1A;&#x88AB;&#x622A;&#x65AD;, &#x53D6;&#x4F4E;&#x4F4D;32bit</li>
</ul>
<h4 id="t541.11.2 &#x771F;&#x503C;">1.11.2 &#x771F;&#x503C; <a href="#t541.11.2 &#x771F;&#x503C;"> # </a></h4>
<ul>
<li>8&#x4F4D;&#x4E8C;&#x8FDB;&#x5236;&#x6570;&#x80FD;&#x8868;&#x793A;&#x7684;&#x771F;&#x503C;&#x8303;&#x56F4;&#x662F;[-2^8, +2^8]</li>
</ul>
<pre><code class="lang-js">+ 00000001 # +1
- 00000001 # -1
</code></pre>
<h4 id="t551.11.3 &#x539F;&#x7801;">1.11.3 &#x539F;&#x7801; <a href="#t551.11.3 &#x539F;&#x7801;"> # </a></h4>
<ul>
<li>&#x7531;&#x4E8E;&#x8BA1;&#x7B97;&#x673A;&#x53EA;&#x80FD;&#x5B58;&#x50A8;0&#x548C;1&#xFF0C;&#x4E0D;&#x80FD;&#x5B58;&#x50A8;&#x6B63;&#x8D1F;</li>
<li>&#x6240;&#x4EE5;&#x7528;8&#x4E2A;&#x4E8C;&#x8FDB;&#x5236;&#x4F4D;&#x7684;&#x6700;&#x9AD8;&#x4F4D;&#x6765;&#x8868;&#x793A;&#x7B26;&#x53F7;&#xFF0C;0&#x8868;&#x793A;&#x6B63;&#xFF0C;1&#x8868;&#x793A;&#x8D1F;&#xFF0C;&#x7528;&#x540E;&#x4E03;&#x4F4D;&#x6765;&#x8868;&#x793A;&#x771F;&#x503C;&#x7684;&#x7EDD;&#x5BF9;&#x503C;</li>
<li>&#x8FD9;&#x79CD;&#x8868;&#x793A;&#x65B9;&#x6CD5;&#x79F0;&#x4E3A;&#x539F;&#x7801;&#x8868;&#x793A;&#x6CD5;&#xFF0C;&#x7B80;&#x79F0;&#x539F;&#x7801;</li>
<li>&#x7531;&#x4E8E;<code>10000000</code>&#x7684;&#x610F;&#x601D;&#x662F;-0&#xFF0C;&#x8FD9;&#x4E2A;&#x6CA1;&#x6709;&#x610F;&#x4E49;&#xFF0C;&#x6240;&#x6709;&#x8FD9;&#x4E2A;&#x6570;&#x5B57;&#x88AB;&#x7528;&#x6765;&#x8868;&#x793A;-128</li>
<li>&#x7531;&#x4E8E;&#x6700;&#x9AD8;&#x4F4D;&#x88AB;&#x7528;&#x6765;&#x8868;&#x793A;&#x7B26;&#x53F7;&#x4E86;&#xFF0C;&#x73B0;&#x5728;&#x80FD;&#x8868;&#x793A;&#x7684;&#x8303;&#x56F4;&#x662F;[-2^7, +2^7-1]&#xFF0C;&#x5373;[-128, +127]</li>
</ul>
<p><img src="./assets/img/b01352062b284abf09ded8c1d6a074fb.gif" alt></p>
<pre><code class="lang-js">0 0000001 # +1
1 0000001 # -1
</code></pre>
<h4 id="t561.11.4 &#x53CD;&#x7801;">1.11.4 &#x53CD;&#x7801; <a href="#t561.11.4 &#x53CD;&#x7801;"> # </a></h4>
<ul>
<li>&#x53CD;&#x7801;&#x662F;&#x53E6;&#x4E00;&#x79CD;&#x8868;&#x793A;&#x6570;&#x5B57;&#x7684;&#x65B9;&#x6CD5;</li>
<li>&#x5176;&#x89C4;&#x5219;&#x662F;&#x6574;&#x6570;&#x7684;&#x53CD;&#x7801;&#x4F55;&#x5176;&#x539F;&#x7801;&#x4E00;&#x6837;</li>
<li>&#x8D1F;&#x6570;&#x7684;&#x53CD;&#x7801;&#x5C06;&#x5176;&#x539F;&#x7801;&#x7684;&#x7B26;&#x53F7;&#x4F4D;&#x4E0D;&#x53D8;&#xFF0C;&#x5176;&#x4F59;&#x5404;&#x4F4D;&#x6309;&#x4F4D;&#x53D6;&#x53CD;</li>
<li>&#x53CD;&#x7801;&#x7684;&#x8868;&#x793A;&#x8303;&#x56F4;&#x662F;[-2^7, +2^7-1]&#xFF0C;&#x5373;[-128, +127]</li>
</ul>
<pre><code class="lang-js">0 0000001 # +1
1 1111110 # -1
</code></pre>
<p><img src="./assets/img/6835471eccda0ba3c608098134c39c28.gif" alt></p>
<h4 id="t571.11.5 &#x8865;&#x7801;">1.11.5 &#x8865;&#x7801; <a href="#t571.11.5 &#x8865;&#x7801;"> # </a></h4>
<ul>
<li>&#x8865;&#x7801;&#x662F;&#x4E3A;&#x4E86;&#x7B80;&#x5316;&#x8FD0;&#x7B97;&#xFF0C;&#x5C06;&#x51CF;&#x6CD5;&#x53D8;&#x4E3A;&#x52A0;&#x6CD5;&#x800C;&#x53D1;&#x660E;&#x7684;&#x6570;&#x5B57;&#x8868;&#x793A;&#x6CD5;</li>
<li>&#x5176;&#x89C4;&#x5219;&#x662F;&#x6574;&#x6570;&#x7684;&#x8865;&#x7801;&#x548C;&#x539F;&#x7801;&#x4E00;&#x6837;&#xFF0C;&#x8D1F;&#x6570;&#x7684;&#x8865;&#x7801;&#x662F;&#x5176;&#x53CD;&#x7801;&#x672B;&#x5C3E;&#x52A0;1</li>
<li>8&#x4F4D;&#x8865;&#x7801;&#x8868;&#x793A;&#x7684;&#x8303;&#x56F4;&#x662F;[-2^7, +2^7-1]&#xFF0C;&#x5373;[-128, +127]</li>
<li>&#x5FEB;&#x901F;&#x8BA1;&#x7B97;&#x8D1F;&#x6570;&#x8865;&#x7801;&#x7684;&#x89C4;&#x5219;&#x5C31;&#x662F;&#xFF0C;&#x7531;&#x5176;&#x539F;&#x7801;&#x4F4E;&#x4F4D;&#x5411;&#x9AD8;&#x4F4D;&#x627E;&#x5230;&#x7B2C;&#x4E00;&#x4E2A;1&#xFF0C;1&#x548C;&#x5176;&#x4F4E;&#x4F4D;&#x4E0D;&#x53D8;&#xFF0C;1&#x524D;&#x9762;&#x7684;&#x9AD8;&#x4F4D;&#x6309;&#x4F4D;&#x53D6;&#x53CD;&#x5373;&#x53EF;</li>
</ul>
<p><img src="./assets/img/33687e4aedf676791a6f7b7adc811260.png" alt></p>
<pre><code class="lang-js">0 0000001 # +1
1 1111111 # -1
</code></pre>
<h4 id="t581.11.6 &#x4E8C;&#x8FDB;&#x5236;&#x6570;&#x6574;&#x6570;">1.11.6 &#x4E8C;&#x8FDB;&#x5236;&#x6570;&#x6574;&#x6570; <a href="#t581.11.6 &#x4E8C;&#x8FDB;&#x5236;&#x6570;&#x6574;&#x6570;"> # </a></h4>
<ul>
<li>&#x53EA;&#x8981;&#x5BF9;js&#x4E2D;&#x7684;&#x4EFB;&#x4F55;&#x6570;&#x5B57;&#x505A;&#x4F4D;&#x8FD0;&#x7B97;&#x64CD;&#x4F5C;&#x7CFB;&#x7EDF;&#x5185;&#x90E8;&#x90FD;&#x4F1A;&#x5C06;&#x5176;&#x8F6C;&#x6362;&#x6210;&#x6574;&#x5F62;</li>
<li>js&#x4E2D;&#x7684;&#x8FD9;&#x79CD;&#x6574;&#x5F62;&#x662F;&#x533A;&#x5206;&#x6B63;&#x8D1F;&#x6570;&#x7684;</li>
<li>js&#x4E2D;&#x7684;&#x6574;&#x6570;&#x7684;&#x8868;&#x793A;&#x8303;&#x56F4;&#x662F;[-2^31, +2^31-1]&#xFF0C;&#x5373;[-2147483648, +2147483647]</li>
</ul>
<h4 id="t591.11.7 ~&#x975E;">1.11.7 ~&#x975E; <a href="#t591.11.7 ~&#x975E;"> # </a></h4>
<ul>
<li>~&#x64CD;&#x4F5C;&#x7B26;&#x4F1A;&#x5C06;&#x64CD;&#x4F5C;&#x6570;&#x7684;&#x6BCF;&#x4E00;&#x4F4D;&#x53D6;&#x53CD;&#xFF0C;&#x5982;&#x679C;&#x662F;1&#x5219;&#x53D8;&#x4E3A;0&#xFF0C;&#x5982;&#x679C;&#x662F;0&#x5219;&#x8FB9;&#x4E3A;1</li>
</ul>
<pre><code class="lang-js"><span class="hljs-number">0b00000011</span>
<span class="hljs-number">3</span>
~<span class="hljs-number">0b00000011</span> =&gt;  <span class="hljs-number">0b11111100</span>
<span class="hljs-number">-4</span>
(~<span class="hljs-number">0b00000011</span>).toString();
<span class="hljs-string">&apos;-4&apos;</span>
(~<span class="hljs-number">0b00000011</span>).toString(<span class="hljs-number">2</span>);
<span class="hljs-string">&apos;-100&apos;</span>

&#x6C42;&#x8865;&#x7801;&#x7684;&#x771F;&#x503C;
<span class="hljs-number">1</span> &#x8868;&#x793A;&#x8D1F;&#x53F7;
&#x5269;&#x4E0B;&#x7684; <span class="hljs-number">1111100</span> &#x5F00;&#x59CB;&#x8F6C;&#x6362;
<span class="hljs-number">1111100</span> &#x51CF;<span class="hljs-number">1</span>
<span class="hljs-number">1111011</span> &#x53D6;&#x53CD;
<span class="hljs-number">0000100</span> <span class="hljs-number">4</span>
</code></pre>
<h4 id="t601.11.8 getHighestPriorityLane">1.11.8 getHighestPriorityLane <a href="#t601.11.8 getHighestPriorityLane"> # </a></h4>
<ul>
<li>&#x53EF;&#x4EE5;&#x627E;&#x5230;&#x6700;&#x53F3;&#x8FB9;&#x7684;1</li>
<li>&#x6700;&#x53F3;&#x8FB9;&#x7684;1&#x53F3;&#x8FB9;&#x7684;&#x5168;&#x662F;0&#xFF0C;&#x5168;&#x662F;0&#x53D6;&#x53CD;&#x5C31;&#x5168;&#x662F;1&#xFF0C;&#x518D;&#x52A0;&#x4E0A;&#x5C31;&#x4F1A;&#x5168;&#x90E8;&#x8FDB;&#x4F4D;&#x5230;1&#x53D6;&#x53CD;&#x7684;&#x4F4D;&#x7F6E;</li>
<li>&#x6700;&#x53F3;&#x8FB9;&#x7684;1&#x548C;&#x53F3;&#x8FB9;&#x7684;&#x6570;&#x8DDF;&#x539F;&#x6765;&#x7684;&#x503C;&#x662F;&#x5B8C;&#x5168;&#x4E00;&#x6837;&#x7684;&#xFF0C;&#x5DE6;&#x8FB9;&#x7684;&#x5168;&#x662F;&#x53CD;&#x7684;</li>
</ul>
<pre><code class="lang-js"><span class="hljs-comment">/**
 * &#x5206;&#x79BB;&#x51FA;&#x6240;&#x6709;&#x6BD4;&#x7279;&#x4F4D;&#x4E2D;&#x6700;&#x53F3;&#x8FB9;&#x7684;1
 * &#x5206;&#x79BB;&#x51FA;&#x6700;&#x9AD8;&#x4F18;&#x5148;&#x7EA7;&#x7684;&#x8F66;&#x9053;
 * <span class="hljs-doctag">@param <span class="hljs-type">{*}</span> </span>lanes &#x8F66;&#x9053;
 * <span class="hljs-doctag">@returns </span>&#x8F66;&#x9053;
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getHighestPriorityLane</span>(<span class="hljs-params">lanes</span>) </span>{
    <span class="hljs-keyword">return</span> lanes &amp; -lanes;
}

lanes=<span class="hljs-number">0b00001100</span>=<span class="hljs-number">12</span>
-lanes=<span class="hljs-number">-12</span>
<span class="hljs-number">1</span>
<span class="hljs-number">0001100</span>
<span class="hljs-number">1110011</span>
<span class="hljs-number">1110100</span>
<span class="hljs-number">11110100</span>
<span class="hljs-number">00001100</span>
</code></pre>
<h4 id="t611.11.9 &#x5DE6;&#x79FB;">1.11.9 &#x5DE6;&#x79FB; <a href="#t611.11.9 &#x5DE6;&#x79FB;"> # </a></h4>
<ul>
<li>&#x5DE6;&#x79FB;&#x7684;&#x89C4;&#x5219;&#x5C31;&#x662F;&#x6BCF;&#x4E00;&#x4F4D;&#x90FD;&#x5411;&#x5DE6;&#x79FB;&#x52A8;&#x4E00;&#x4F4D;&#xFF0C;&#x672B;&#x5C3E;&#x8865;0&#xFF0C;&#x5176;&#x6548;&#x679C;&#x76F8;&#x5F53;&#x4E8E;&#xD7;2</li>
<li>&#x8BA1;&#x7B97;&#x673A;&#x5C31;&#x662F;&#x7528;&#x79FB;&#x4F4D;&#x64CD;&#x4F5C;&#x6765;&#x8BA1;&#x7B97;&#x4E58;&#x6CD5;&#x7684;</li>
</ul>
<pre><code class="lang-js">(<span class="hljs-number">0b00000010</span>&lt;&lt;<span class="hljs-number">1</span>).toString(<span class="hljs-number">2</span>)
</code></pre>
<h4 id="t621.11.10 &gt;&gt; &#x6709;&#x7B26;&#x53F7;&#x53F3;&#x79FB;">1.11.10 &gt;&gt; &#x6709;&#x7B26;&#x53F7;&#x53F3;&#x79FB; <a href="#t621.11.10 &gt;&gt; &#x6709;&#x7B26;&#x53F7;&#x53F3;&#x79FB;"> # </a></h4>
<ul>
<li>&#x6709;&#x7B26;&#x53F7;&#x53F3;&#x79FB;&#x4E5F;&#x5C31;&#x662F;&#x79FB;&#x4F4D;&#x7684;&#x65F6;&#x5019;&#x9AD8;&#x4F4D;&#x8865;&#x7684;&#x662F;&#x5176;&#x7B26;&#x53F7;&#x4F4D;&#xFF0C;&#x6574;&#x6570;&#x5219;&#x8865;0&#xFF0C;&#x8D1F;&#x6570;&#x5219;&#x8865;1</li>
</ul>
<pre><code class="lang-js">(<span class="hljs-number">-0</span>b111&gt;&gt;<span class="hljs-number">1</span>).toString(<span class="hljs-number">2</span>) <span class="hljs-string">&quot;-100&quot;</span>
<span class="hljs-number">-0</span>b111 <span class="hljs-number">-7</span>
<span class="hljs-number">100000111</span> &#x539F;&#x7801;
<span class="hljs-number">111111000</span> &#x53CD;&#x7801;
<span class="hljs-number">111111001</span> &#x8865;&#x7801;
<span class="hljs-number">111111100</span>

<span class="hljs-number">1</span>
<span class="hljs-number">111111100</span>
<span class="hljs-number">111111011</span>
<span class="hljs-number">000000100</span>
<span class="hljs-number">1000000100</span>
<span class="hljs-number">-100</span>
<span class="hljs-number">-4</span>
</code></pre>
<h4 id="t631.11.11 &gt;&gt;&gt;&#x65E0;&#x7B26;&#x53F7;&#x53F3;&#x79FB;">1.11.11 &gt;&gt;&gt;&#x65E0;&#x7B26;&#x53F7;&#x53F3;&#x79FB; <a href="#t631.11.11 &gt;&gt;&gt;&#x65E0;&#x7B26;&#x53F7;&#x53F3;&#x79FB;"> # </a></h4>
<ul>
<li>&#x53F3;&#x79FB;&#x7684;&#x65F6;&#x5019;&#x9AD8;&#x4F4D;&#x59CB;&#x7EC8;&#x8865;0</li>
<li>&#x6B63;&#x6570;&#x548C;&#x6709;&#x7B26;&#x53F7;&#x53F3;&#x79FB;&#x6CA1;&#x6709;&#x533A;&#x522B;</li>
<li>&#x8D1F;&#x6570;&#x53F3;&#x79FB;&#x540E;&#x4F1A;&#x53D8;&#x4E3A;&#x6B63;&#x6570;</li>
</ul>
<pre><code class="lang-js">(<span class="hljs-number">0b111</span>&gt;&gt;&gt;<span class="hljs-number">1</span>).toString(<span class="hljs-number">2</span>)
&gt;&gt;&gt; <span class="hljs-string">&quot;11&quot;</span>
</code></pre>
<pre><code class="lang-js">(<span class="hljs-number">-0</span>b111&gt;&gt;&gt;<span class="hljs-number">1</span>).toString(<span class="hljs-number">2</span>)
&gt;&gt;&gt; <span class="hljs-string">&quot;1111111111111111111111111111100&quot;</span>

<span class="hljs-number">00000000000000000000000000000111</span>
<span class="hljs-number">11111111111111111111111111111000</span>
<span class="hljs-number">11111111111111111111111111111001</span>
<span class="hljs-number">01111111111111111111111111111100</span>
<span class="hljs-number">2147483644</span>
</code></pre>
<h3 id="t641.12 &#x66F4;&#x65B0;&#x4F18;&#x5148;&#x7EA7;">1.12 &#x66F4;&#x65B0;&#x4F18;&#x5148;&#x7EA7; <a href="#t641.12 &#x66F4;&#x65B0;&#x4F18;&#x5148;&#x7EA7;"> # </a></h3>
<h4 id="t651.12.1 lane">1.12.1 lane <a href="#t651.12.1 lane"> # </a></h4>
<ul>
<li>React&#x4E2D;&#x7528;lane(&#x8F66;&#x9053;)&#x6A21;&#x578B;&#x6765;&#x8868;&#x793A;&#x4EFB;&#x52A1;&#x4F18;&#x5148;&#x7EA7;</li>
<li>&#x4E00;&#x5171;&#x6709;31&#x6761;&#x4F18;&#x5148;&#x7EA7;&#xFF0C;&#x6570;&#x5B57;&#x8D8A;&#x5C0F;&#x4F18;&#x5148;&#x7EA7;&#x8D8A;&#x9AD8;&#xFF0C;&#x67D0;&#x4E9B;&#x8F66;&#x9053;&#x7684;&#x4F18;&#x5148;&#x7EA7;&#x76F8;&#x540C;</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32">clz32</a>&#x51FD;&#x6570;&#x8FD4;&#x56DE;&#x5F00;&#x5934;&#x7684; 0 &#x7684;&#x4E2A;&#x6570;</li>
</ul>
<p><img src="./assets/img/05d04ddf9cb9e4dcd0febe8be348e72f.jfif" alt></p>
<p><img src="./assets/img/fef9f035deab06e9a99c9e4bf9f029bf.jpg" alt></p>
<pre><code class="lang-js"><span class="hljs-comment">//&#x4E00;&#x5171;&#x6709;16&#x79CD;&#x4F18;&#x5148;&#x7EA7;</span>
<span class="hljs-comment">//&#x540C;&#x6B65;&#x4F18;&#x5148;&#x7EA7;</span>
<span class="hljs-keyword">const</span> SyncLanePriority = <span class="hljs-number">15</span>;
<span class="hljs-keyword">const</span> SyncBatchedLanePriority = <span class="hljs-number">14</span>;
<span class="hljs-comment">//&#x79BB;&#x6563;&#x4E8B;&#x4EF6;&#x4F18;&#x5148;&#x7EA7;</span>
<span class="hljs-keyword">const</span> InputDiscreteHydrationLanePriority = <span class="hljs-number">13</span>;
<span class="hljs-keyword">const</span> InputDiscreteLanePriority = <span class="hljs-number">12</span>;
<span class="hljs-comment">//&#x8FDE;&#x7EED;&#x4E8B;&#x4EF6;&#x4F18;&#x5148;&#x7EA7;</span>
<span class="hljs-keyword">const</span> InputContinuousHydrationLanePriority = <span class="hljs-number">11</span>;
<span class="hljs-keyword">const</span> InputContinuousLanePriority = <span class="hljs-number">10</span>;
<span class="hljs-comment">//&#x9ED8;&#x8BA4;&#x4F18;&#x5148;&#x7EA7;</span>
<span class="hljs-keyword">const</span> DefaultHydrationLanePriority = <span class="hljs-number">9</span>;
<span class="hljs-keyword">const</span> DefaultLanePriority = <span class="hljs-number">8</span>;
<span class="hljs-comment">//&#x6E10;&#x53D8;&#x4F18;&#x5148;&#x7EA7;</span>
<span class="hljs-keyword">const</span> TransitionHydrationPriority = <span class="hljs-number">7</span>;
<span class="hljs-keyword">const</span> TransitionPriority = <span class="hljs-number">6</span>;
<span class="hljs-keyword">const</span> RetryLanePriority = <span class="hljs-number">5</span>;
<span class="hljs-keyword">const</span> SelectiveHydrationLanePriority = <span class="hljs-number">4</span>;
<span class="hljs-comment">//&#x7A7A;&#x95F2;&#x4F18;&#x5148;&#x7EA7;</span>
<span class="hljs-keyword">const</span> IdleHydrationLanePriority = <span class="hljs-number">3</span>;
<span class="hljs-keyword">const</span> IdleLanePriority = <span class="hljs-number">2</span>;
<span class="hljs-comment">//&#x79BB;&#x5C4F;&#x4F18;&#x5148;&#x7EA7;</span>
<span class="hljs-keyword">const</span> OffscreenLanePriority = <span class="hljs-number">1</span>;
<span class="hljs-comment">//&#x672A;&#x8BBE;&#x7F6E;&#x4F18;&#x5148;&#x7EA7;</span>
<span class="hljs-keyword">const</span> NoLanePriority = <span class="hljs-number">0</span>;
<span class="hljs-comment">/**
 * &#x4E00;&#x5171;&#x6709;31&#x6761;&#x8F66;&#x9053;
 */</span>
<span class="hljs-keyword">const</span> TotalLanes = <span class="hljs-number">31</span>;
<span class="hljs-comment">//&#x6CA1;&#x6709;&#x8F66;&#x9053;&#xFF0C;&#x6240;&#x6709;&#x4F4D;&#x90FD;&#x4E3A;0</span>
<span class="hljs-keyword">const</span> NoLanes = <span class="hljs-number">0b0000000000000000000000000000000</span>;
<span class="hljs-keyword">const</span> NoLane = <span class="hljs-number">0b0000000000000000000000000000000</span>;
<span class="hljs-comment">//&#x540C;&#x6B65;&#x8F66;&#x9053;&#xFF0C;&#x4F18;&#x5148;&#x7EA7;&#x6700;&#x9AD8;</span>
<span class="hljs-keyword">const</span> SyncLane = <span class="hljs-number">0b0000000000000000000000000000001</span>;
<span class="hljs-keyword">const</span> SyncBatchedLane = <span class="hljs-number">0b0000000000000000000000000000010</span>;
<span class="hljs-comment">//&#x79BB;&#x6563;&#x7528;&#x6237;&#x4EA4;&#x4E92;&#x8F66;&#x9053; click</span>
<span class="hljs-keyword">const</span> InputDiscreteHydrationLane = <span class="hljs-number">0b0000000000000000000000000000100</span>;
<span class="hljs-keyword">const</span> InputDiscreteLanes = <span class="hljs-number">0b0000000000000000000000000011000</span>;
<span class="hljs-comment">//&#x8FDE;&#x7EED;&#x4EA4;&#x4E92;&#x8F66;&#x9053; mouseMove</span>
<span class="hljs-keyword">const</span> InputContinuousHydrationLane = <span class="hljs-number">0b0000000000000000000000000100000</span>;
<span class="hljs-keyword">const</span> InputContinuousLanes = <span class="hljs-number">0b0000000000000000000000011000000</span>;
<span class="hljs-comment">//&#x9ED8;&#x8BA4;&#x8F66;&#x9053;</span>
<span class="hljs-keyword">const</span> DefaultHydrationLane = <span class="hljs-number">0b0000000000000000000000100000000</span>;
<span class="hljs-keyword">const</span> DefaultLanes = <span class="hljs-number">0b0000000000000000000111000000000</span>;
<span class="hljs-comment">//&#x6E10;&#x53D8;&#x8F66;&#x9053;</span>
<span class="hljs-keyword">const</span> TransitionHydrationLane = <span class="hljs-number">0b0000000000000000001000000000000</span>;
<span class="hljs-keyword">const</span> TransitionLanes = <span class="hljs-number">0b0000000001111111110000000000000</span>;
<span class="hljs-comment">//&#x91CD;&#x8BD5;&#x8F66;&#x9053;</span>
<span class="hljs-keyword">const</span> RetryLanes = <span class="hljs-number">0b0000011110000000000000000000000</span>;
<span class="hljs-keyword">const</span> SomeRetryLane = <span class="hljs-number">0b0000010000000000000000000000000</span>;
<span class="hljs-comment">//&#x9009;&#x62E9;&#x6027;&#x6C34;&#x5408;&#x8F66;&#x9053;</span>
<span class="hljs-keyword">const</span> SelectiveHydrationLane = <span class="hljs-number">0b0000100000000000000000000000000</span>;
<span class="hljs-comment">//&#x975E;&#x7A7A;&#x95F2;&#x8F66;&#x9053;</span>
<span class="hljs-keyword">const</span> NonIdleLanes = <span class="hljs-number">0b0000111111111111111111111111111</span>;
<span class="hljs-keyword">const</span> IdleHydrationLane = <span class="hljs-number">0b0001000000000000000000000000000</span>;
<span class="hljs-comment">//&#x7A7A;&#x95F2;&#x8F66;&#x9053;</span>
<span class="hljs-keyword">const</span> IdleLanes = <span class="hljs-number">0b0110000000000000000000000000000</span>;
<span class="hljs-comment">//&#x79BB;&#x5C4F;&#x8F66;&#x9053;</span>
<span class="hljs-keyword">const</span> OffscreenLane = <span class="hljs-number">0b1000000000000000000000000000000</span>;

<span class="hljs-comment">/**
 * &#x5206;&#x79BB;&#x51FA;&#x6240;&#x6709;&#x6BD4;&#x7279;&#x4F4D;&#x4E2D;&#x6700;&#x53F3;&#x8FB9;&#x7684;1
 * &#x5206;&#x79BB;&#x51FA;&#x6700;&#x9AD8;&#x4F18;&#x5148;&#x7EA7;&#x7684;&#x8F66;&#x9053;
 * @param {*} lanes &#x8F66;&#x9053;
 * @returns &#x8F66;&#x9053;
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getHighestPriorityLane</span>(<span class="hljs-params">lanes</span>) </span>{
    <span class="hljs-keyword">return</span> lanes &amp; -lanes;
}

<span class="hljs-comment">//console.log(getHighestPriorityLane(InputDiscreteLanes));//8 0b1000</span>
<span class="hljs-comment">//console.log(&apos;0000000000000000000000000011000&apos;);</span>
<span class="hljs-comment">//console.log(&apos;1111111111111111111111111101000&apos;);</span>

<span class="hljs-comment">/**
 * &#x5206;&#x79BB;&#x51FA;&#x6240;&#x6709;&#x6BD4;&#x7279;&#x4F4D;&#x4E2D;&#x6700;&#x5DE6;&#x8FB9;&#x7684;1
 * &#x5206;&#x79BB;&#x51FA;&#x6700;&#x4F4E;&#x4F18;&#x5148;&#x7EA7;&#x7684;&#x8F66;&#x9053;
 * <span class="hljs-doctag">@param <span class="hljs-type">{*}</span> </span>lanes &#x8F66;&#x9053;
 * <span class="hljs-doctag">@returns </span>&#x8F66;&#x9053;
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getLowestPriorityLane</span>(<span class="hljs-params">lanes</span>) </span>{
    <span class="hljs-keyword">const</span> index = <span class="hljs-number">31</span> - <span class="hljs-built_in">Math</span>.clz32(lanes);
    <span class="hljs-keyword">return</span> index &lt; <span class="hljs-number">0</span> ? NoLanes : <span class="hljs-number">1</span> &lt;&lt; index;
}
<span class="hljs-built_in">console</span>.log(getLowestPriorityLane(InputDiscreteLanes));<span class="hljs-comment">//16 0b10000</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&apos;0000000000000000000000000011000&apos;</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Math</span>.clz32(InputDiscreteLanes));<span class="hljs-comment">//27</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-number">31</span> - <span class="hljs-built_in">Math</span>.clz32(InputDiscreteLanes));<span class="hljs-comment">//4</span>
</code></pre>
<h4 id="t661.12.2 Hydration">1.12.2 Hydration <a href="#t661.12.2 Hydration"> # </a></h4>
<ul>
<li>&#x6C34;&#x5408;&#x53CD;&#x5E94;(hydrated reaction)&#xFF0C;&#x4E5F;&#x53EB;&#x4F5C;&#x6C34;&#x5316;</li>
<li>&#x662F;&#x6307;&#x7269;&#x8D28;&#x6EB6;&#x89E3;&#x5728;&#x6C34;&#x91CC;&#x65F6;&#xFF0C;&#x4E0E;&#x6C34;&#x53D1;&#x751F;&#x7684;&#x5316;&#x5B66;&#x4F5C;&#x7528;,&#x6C34;&#x5408;&#x5206;&#x5B50;&#x7684;&#x8FC7;&#x7A0B;</li>
<li>&#x7EC4;&#x4EF6;&#x5728;&#x670D;&#x52A1;&#x5668;&#x7AEF;&#x62C9;&#x53D6;&#x6570;&#x636E;(&#x6C34;)&#xFF0C;&#x5E76;&#x5728;&#x670D;&#x52A1;&#x5668;&#x7AEF;&#x9996;&#x6B21;&#x6E32;&#x67D3;</li>
<li>&#x8131;&#x6C34;: &#x5BF9;&#x7EC4;&#x4EF6;&#x8FDB;&#x884C;&#x8131;&#x6C34;&#xFF0C;&#x53D8;&#x6210;HTML&#x5B57;&#x7B26;&#x4E32;&#xFF0C;&#x8131;&#x53BB;&#x52A8;&#x6001;&#x6570;&#x636E;&#xFF0C;&#x6210;&#x4E3A;&#x98CE;&#x5E72;&#x6807;&#x672C;&#x5FEB;&#x7167;</li>
<li>&#x6CE8;&#x6C34;&#xFF1A;&#x53D1;&#x9001;&#x5230;&#x5BA2;&#x6237;&#x7AEF;&#x540E;&#xFF0C;&#x91CD;&#x65B0;&#x6CE8;&#x5165;&#x6570;&#x636E;(&#x6C34;)&#xFF0C;&#x91CD;&#x65B0;&#x53D8;&#x6210;&#x53EF;&#x4EA4;&#x4E92;&#x7EC4;&#x4EF6;</li>
</ul>
<p><img src="./assets/img/1931e77588558a5ca549e398631b5576.jfif" style="width:500px"><br>
<img src="./assets/img/7d094edf55785fa672e560a141ce753b.jfif" style="width:500px"><br>
<img src="./assets/img/0baa61cd28a6f7a2e4df1fdc001cb264.jpeg" style="width:500px"><br></p>
<h4 id="t671.12.3 ReactFiberLane.js">1.12.3 ReactFiberLane.js <a href="#t671.12.3 ReactFiberLane.js"> # </a></h4>
<p>ReactFiberLane.js</p>
<pre><code class="lang-js">const NoLanes = 0b00;
const NoLane = 0b00;
const SyncLane = 0b01;
const SyncBatchedLane = 0b10;
/**
 * &#x5224;&#x65AD;subset&#x662F;&#x4E0D;&#x662F;set&#x7684;&#x5B50;&#x96C6;
 * @param {*} set 
 * @param {*} subset 
 * @returns 
 */
function isSubsetOfLanes(set, subset) {
    return (set &amp; subset) === subset;
}
/**
 * &#x5408;&#x5E76;&#x4E24;&#x4E2A;&#x8F66;&#x9053;
 * @param {*} a 
 * @param {*} b 
 * @returns 
 */
function mergeLanes(a, b) {
    return a | b;
}
module.exports = {
    NoLane,
    NoLanes,
    SyncLane,
    SyncBatchedLane,
    isSubsetOfLanes,
    mergeLanes
}
</code></pre>
<h4 id="t681.12.4 ReactUpdateQueue.js">1.12.4 ReactUpdateQueue.js <a href="#t681.12.4 ReactUpdateQueue.js"> # </a></h4>
<p>ReactUpdateQueue.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> { NoLane, NoLanes, isSubsetOfLanes, mergeLanes } = <span class="hljs-built_in">require</span>(<span class="hljs-string">&apos;./ReactFiberLane&apos;</span>);
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">initializeUpdateQueue</span>(<span class="hljs-params">fiber</span>) </span>{
  <span class="hljs-keyword">const</span> queue = {
    <span class="hljs-attr">baseState</span>: fiber.memoizedState,<span class="hljs-comment">//&#x672C;&#x6B21;&#x66F4;&#x65B0;&#x524D;&#x8BE5;Fiber&#x8282;&#x70B9;&#x7684;state,Update&#x57FA;&#x4E8E;&#x8BE5;state&#x8BA1;&#x7B97;&#x66F4;&#x65B0;&#x540E;&#x7684;state</span>
    <span class="hljs-attr">firstBaseUpdate</span>: <span class="hljs-literal">null</span>,<span class="hljs-comment">//&#x672C;&#x6B21;&#x66F4;&#x65B0;&#x524D;&#x8BE5;Fiber&#x8282;&#x70B9;&#x5DF2;&#x4FDD;&#x5B58;&#x7684;Update&#x94FE;&#x8868;&#x5934;</span>
    <span class="hljs-attr">lastBaseUpdate</span>: <span class="hljs-literal">null</span>,<span class="hljs-comment">//&#x672C;&#x6B21;&#x66F4;&#x65B0;&#x524D;&#x8BE5;Fiber&#x8282;&#x70B9;&#x5DF2;&#x4FDD;&#x5B58;&#x7684;Update&#x94FE;&#x8868;&#x5C3E;</span>
    <span class="hljs-attr">shared</span>: {
      <span class="hljs-comment">//&#x89E6;&#x53D1;&#x66F4;&#x65B0;&#x65F6;&#xFF0C;&#x4EA7;&#x751F;&#x7684;Update&#x4F1A;&#x4FDD;&#x5B58;&#x5728;shared.pending&#x4E2D;&#x5F62;&#x6210;&#x5355;&#x5411;&#x73AF;&#x72B6;&#x94FE;&#x8868;</span>
      <span class="hljs-comment">//&#x5F53;&#x7531;Update&#x8BA1;&#x7B97;state&#x65F6;&#x8FD9;&#x4E2A;&#x73AF;&#x4F1A;&#x88AB;&#x526A;&#x5F00;&#x5E76;&#x8FDE;&#x63A5;&#x5728;lastBaseUpdate&#x540E;&#x9762;</span>
      <span class="hljs-attr">pending</span>: <span class="hljs-literal">null</span>
    }
  }
  fiber.updateQueue = queue;
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">enqueueUpdate</span>(<span class="hljs-params">fiber, update</span>) </span>{
  <span class="hljs-keyword">const</span> updateQueue = fiber.updateQueue;
  <span class="hljs-keyword">if</span> (updateQueue === <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">return</span>;
  }
  <span class="hljs-keyword">const</span> sharedQueue = updateQueue.shared;
  <span class="hljs-keyword">const</span> pending = sharedQueue.pending;
  <span class="hljs-keyword">if</span> (pending === <span class="hljs-literal">null</span>) {
    update.next = update;
  } <span class="hljs-keyword">else</span> {
    update.next = pending.next;
    pending.next = update;
  }
  sharedQueue.pending = update;
}

<span class="hljs-comment">/**
 * &#x5904;&#x7406;&#x66F4;&#x65B0;&#x961F;&#x5217;
 * <span class="hljs-doctag">@param <span class="hljs-type">{*}</span> </span>fiber 
 * <span class="hljs-doctag">@param <span class="hljs-type">{*}</span> </span>renderLanes 
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">processUpdateQueue</span>(<span class="hljs-params">fiber, renderLanes</span>) </span>{
  <span class="hljs-comment">//&#x83B7;&#x53D6;&#x6B64;fiber&#x4E0A;&#x7684;&#x66F4;&#x65B0;&#x961F;&#x5217;</span>
  <span class="hljs-keyword">const</span> queue = fiber.updateQueue;
  <span class="hljs-comment">//&#x83B7;&#x53D6;&#x7B2C;&#x4E00;&#x4E2A;&#x66F4;&#x65B0;</span>
  <span class="hljs-keyword">let</span> firstBaseUpdate = queue.firstBaseUpdate;
  <span class="hljs-keyword">let</span> lastBaseUpdate = queue.lastBaseUpdate;
  <span class="hljs-comment">//&#x5224;&#x65AD;&#x4E00;&#x4E0B;&#x662F;&#x5426;&#x5728;&#x7B49;&#x5F85;&#x751F;&#x6548;&#x7684;&#x7684;&#x66F4;&#x65B0;&#xFF0C;&#x5982;&#x679C;&#x6709;&#xFF0C;&#x53D8;&#x6210;base&#x961F;&#x5217;</span>
  <span class="hljs-keyword">let</span> pendingQueue = queue.shared.pending;
  <span class="hljs-keyword">if</span> (pendingQueue !== <span class="hljs-literal">null</span>) {
    <span class="hljs-comment">//&#x7B49;&#x5F85;&#x751F;&#x6548;&#x7684;&#x961F;&#x5217;&#x662F;&#x5FAA;&#x73AF;&#x961F;&#x5217;</span>
    queue.shared.pending = <span class="hljs-literal">null</span>;
    <span class="hljs-comment">//&#x6700;&#x540E;&#x4E00;&#x4E2A;&#x7B49;&#x5F85;&#x7684;&#x66F4;&#x65B0; update4</span>
    <span class="hljs-keyword">const</span> lastPendingUpdate = pendingQueue;
    <span class="hljs-comment">//&#x7B2C;&#x4E00;&#x4E2A;&#x7B49;&#x5F85;&#x7684;&#x66F4;&#x65B0; update1</span>
    <span class="hljs-keyword">const</span> firstPendingUpdate = lastPendingUpdate.next;
    <span class="hljs-comment">//&#x628A;&#x73AF;&#x526A;&#x65AD;&#xFF0C;&#x6700;&#x540E;&#x4E00;&#x4E2A;&#x4E0D;&#x518D;&#x6307;&#x5411;&#x7B2C;&#x4E00;&#x4E2A;</span>
    lastPendingUpdate.next = <span class="hljs-literal">null</span>;
    <span class="hljs-comment">//&#x628A;&#x7B49;&#x5F85;&#x751F;&#x6548;&#x7684;&#x961F;&#x5217;&#x6DFB;&#x52A0;&#x5230;base&#x961F;&#x5217;&#x4E2D;</span>
    <span class="hljs-comment">//&#x5982;&#x679C;base&#x961F;&#x5217;&#x4E3A;&#x7A7A;</span>
    <span class="hljs-keyword">if</span> (lastBaseUpdate === <span class="hljs-literal">null</span>) {
      firstBaseUpdate = firstPendingUpdate;
    } <span class="hljs-keyword">else</span> {<span class="hljs-comment">//&#x5426;&#x5219;&#x5C31;&#x628A;&#x5F53;&#x524D;&#x7684;&#x66F4;&#x65B0;&#x961F;&#x5217;&#x6DFB;&#x52A0;&#x5230;base&#x961F;&#x5217;&#x7684;&#x5C3E;&#x90E8;</span>
      lastBaseUpdate.next = firstPendingUpdate;
    }
    <span class="hljs-comment">//&#x5C3E;&#x90E8;&#x4E5F;&#x63A5;&#x4E0A;</span>
    lastBaseUpdate = lastPendingUpdate;
  }
  <span class="hljs-comment">//&#x5F00;&#x59CB;&#x8BA1;&#x7B97;&#x65B0;&#x7684;&#x72B6;&#x6001;</span>
  <span class="hljs-keyword">if</span> (firstBaseUpdate !== <span class="hljs-literal">null</span>) {
    <span class="hljs-comment">//&#x5148;&#x83B7;&#x53D6;&#x8001;&#x7684;&#x503C;{number:0}</span>
    <span class="hljs-keyword">let</span> newState = queue.baseState;
    <span class="hljs-keyword">let</span> newLanes = NoLanes;
    <span class="hljs-keyword">let</span> newBaseState = <span class="hljs-literal">null</span>;<span class="hljs-comment">//&#x65B0;&#x7684;&#x57FA;&#x7840;&#x72B6;&#x6001;</span>
    <span class="hljs-keyword">let</span> newFirstBaseUpdate = <span class="hljs-literal">null</span>;<span class="hljs-comment">//&#x7B2C;&#x4E00;&#x4E2A;&#x8DF3;&#x8FC7;&#x7684;&#x66F4;&#x65B0;</span>
    <span class="hljs-keyword">let</span> newLastBaseUpdate = <span class="hljs-literal">null</span>;<span class="hljs-comment">//&#x65B0;&#x7684;&#x6700;&#x540E;&#x4E00;&#x4E2A;&#x57FA;&#x672C;&#x66F4;&#x65B0;</span>
    <span class="hljs-keyword">let</span> update = firstBaseUpdate;<span class="hljs-comment">//&#x6307;&#x5411;&#x7B2C;&#x4E00;&#x4E2A;&#x66F4;&#x65B0;</span>
    <span class="hljs-keyword">do</span> {
      <span class="hljs-comment">//&#x83B7;&#x53D6;&#x66F4;&#x65B0;&#x8F66;&#x9053;</span>
      <span class="hljs-keyword">const</span> updateLane = update.lane;
      <span class="hljs-comment">//&#x5982;&#x679C;&#x4F18;&#x5148;&#x7EA7;&#x4E0D;&#x591F;&#xFF0C;&#x8DF3;&#x8FC7;&#x8FD9;&#x4E2A;&#x66F4;&#x65B0;&#xFF0C;&#x5982;&#x679C;&#x8FD9;&#x662F;&#x7B2C;&#x4E00;&#x4E2A;&#x8DF3;&#x8FC7;&#x7684;&#x66F4;&#x65B0;&#xFF0C;&#x4E0A;&#x4E00;&#x4E2A;&#x72B6;&#x6001;&#x548C;&#x66F4;&#x65B0;&#x6210;&#x4E3A;newBaseState&#x548C;newFirstBaseUpdate</span>
      <span class="hljs-keyword">if</span> (!isSubsetOfLanes(renderLanes, updateLane)) {
        <span class="hljs-keyword">const</span> clone = {
          <span class="hljs-attr">id</span>: update.id,
          <span class="hljs-attr">lane</span>: updateLane,
          <span class="hljs-attr">payload</span>: update.payload
        };
        <span class="hljs-keyword">if</span> (newLastBaseUpdate === <span class="hljs-literal">null</span>) {
          newFirstBaseUpdate = newLastBaseUpdate = clone;<span class="hljs-comment">// first=last=update1</span>
          newBaseState = newState;<span class="hljs-comment">//0</span>
        } <span class="hljs-keyword">else</span> {
          newLastBaseUpdate = newLastBaseUpdate.next = clone;
        }
        <span class="hljs-comment">//&#x66F4;&#x65B0;&#x961F;&#x5217;&#x4E2D;&#x7684;&#x5269;&#x4E0B;&#x7684;&#x4F18;&#x5148;&#x7EA7;</span>
        newLanes = mergeLanes(newLanes, updateLane);
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">//&#x5982;&#x679C;&#x6709;&#x8DB3;&#x591F;&#x7684;&#x4F18;&#x5148;&#x7EA7; &#x5982;&#x679C;&#x6709;&#x66FE;&#x7ECF;&#x8DF3;&#x8FC7;&#x7684;&#x66F4;&#x65B0;&#xFF0C;&#x4ECD;&#x7136;&#x8FFD;&#x52A0;&#x5728;&#x540E;&#x9762;</span>
        <span class="hljs-keyword">if</span> (newLastBaseUpdate !== <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">const</span> clone = {
            <span class="hljs-attr">id</span>: update.id,
            <span class="hljs-comment">//NoLane&#x662F;&#x6240;&#x6709;&#x7684;&#x4F18;&#x5148;&#x7EA7;&#x7684;&#x5B50;&#x96C6;&#xFF0C;&#x6C38;&#x8FDC;&#x4E0D;&#x4F1A;&#x88AB;&#x8DF3;&#x8FC7;</span>
            <span class="hljs-attr">lane</span>: NoLane,
            <span class="hljs-attr">payload</span>: update.payload
          };
          newLastBaseUpdate = newLastBaseUpdate.next = clone;
        }
        newState = getStateFromUpdate(update, newState);
      }
      update = update.next;
      <span class="hljs-keyword">if</span> (!update) {
        <span class="hljs-keyword">break</span>;
      }
    } <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>);

    <span class="hljs-keyword">if</span> (!newLastBaseUpdate) {
      newBaseState = newState;
    }
    queue.baseState = newBaseState;
    queue.firstBaseUpdate = newFirstBaseUpdate;
    queue.lastBaseUpdate = newLastBaseUpdate;
    fiber.lanes = newLanes;
    fiber.memoizedState = newState;
  }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getStateFromUpdate</span>(<span class="hljs-params">update, prevState</span>) </span>{
  <span class="hljs-keyword">const</span> payload = update.payload;
  <span class="hljs-keyword">let</span> partialState = payload(prevState);
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.assign({}, prevState, partialState);
}
<span class="hljs-built_in">module</span>.exports = {
  initializeUpdateQueue,
  enqueueUpdate,
  processUpdateQueue
}
</code></pre>
<h4 id="t691.12.5 processUpdateQueue.js">1.12.5 processUpdateQueue.js <a href="#t691.12.5 processUpdateQueue.js"> # </a></h4>
<p>use.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> { initializeUpdateQueue, enqueueUpdate, processUpdateQueue } = <span class="hljs-built_in">require</span>(<span class="hljs-string">&apos;./ReactUpdateQueue&apos;</span>);
<span class="hljs-keyword">const</span> { SyncBatchedLane, SyncLane } = <span class="hljs-built_in">require</span>(<span class="hljs-string">&apos;./ReactFiberLane&apos;</span>);

<span class="hljs-comment">//&#x521D;&#x59CB;&#x5316;fiber&#x8282;&#x70B9;</span>
<span class="hljs-keyword">let</span> fiber = { <span class="hljs-attr">memoizedState</span>: { <span class="hljs-attr">msg</span>: <span class="hljs-string">&apos;&apos;</span> } };
initializeUpdateQueue(fiber);
<span class="hljs-keyword">let</span> update1 = { <span class="hljs-attr">id</span>: <span class="hljs-string">&apos;A&apos;</span>, <span class="hljs-attr">payload</span>: <span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> ({ <span class="hljs-attr">msg</span>: state.msg + <span class="hljs-string">&apos;A&apos;</span> }), <span class="hljs-attr">lane</span>: SyncBatchedLane };
enqueueUpdate(fiber, update1);
<span class="hljs-keyword">let</span> update2 = { <span class="hljs-attr">id</span>: <span class="hljs-string">&apos;B&apos;</span>, <span class="hljs-attr">payload</span>: <span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> ({ <span class="hljs-attr">msg</span>: state.msg + <span class="hljs-string">&apos;B&apos;</span> }), <span class="hljs-attr">lane</span>: SyncLane };
enqueueUpdate(fiber, update2);
<span class="hljs-keyword">let</span> update3 = { <span class="hljs-attr">id</span>: <span class="hljs-string">&apos;C&apos;</span>, <span class="hljs-attr">payload</span>: <span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> ({ <span class="hljs-attr">msg</span>: state.msg + <span class="hljs-string">&apos;C&apos;</span> }), <span class="hljs-attr">lane</span>: SyncBatchedLane };
enqueueUpdate(fiber, update3);
<span class="hljs-keyword">let</span> update4 = { <span class="hljs-attr">id</span>: <span class="hljs-string">&apos;D&apos;</span>, <span class="hljs-attr">payload</span>: <span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> ({ <span class="hljs-attr">msg</span>: state.msg + <span class="hljs-string">&apos;D&apos;</span> }), <span class="hljs-attr">lane</span>: SyncLane };
enqueueUpdate(fiber, update4);

<span class="hljs-comment">//&#x4EE5;&#x540C;&#x6B65;&#x7684;&#x4F18;&#x5148;&#x7EA7;&#x8FDB;&#x884C;&#x66F4;&#x65B0;</span>
processUpdateQueue(fiber, SyncLane);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&apos;memoizedState&apos;</span>, fiber.memoizedState);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&apos;updateQueue&apos;</span>, printQueue(fiber.updateQueue));

<span class="hljs-keyword">let</span> update5 = { <span class="hljs-attr">id</span>: <span class="hljs-string">&apos;E&apos;</span>, <span class="hljs-attr">payload</span>: <span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> ({ <span class="hljs-attr">msg</span>: state.msg + <span class="hljs-string">&apos;E&apos;</span> }), <span class="hljs-attr">lane</span>: SyncLane };
enqueueUpdate(fiber, update5);
processUpdateQueue(fiber, SyncLane);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&apos;memoizedState&apos;</span>, fiber.memoizedState);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&apos;updateQueue&apos;</span>, printQueue(fiber.updateQueue));

processUpdateQueue(fiber, SyncBatchedLane);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&apos;memoizedState&apos;</span>, fiber.memoizedState);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&apos;updateQueue&apos;</span>, printQueue(fiber.updateQueue));

<span class="hljs-keyword">let</span> update6 = { <span class="hljs-attr">id</span>: <span class="hljs-string">&apos;F&apos;</span>, <span class="hljs-attr">payload</span>: <span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> ({ <span class="hljs-attr">msg</span>: state.msg + <span class="hljs-string">&apos;F&apos;</span> }), <span class="hljs-attr">lane</span>: SyncLane };
enqueueUpdate(fiber, update6);
processUpdateQueue(fiber, SyncLane);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&apos;memoizedState&apos;</span>, fiber.memoizedState);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&apos;updateQueue&apos;</span>, printQueue(fiber.updateQueue));


<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printQueue</span>(<span class="hljs-params">queue</span>) </span>{
  <span class="hljs-keyword">const</span> { baseState, firstBaseUpdate } = queue
  <span class="hljs-keyword">let</span> state = baseState.msg + <span class="hljs-string">&apos;|&apos;</span>;
  <span class="hljs-keyword">let</span> update = firstBaseUpdate;
  <span class="hljs-keyword">while</span> (update) {
    state += ((update.id) + <span class="hljs-string">&quot;=&gt;&quot;</span>);
    update = update.next;
  }
  state += <span class="hljs-string">&quot;null&quot;</span>;
  <span class="hljs-built_in">console</span>.log(state);
}
</code></pre>
<h2 id="t702.&#x521B;&#x5EFA;&#x9879;&#x76EE;">2.&#x521B;&#x5EFA;&#x9879;&#x76EE; <a href="#t702.&#x521B;&#x5EFA;&#x9879;&#x76EE;"> # </a></h2>
<ul>
<li><a href="https://cn.vitejs.dev/">vitejs</a></li>
</ul>
<h3 id="t712.1 &#x521B;&#x5EFA;&#x76EE;&#x5F55;">2.1 &#x521B;&#x5EFA;&#x76EE;&#x5F55; <a href="#t712.1 &#x521B;&#x5EFA;&#x76EE;&#x5F55;"> # </a></h3>
<pre><code class="lang-js">mkdir react182
cd react182
npm init -y
</code></pre>
<h3 id="t722.2 &#x5B89;&#x88C5;">2.2 &#x5B89;&#x88C5; <a href="#t722.2 &#x5B89;&#x88C5;"> # </a></h3>
<pre><code class="lang-js">npm install vite @vitejs/plugin-react --save
</code></pre>
<h3 id="t732.3 vite.config.js">2.3 vite.config.js <a href="#t732.3 vite.config.js"> # </a></h3>
<pre><code class="lang-js"><span class="hljs-keyword">import</span> { defineConfig } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vite&quot;</span>;
<span class="hljs-keyword">import</span> react <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@vitejs/plugin-react&quot;</span>;
<span class="hljs-keyword">import</span> path <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;path&quot;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> defineConfig({
  <span class="hljs-attr">define</span>: {
    <span class="hljs-attr">__DEV__</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">__PROFILE__</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">__UMD__</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">__EXPERIMENTAL__</span>: <span class="hljs-literal">true</span>,
  },
  <span class="hljs-attr">resolve</span>: {
    <span class="hljs-attr">alias</span>: {
      <span class="hljs-attr">react</span>: path.posix.resolve(<span class="hljs-string">&quot;src/react&quot;</span>),
      <span class="hljs-string">&quot;react-dom&quot;</span>: path.posix.resolve(<span class="hljs-string">&quot;src/react-dom&quot;</span>),
      <span class="hljs-string">&quot;react-dom-bindings&quot;</span>: path.posix.resolve(<span class="hljs-string">&quot;src/react-dom-bindings&quot;</span>),
      <span class="hljs-string">&quot;react-reconciler&quot;</span>: path.posix.resolve(<span class="hljs-string">&quot;src/react-reconciler&quot;</span>),
      <span class="hljs-attr">scheduler</span>: path.posix.resolve(<span class="hljs-string">&quot;src/scheduler&quot;</span>),
      <span class="hljs-attr">shared</span>: path.posix.resolve(<span class="hljs-string">&quot;src/shared&quot;</span>),
    },
  },
  <span class="hljs-attr">plugins</span>: [react()],
  <span class="hljs-attr">optimizeDeps</span>: {
    <span class="hljs-attr">force</span>: <span class="hljs-literal">true</span>,
  },
});
</code></pre>
<h3 id="t742.4 jsconfig.json">2.4 jsconfig.json <a href="#t742.4 jsconfig.json"> # </a></h3>
<p>jsconfig.json</p>
<pre><code class="lang-json">{
  <span class="hljs-attr">&quot;compilerOptions&quot;</span>: {
    <span class="hljs-attr">&quot;baseUrl&quot;</span>: <span class="hljs-string">&quot;./&quot;</span>,
    <span class="hljs-attr">&quot;paths&quot;</span>: {
      <span class="hljs-attr">&quot;react/*&quot;</span>: [<span class="hljs-string">&quot;src/react/*&quot;</span>],
      <span class="hljs-attr">&quot;react-dom/*&quot;</span>: [<span class="hljs-string">&quot;src/react-dom/*&quot;</span>],
      <span class="hljs-attr">&quot;react-dom-bindings/*&quot;</span>: [<span class="hljs-string">&quot;react-dom-bindings/*&quot;</span>],
      <span class="hljs-attr">&quot;react-reconciler/*&quot;</span>: [<span class="hljs-string">&quot;src/react-reconciler/*&quot;</span>],
      <span class="hljs-attr">&quot;scheduler/*&quot;</span>: [<span class="hljs-string">&quot;scheduler/*&quot;</span>],
      <span class="hljs-attr">&quot;shared/*&quot;</span>: [<span class="hljs-string">&quot;src/shared/*&quot;</span>]
    }
  },
  <span class="hljs-attr">&quot;exclude&quot;</span>: [<span class="hljs-string">&quot;node_modules&quot;</span>, <span class="hljs-string">&quot;dist&quot;</span>]
}
</code></pre>
<h3 id="t752.5 main.jsx">2.5 main.jsx <a href="#t752.5 main.jsx"> # </a></h3>
<p>src\main.jsx</p>
<pre><code class="lang-js"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;main&quot;</span>);
</code></pre>
<h3 id="t762.6 index.html">2.6 index.html <a href="#t762.6 index.html"> # </a></h3>
<p>index.html</p>
<pre><code class="lang-html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>React18<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;root&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;module&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/src/main.jsx&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>
<h3 id="t772.7 package.json">2.7 package.json <a href="#t772.7 package.json"> # </a></h3>
<p>package.json</p>
<pre><code class="lang-json">{
  <span class="hljs-attr">&quot;scripts&quot;</span>: {
    <span class="hljs-attr">&quot;dev&quot;</span>: <span class="hljs-string">&quot;vite&quot;</span>
  }
}
</code></pre>
<h2 id="t783.&#x5B9E;&#x73B0;&#x865A;&#x62DF; DOM">3.&#x5B9E;&#x73B0;&#x865A;&#x62DF; DOM <a href="#t783.&#x5B9E;&#x73B0;&#x865A;&#x62DF; DOM"> # </a></h2>
<p><img src="./assets/img/5e5ca920941f292a41ce77c820ca90c6.png" alt></p>
<h3 id="t793.1 main.jsx">3.1 main.jsx <a href="#t793.1 main.jsx"> # </a></h3>
<p>main.jsx</p>
<pre><code class="lang-js"><span class="hljs-keyword">let</span> element = (
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>
    hello<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{{</span> <span class="hljs-attr">color:</span> &quot;<span class="hljs-attr">red</span>&quot; }}&gt;</span>world<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>
);
<span class="hljs-built_in">console</span>.log(element);
</code></pre>
<h3 id="t803.2 jsx-dev-runtime.js">3.2 jsx-dev-runtime.js <a href="#t803.2 jsx-dev-runtime.js"> # </a></h3>
<p>src\react\jsx-dev-runtime.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">export</span> { jsxDEV } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./src/jsx/ReactJSXElement&quot;</span>;
</code></pre>
<h3 id="t813.3 ReactJSXElement.js">3.3 ReactJSXElement.js <a href="#t813.3 ReactJSXElement.js"> # </a></h3>
<p>src\react\src\jsx\ReactJSXElement.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">import</span> hasOwnProperty <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;shared/hasOwnProperty&quot;</span>;
<span class="hljs-keyword">import</span> { REACT_ELEMENT_TYPE } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;shared/ReactSymbols&quot;</span>;

<span class="hljs-keyword">const</span> RESERVED_PROPS = {
  <span class="hljs-attr">key</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">ref</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">__self</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">__source</span>: <span class="hljs-literal">true</span>,
};
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hasValidRef</span>(<span class="hljs-params">config</span>) </span>{
  <span class="hljs-keyword">return</span> config.ref !== <span class="hljs-literal">undefined</span>;
}

<span class="hljs-keyword">const</span> ReactElement = <span class="hljs-function">(<span class="hljs-params">type, key, ref, props</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> element = {
    <span class="hljs-attr">$$typeof</span>: REACT_ELEMENT_TYPE,
    type,
    key,
    ref,
    props,
  };
  <span class="hljs-keyword">return</span> element;
};

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">jsxDEV</span>(<span class="hljs-params">type, config, maybeKey</span>) </span>{
  <span class="hljs-keyword">let</span> propName;
  <span class="hljs-keyword">const</span> props = {};
  <span class="hljs-keyword">let</span> key = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">let</span> ref = <span class="hljs-literal">null</span>;

  <span class="hljs-keyword">if</span> (maybeKey !== <span class="hljs-literal">undefined</span>) {
    key = <span class="hljs-string">&quot;&quot;</span> + maybeKey;
  }

  <span class="hljs-keyword">if</span> (hasValidRef(config)) {
    ref = config.ref;
  }

  <span class="hljs-keyword">for</span> (propName <span class="hljs-keyword">in</span> config) {
    <span class="hljs-keyword">if</span> (hasOwnProperty.call(config, propName) &amp;&amp; !RESERVED_PROPS.hasOwnProperty(propName)) {
      props[propName] = config[propName];
    }
  }
  <span class="hljs-keyword">return</span> ReactElement(type, key, ref, props);
}
</code></pre>
<h3 id="t823.4 ReactSymbols.js">3.4 ReactSymbols.js <a href="#t823.4 ReactSymbols.js"> # </a></h3>
<p>src\shared\ReactSymbols.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> REACT_ELEMENT_TYPE = <span class="hljs-built_in">Symbol</span>.for(<span class="hljs-string">&quot;react.element&quot;</span>);
</code></pre>
<h3 id="t833.5 hasOwnProperty.js">3.5 hasOwnProperty.js <a href="#t833.5 hasOwnProperty.js"> # </a></h3>
<p>src\shared\hasOwnProperty.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> { hasOwnProperty } = <span class="hljs-built_in">Object</span>.prototype;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> hasOwnProperty;
</code></pre>
<h2 id="t844.&#x521B;&#x5EFA; ReactDOMRoot">4.&#x521B;&#x5EFA; ReactDOMRoot <a href="#t844.&#x521B;&#x5EFA; ReactDOMRoot"> # </a></h2>
<p><img src="./assets/img/31aca58d6364dca29e48396a096dbcf5.png" alt></p>
<h3 id="t854.1 main.jsx">4.1 main.jsx <a href="#t854.1 main.jsx"> # </a></h3>
<p>src\main.jsx</p>
<pre><code class="lang-diff"><span class="hljs-addition">+import { createRoot } from &quot;react-dom/client&quot;;</span>
let element = (
  &lt;h1&gt;
    hello&lt;span style={{ color: &quot;red&quot; }}&gt;world&lt;/span&gt;
  &lt;/h1&gt;
);
<span class="hljs-addition">+const root = createRoot(document.getElementById(&quot;root&quot;));</span>
<span class="hljs-addition">+console.log(root);</span>
</code></pre>
<h3 id="t864.2 client.js">4.2 client.js <a href="#t864.2 client.js"> # </a></h3>
<p>src\react-dom\client.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">export</span> { createRoot } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./src/client/ReactDOMRoot&quot;</span>;
</code></pre>
<h3 id="t874.3 ReactDOMRoot.js">4.3 ReactDOMRoot.js <a href="#t874.3 ReactDOMRoot.js"> # </a></h3>
<p>src\react-dom\src\client\ReactDOMRoot.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">import</span> { createContainer } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-reconciler/src/ReactFiberReconciler&quot;</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ReactDOMRoot</span>(<span class="hljs-params">internalRoot</span>) </span>{
  <span class="hljs-keyword">this</span>._internalRoot = internalRoot;
}

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createRoot</span>(<span class="hljs-params">container</span>) </span>{
  <span class="hljs-keyword">const</span> root = createContainer(container);
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ReactDOMRoot(root);
}
</code></pre>
<h3 id="t884.4 ReactFiberReconciler.js">4.4 ReactFiberReconciler.js <a href="#t884.4 ReactFiberReconciler.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberReconciler.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">import</span> { createFiberRoot } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./ReactFiberRoot&quot;</span>;
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createContainer</span>(<span class="hljs-params">containerInfo</span>) </span>{
  <span class="hljs-keyword">return</span> createFiberRoot(containerInfo);
}
</code></pre>
<h3 id="t894.5 ReactFiberRoot.js">4.5 ReactFiberRoot.js <a href="#t894.5 ReactFiberRoot.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberRoot.js</p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">FiberRootNode</span>(<span class="hljs-params">containerInfo</span>) </span>{
  <span class="hljs-keyword">this</span>.containerInfo = containerInfo;
}

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createFiberRoot</span>(<span class="hljs-params">containerInfo</span>) </span>{
  <span class="hljs-keyword">const</span> root = <span class="hljs-keyword">new</span> FiberRootNode(containerInfo);
  <span class="hljs-keyword">return</span> root;
}
</code></pre>
<h2 id="t905.&#x521B;&#x5EFA; RootFiber">5.&#x521B;&#x5EFA; RootFiber <a href="#t905.&#x521B;&#x5EFA; RootFiber"> # </a></h2>
<p><img src="./assets/img/ab3cc86c878b7db1d4f066f19dc8fa75.png" alt></p>
<p><img src="./assets/img/5cd242e019cb7e5f5caced7c7289719a.jpg" alt></p>
<h3 id="t915.1 ReactFiberRoot.js">5.1 ReactFiberRoot.js <a href="#t915.1 ReactFiberRoot.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberRoot.js</p>
<pre><code class="lang-diff"><span class="hljs-addition">+import { createHostRootFiber } from &quot;./ReactFiber&quot;;</span>
function FiberRootNode(containerInfo) {
  this.containerInfo = containerInfo;
}

export function createFiberRoot(containerInfo) {
  const root = new FiberRootNode(containerInfo);
<span class="hljs-addition">+ const uninitializedFiber = createHostRootFiber();</span>
<span class="hljs-addition">+ root.current = uninitializedFiber;</span>
<span class="hljs-addition">+ uninitializedFiber.stateNode = root;</span>
  return root;
}
</code></pre>
<h3 id="t925.2 ReactFiber.js">5.2 ReactFiber.js <a href="#t925.2 ReactFiber.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiber.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">import</span> { HostRoot } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./ReactWorkTags&quot;</span>;
<span class="hljs-keyword">import</span> { NoFlags } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./ReactFiberFlags&quot;</span>;
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">FiberNode</span>(<span class="hljs-params">tag, pendingProps, key</span>) </span>{
  <span class="hljs-keyword">this</span>.tag = tag;
  <span class="hljs-keyword">this</span>.key = key;
  <span class="hljs-keyword">this</span>.type = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">this</span>.stateNode = <span class="hljs-literal">null</span>;

  <span class="hljs-keyword">this</span>.return = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">this</span>.child = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">this</span>.sibling = <span class="hljs-literal">null</span>;

  <span class="hljs-keyword">this</span>.pendingProps = pendingProps;
  <span class="hljs-keyword">this</span>.memoizedProps = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">this</span>.updateQueue = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">this</span>.memoizedState = <span class="hljs-literal">null</span>;

  <span class="hljs-keyword">this</span>.flags = NoFlags;
  <span class="hljs-keyword">this</span>.subtreeFlags = NoFlags;
  <span class="hljs-keyword">this</span>.alternate = <span class="hljs-literal">null</span>;
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createFiber</span>(<span class="hljs-params">tag, pendingProps, key</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FiberNode(tag, pendingProps, key);
}
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createHostRootFiber</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> createFiber(HostRoot, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);
}
</code></pre>
<h3 id="t935.3 ReactWorkTags.js">5.3 ReactWorkTags.js <a href="#t935.3 ReactWorkTags.js"> # </a></h3>
<p>src\react-reconciler\src\ReactWorkTags.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> HostRoot = <span class="hljs-number">3</span>;
</code></pre>
<h3 id="t945.4 ReactFiberFlags.js">5.4 ReactFiberFlags.js <a href="#t945.4 ReactFiberFlags.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberFlags.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> NoFlags = <span class="hljs-number">0b00000000000000000000000000</span>;
</code></pre>
<h2 id="t956.&#x521D;&#x59CB;&#x5316; UpdateQueue">6.&#x521D;&#x59CB;&#x5316; UpdateQueue <a href="#t956.&#x521D;&#x59CB;&#x5316; UpdateQueue"> # </a></h2>
<p><img src="./assets/img/b13b99c9c43bc9f353893bdf9b422baa.png" alt></p>
<h3 id="t966.1 ReactFiberRoot.js">6.1 ReactFiberRoot.js <a href="#t966.1 ReactFiberRoot.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberRoot.js</p>
<pre><code class="lang-diff">import { createHostRootFiber } from &quot;./ReactFiber&quot;;
<span class="hljs-addition">+import { initializeUpdateQueue } from &quot;./ReactFiberClassUpdateQueue&quot;;</span>
function FiberRootNode(containerInfo) {
  this.containerInfo = containerInfo;
}

export function createFiberRoot(containerInfo) {
  const root = new FiberRootNode(containerInfo);
  const uninitializedFiber = createHostRootFiber();
  root.current = uninitializedFiber;
  uninitializedFiber.stateNode = root;
<span class="hljs-addition">+ initializeUpdateQueue(uninitializedFiber);</span>
  return root;
}
</code></pre>
<h3 id="t976.2 ReactFiberClassUpdateQueue.js">6.2 ReactFiberClassUpdateQueue.js <a href="#t976.2 ReactFiberClassUpdateQueue.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberClassUpdateQueue.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">initializeUpdateQueue</span>(<span class="hljs-params">fiber</span>) </span>{
  <span class="hljs-keyword">const</span> queue = {
    <span class="hljs-attr">shared</span>: {
      <span class="hljs-attr">pending</span>: <span class="hljs-literal">null</span>,
    },
  };
  fiber.updateQueue = queue;
}
</code></pre>
<h2 id="t987. enqueueUpdate">7. enqueueUpdate <a href="#t987. enqueueUpdate"> # </a></h2>
<p><img src="./assets/img/afbfbabea8167a75cc015db63fc3ac54.png" alt></p>
<h3 id="t997.1 main.jsx">7.1 main.jsx <a href="#t997.1 main.jsx"> # </a></h3>
<p>src\main.jsx</p>
<pre><code class="lang-diff">import { createRoot } from &quot;react-dom/client&quot;;
let element = (
  &lt;h1&gt;
    hello&lt;span style={{ color: &quot;red&quot; }}&gt;world&lt;/span&gt;
  &lt;/h1&gt;
);
const root = createRoot(document.getElementById(&quot;root&quot;));
<span class="hljs-addition">+root.render(element);</span>
</code></pre>
<h3 id="t1007.2 ReactDOMRoot.js">7.2 ReactDOMRoot.js <a href="#t1007.2 ReactDOMRoot.js"> # </a></h3>
<p>src\react-dom\src\client\ReactDOMRoot.js</p>
<pre><code class="lang-diff">import {
  createContainer,
<span class="hljs-addition">+ updateContainer,</span>
} from &quot;react-reconciler/src/ReactFiberReconciler&quot;;

function ReactDOMRoot(internalRoot) {
  this._internalRoot = internalRoot;
}
<span class="hljs-addition">+ReactDOMRoot.prototype.render = function render(children) {</span>
<span class="hljs-addition">+  const root = this._internalRoot;</span>
<span class="hljs-addition">+  root.containerInfo.innerHTML = &quot;&quot;;</span>
<span class="hljs-addition">+  updateContainer(children, root);</span>
<span class="hljs-addition">+};</span>
export function createRoot(container) {
  const root = createContainer(container);
  return new ReactDOMRoot(root);
}
</code></pre>
<h3 id="t1017.3 ReactFiberReconciler.js">7.3 ReactFiberReconciler.js <a href="#t1017.3 ReactFiberReconciler.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberReconciler.js</p>
<pre><code class="lang-diff">import { createFiberRoot } from &quot;./ReactFiberRoot&quot;;
<span class="hljs-addition">+import { createUpdate, enqueueUpdate } from &quot;./ReactFiberClassUpdateQueue&quot;;</span>
export function createContainer(containerInfo) {
  return createFiberRoot(containerInfo);
}
<span class="hljs-addition">+export function updateContainer(element, container) {</span>
<span class="hljs-addition">+  const current = container.current;</span>
<span class="hljs-addition">+  const update = createUpdate();</span>
<span class="hljs-addition">+  update.payload = { element };</span>
<span class="hljs-addition">+  const root = enqueueUpdate(current, update);</span>
<span class="hljs-addition">+  console.log(root);</span>
<span class="hljs-addition">+}</span>
</code></pre>
<h3 id="t1027.4 ReactFiberClassUpdateQueue.js">7.4 ReactFiberClassUpdateQueue.js <a href="#t1027.4 ReactFiberClassUpdateQueue.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberClassUpdateQueue.js</p>
<pre><code class="lang-diff"><span class="hljs-addition">+import { markUpdateLaneFromFiberToRoot } from &quot;./ReactFiberConcurrentUpdates&quot;;</span>
<span class="hljs-addition">+export const UpdateState = 0;</span>
export function initializeUpdateQueue(fiber) {
  const queue = {
    shared: {
      pending: null,
    },
  };
  fiber.updateQueue = queue;
}
<span class="hljs-addition">+export function createUpdate() {</span>
<span class="hljs-addition">+  const update = { tag: UpdateState };</span>
<span class="hljs-addition">+  return update;</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+export function enqueueUpdate(fiber, update) {</span>
<span class="hljs-addition">+  const updateQueue = fiber.updateQueue;</span>
<span class="hljs-addition">+  const sharedQueue = updateQueue.shared;</span>
<span class="hljs-addition">+  const pending = sharedQueue.pending;</span>
<span class="hljs-addition">+  if (pending === null) {</span>
<span class="hljs-addition">+    update.next = update;</span>
<span class="hljs-addition">+  } else {</span>
<span class="hljs-addition">+    update.next = pending.next;</span>
<span class="hljs-addition">+    pending.next = update;</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+  updateQueue.shared.pending = update;</span>
<span class="hljs-addition">+  return markUpdateLaneFromFiberToRoot(fiber);</span>
<span class="hljs-addition">+}</span>
</code></pre>
<h3 id="t1037.5 ReactFiberConcurrentUpdates.js">7.5 ReactFiberConcurrentUpdates.js <a href="#t1037.5 ReactFiberConcurrentUpdates.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberConcurrentUpdates.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">import</span> { HostRoot } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./ReactWorkTags&quot;</span>;
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">markUpdateLaneFromFiberToRoot</span>(<span class="hljs-params">sourceFiber</span>) </span>{
  <span class="hljs-keyword">let</span> node = sourceFiber;
  <span class="hljs-keyword">let</span> parent = sourceFiber.return;
  <span class="hljs-keyword">while</span> (parent !== <span class="hljs-literal">null</span>) {
    node = parent;
    parent = parent.return;
  }
  <span class="hljs-keyword">if</span> (node.tag === HostRoot) {
    <span class="hljs-keyword">const</span> root = node.stateNode;
    <span class="hljs-keyword">return</span> root;
  }
  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
}
</code></pre>
<h2 id="t1048.performConcurrentWorkOnRoot">8.performConcurrentWorkOnRoot <a href="#t1048.performConcurrentWorkOnRoot"> # </a></h2>
<h3 id="t1058.1 ReactFiberReconciler.js">8.1 ReactFiberReconciler.js <a href="#t1058.1 ReactFiberReconciler.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberReconciler.js</p>
<pre><code class="lang-diff">import { createFiberRoot } from &quot;./ReactFiberRoot&quot;;
import { createUpdate, enqueueUpdate } from &quot;./ReactFiberClassUpdateQueue&quot;;
<span class="hljs-addition">+import { scheduleUpdateOnFiber } from &quot;./ReactFiberWorkLoop&quot;;</span>
export function createContainer(containerInfo) {
  return createFiberRoot(containerInfo);
}
export function updateContainer(element, container) {
  const current = container.current;
  const update = createUpdate();
  update.payload = { element };
  const root = enqueueUpdate(current, update);
<span class="hljs-addition">+ scheduleUpdateOnFiber(root);</span>
}
</code></pre>
<h3 id="t1068.2 ReactFiberWorkLoop.js">8.2 ReactFiberWorkLoop.js <a href="#t1068.2 ReactFiberWorkLoop.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberWorkLoop.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">import</span> { scheduleCallback } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;scheduler&quot;</span>;
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">scheduleUpdateOnFiber</span>(<span class="hljs-params">root</span>) </span>{
  ensureRootIsScheduled(root);
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ensureRootIsScheduled</span>(<span class="hljs-params">root</span>) </span>{
  scheduleCallback(performConcurrentWorkOnRoot.bind(<span class="hljs-literal">null</span>, root));
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">performConcurrentWorkOnRoot</span>(<span class="hljs-params">root</span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;performConcurrentWorkOnRoot&quot;</span>);
}
</code></pre>
<h3 id="t1078.3 scheduler\index.js">8.3 scheduler\index.js <a href="#t1078.3 scheduler\index.js"> # </a></h3>
<p>src\scheduler\index.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">export</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./src/forks/Scheduler&quot;</span>;
</code></pre>
<h3 id="t1088.4 Scheduler.js">8.4 Scheduler.js <a href="#t1088.4 Scheduler.js"> # </a></h3>
<p>src\scheduler\src\forks\Scheduler.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">scheduleCallback</span>(<span class="hljs-params">callback</span>) </span>{
  requestIdleCallback(callback);
}
</code></pre>
<h2 id="t1099.prepareFreshStack">9.prepareFreshStack <a href="#t1099.prepareFreshStack"> # </a></h2>
<p><img src="./assets/img/344b64e65608f20ef313b7430212138b.png" alt></p>
<h3 id="t1109.1 ReactFiberWorkLoop.js">9.1 ReactFiberWorkLoop.js <a href="#t1109.1 ReactFiberWorkLoop.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberWorkLoop.js</p>
<pre><code class="lang-diff">import { scheduleCallback } from &quot;scheduler&quot;;
<span class="hljs-addition">+import { createWorkInProgress } from &quot;./ReactFiber&quot;;</span>
<span class="hljs-addition">+let workInProgress = null;</span>
export function scheduleUpdateOnFiber(root) {
  ensureRootIsScheduled(root);
}
function ensureRootIsScheduled(root) {
  scheduleCallback(performConcurrentWorkOnRoot.bind(null, root));
}
function performConcurrentWorkOnRoot(root) {
<span class="hljs-addition">+ renderRootSync(root);</span>
}
<span class="hljs-addition">+function prepareFreshStack(root) {</span>
<span class="hljs-addition">+  workInProgress = createWorkInProgress(root.current, null);</span>
<span class="hljs-addition">+  console.log(workInProgress);</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+function renderRootSync(root) {</span>
<span class="hljs-addition">+  prepareFreshStack(root);</span>
<span class="hljs-addition">+}</span>
</code></pre>
<h3 id="t1119.2 ReactFiber.js">9.2 ReactFiber.js <a href="#t1119.2 ReactFiber.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiber.js</p>
<pre><code class="lang-diff">import { HostRoot } from &quot;./ReactWorkTags&quot;;
import { NoFlags } from &quot;./ReactFiberFlags&quot;;
export function FiberNode(tag, pendingProps, key) {
  this.tag = tag;
  this.key = key;
  this.type = null;
  this.stateNode = null;

  this.return = null;
  this.child = null;
  this.sibling = null;

  this.pendingProps = pendingProps;
  this.memoizedProps = null;
  this.updateQueue = null;
  this.memoizedState = null;

  this.flags = NoFlags;
  this.subtreeFlags = NoFlags;
  this.alternate = null;
}
function createFiber(tag, pendingProps, key) {
  return new FiberNode(tag, pendingProps, key);
}
export function createHostRootFiber() {
  return createFiber(HostRoot, null, null);
}
<span class="hljs-addition">+// We use a double buffering pooling technique because we know that we&apos;ll</span>
<span class="hljs-addition">+// only ever need at most two versions of a tree. We pool the &quot;other&quot; unused</span>
<span class="hljs-addition">+// node that we&apos;re free to reuse. This is lazily created to avoid allocating</span>
<span class="hljs-addition">+// extra objects for things that are never updated. It also allow us to</span>
<span class="hljs-addition">+// reclaim the extra memory if needed.</span>
<span class="hljs-addition">+//&#x6211;&#x4EEC;&#x4F7F;&#x7528;&#x53CC;&#x7F13;&#x51B2;&#x6C60;&#x6280;&#x672F;&#xFF0C;&#x56E0;&#x4E3A;&#x6211;&#x4EEC;&#x77E5;&#x9053;&#x4E00;&#x68F5;&#x6811;&#x6700;&#x591A;&#x53EA;&#x9700;&#x8981;&#x4E24;&#x4E2A;&#x7248;&#x672C;</span>
<span class="hljs-addition">+//&#x6211;&#x4EEC;&#x5C06;&#x201C;&#x5176;&#x4ED6;&#x201D;&#x672A;&#x4F7F;&#x7528;&#x7684;&#x6211;&#x4EEC;&#x53EF;&#x4EE5;&#x81EA;&#x7531;&#x91CD;&#x7528;&#x7684;&#x8282;&#x70B9;</span>
<span class="hljs-addition">+//&#x8FD9;&#x662F;&#x5EF6;&#x8FDF;&#x521B;&#x5EFA;&#x7684;&#xFF0C;&#x4EE5;&#x907F;&#x514D;&#x5206;&#x914D;&#x4ECE;&#x672A;&#x66F4;&#x65B0;&#x7684;&#x5185;&#x5BB9;&#x7684;&#x989D;&#x5916;&#x5BF9;&#x8C61;&#x3002;&#x5B83;&#x8FD8;&#x5141;&#x8BB8;&#x6211;&#x4EEC;&#x5982;&#x679C;&#x9700;&#x8981;&#xFF0C;&#x56DE;&#x6536;&#x989D;&#x5916;&#x7684;&#x5185;+&#x5B58;</span>
<span class="hljs-addition">+export function createWorkInProgress(current, pendingProps) {</span>
<span class="hljs-addition">+  let workInProgress = current.alternate;</span>
<span class="hljs-addition">+  if (workInProgress === null) {</span>
<span class="hljs-addition">+    workInProgress = createFiber(current.tag, pendingProps, current.key);</span>
<span class="hljs-addition">+    workInProgress.type = current.type;</span>
<span class="hljs-addition">+    workInProgress.stateNode = current.stateNode;</span>
<span class="hljs-addition">+    workInProgress.alternate = current;</span>
<span class="hljs-addition">+    current.alternate = workInProgress;</span>
<span class="hljs-addition">+  } else {</span>
<span class="hljs-addition">+    workInProgress.pendingProps = pendingProps;</span>
<span class="hljs-addition">+    workInProgress.type = current.type;</span>
<span class="hljs-addition">+    workInProgress.flags = NoFlags;</span>
<span class="hljs-addition">+    workInProgress.subtreeFlags = NoFlags;</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+  workInProgress.child = current.child;</span>
<span class="hljs-addition">+  workInProgress.memoizedProps = current.memoizedProps;</span>
<span class="hljs-addition">+  workInProgress.memoizedState = current.memoizedState;</span>
<span class="hljs-addition">+  workInProgress.updateQueue = current.updateQueue;</span>
<span class="hljs-addition">+  workInProgress.sibling = current.sibling;</span>
<span class="hljs-addition">+  workInProgress.index = current.index;</span>
<span class="hljs-addition">+  return workInProgress;</span>
<span class="hljs-addition">+}</span>
</code></pre>
<h2 id="t11210.beginWork">10.beginWork <a href="#t11210.beginWork"> # </a></h2>
<p><img src="./assets/img/b14336c5a80561534ae6cb104f0731de.png" alt></p>
<h3 id="t11310.1 ReactFiberWorkLoop.js">10.1 ReactFiberWorkLoop.js <a href="#t11310.1 ReactFiberWorkLoop.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberWorkLoop.js</p>
<pre><code class="lang-diff">import { scheduleCallback } from &quot;scheduler&quot;;
import { createWorkInProgress } from &quot;./ReactFiber&quot;;
import { beginWork } from &quot;./ReactFiberBeginWork&quot;;
let workInProgress = null;
export function scheduleUpdateOnFiber(root) {
  ensureRootIsScheduled(root);
}
function ensureRootIsScheduled(root) {
  scheduleCallback(performConcurrentWorkOnRoot.bind(null, root));
}
function performConcurrentWorkOnRoot(root) {
  renderRootSync(root);
}
function prepareFreshStack(root) {
  workInProgress = createWorkInProgress(root.current, null);

}
function renderRootSync(root) {
  prepareFreshStack(root);
<span class="hljs-addition">+ workLoopSync();</span>
}

<span class="hljs-addition">+function workLoopSync() {</span>
<span class="hljs-addition">+  while (workInProgress !== null) {</span>
<span class="hljs-addition">+    performUnitOfWork(workInProgress);</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+function performUnitOfWork(unitOfWork) {</span>
<span class="hljs-addition">+  const current = unitOfWork.alternate;</span>
<span class="hljs-addition">+  const next = beginWork(current, unitOfWork);</span>
<span class="hljs-addition">+  unitOfWork.memoizedProps = unitOfWork.pendingProps;</span>
<span class="hljs-addition">+  if (next === null) {</span>
<span class="hljs-addition">+    //completeUnitOfWork(unitOfWork);</span>
<span class="hljs-addition">+    workInProgress = null;</span>
<span class="hljs-addition">+  } else {</span>
<span class="hljs-addition">+    workInProgress = next;</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+}</span>
</code></pre>
<h3 id="t11410.2 ReactFiberBeginWork.js">10.2 ReactFiberBeginWork.js <a href="#t11410.2 ReactFiberBeginWork.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberBeginWork.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">import</span> { HostRoot, HostComponent, HostText } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./ReactWorkTags&quot;</span>;
<span class="hljs-keyword">import</span> { processUpdateQueue } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./ReactFiberClassUpdateQueue&quot;</span>;
<span class="hljs-keyword">import</span> { mountChildFibers, reconcileChildFibers } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./ReactChildFiber&quot;</span>;
<span class="hljs-keyword">import</span> { shouldSetTextContent } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-dom-bindings/src/client/ReactDOMHostConfig&quot;</span>;
<span class="hljs-keyword">import</span> logger, { indent } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;shared/logger&quot;</span>;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reconcileChildren</span>(<span class="hljs-params">current, workInProgress, nextChildren</span>) </span>{
  <span class="hljs-keyword">if</span> (current === <span class="hljs-literal">null</span>) {
    workInProgress.child = mountChildFibers(workInProgress, <span class="hljs-literal">null</span>, nextChildren);
  } <span class="hljs-keyword">else</span> {
    workInProgress.child = reconcileChildFibers(workInProgress, current.child, nextChildren);
  }
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateHostRoot</span>(<span class="hljs-params">current, workInProgress</span>) </span>{
  processUpdateQueue(workInProgress);
  <span class="hljs-keyword">const</span> nextState = workInProgress.memoizedState;
  <span class="hljs-keyword">const</span> nextChildren = nextState.element;
  reconcileChildren(current, workInProgress, nextChildren);
  <span class="hljs-keyword">return</span> workInProgress.child;
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateHostComponent</span>(<span class="hljs-params">current, workInProgress</span>) </span>{
  <span class="hljs-keyword">const</span> { type } = workInProgress;
  <span class="hljs-keyword">const</span> nextProps = workInProgress.pendingProps;
  <span class="hljs-keyword">let</span> nextChildren = nextProps.children;
  <span class="hljs-keyword">const</span> isDirectTextChild = shouldSetTextContent(type, nextProps);
  <span class="hljs-keyword">if</span> (isDirectTextChild) {
    nextChildren = <span class="hljs-literal">null</span>;
  }
  reconcileChildren(current, workInProgress, nextChildren);
  <span class="hljs-keyword">return</span> workInProgress.child;
}
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">beginWork</span>(<span class="hljs-params">current, workInProgress</span>) </span>{
  logger(<span class="hljs-string">&quot; &quot;</span>.repeat(indent.number) + <span class="hljs-string">&quot;beginWork&quot;</span>, workInProgress);
  <span class="hljs-keyword">switch</span> (workInProgress.tag) {
    <span class="hljs-keyword">case</span> HostRoot:
      <span class="hljs-keyword">return</span> updateHostRoot(current, workInProgress);
    <span class="hljs-keyword">case</span> HostComponent:
      <span class="hljs-keyword">return</span> updateHostComponent(current, workInProgress);
    <span class="hljs-keyword">case</span> HostText:
    <span class="hljs-keyword">default</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }
}
</code></pre>
<h3 id="t11510.3 ReactWorkTags.js">10.3 ReactWorkTags.js <a href="#t11510.3 ReactWorkTags.js"> # </a></h3>
<p>src\react-reconciler\src\ReactWorkTags.js</p>
<pre><code class="lang-diff">export const HostRoot = 3;
<span class="hljs-addition">+export const IndeterminateComponent = 2;</span>
<span class="hljs-addition">+export const HostComponent = 5;</span>
<span class="hljs-addition">+export const HostText = 6;</span>
</code></pre>
<h3 id="t11610.4 ReactFiberClassUpdateQueue.js">10.4 ReactFiberClassUpdateQueue.js <a href="#t11610.4 ReactFiberClassUpdateQueue.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberClassUpdateQueue.js</p>
<pre><code class="lang-diff">import { markUpdateLaneFromFiberToRoot } from &quot;./ReactFiberConcurrentUpdates&quot;;
<span class="hljs-addition">+import assign from &quot;shared/assign&quot;;</span>
export const UpdateState = 0;
export function initializeUpdateQueue(fiber) {
  const queue = {
    shared: {
      pending: null,
    },
  };
  fiber.updateQueue = queue;
}
export function createUpdate() {
  const update = { tag: UpdateState };
  return update;
}
export function enqueueUpdate(fiber, update) {
  const updateQueue = fiber.updateQueue;
  const sharedQueue = updateQueue.shared;
  const pending = sharedQueue.pending;
  if (pending <span class="hljs-comment">=== null) {</span>
    update.next = update;
  } else {
    update.next = pending.next;
    pending.next = update;
  }
  updateQueue.shared.pending = update;
  return markUpdateLaneFromFiberToRoot(fiber);
}

<span class="hljs-addition">+function getStateFromUpdate(update, prevState) {</span>
<span class="hljs-addition">+  switch (update.tag) {</span>
<span class="hljs-addition">+    case UpdateState: {</span>
<span class="hljs-addition">+      const { payload } = update;</span>
<span class="hljs-addition">+      const partialState = payload;</span>
<span class="hljs-addition">+      return assign({}, prevState, partialState);</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+    default:</span>
<span class="hljs-addition">+      return prevState;</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+export function processUpdateQueue(workInProgress) {</span>
<span class="hljs-addition">+  const queue = workInProgress.updateQueue;</span>
<span class="hljs-addition">+  const pendingQueue = queue.shared.pending;</span>
<span class="hljs-addition">+  if (pendingQueue !== null) {</span>
<span class="hljs-addition">+    queue.shared.pending = null;</span>
<span class="hljs-addition">+    const lastPendingUpdate = pendingQueue;</span>
<span class="hljs-addition">+    const firstPendingUpdate = lastPendingUpdate.next;</span>
<span class="hljs-addition">+    lastPendingUpdate.next = null;</span>
<span class="hljs-addition">+    let newState = workInProgress.memoizedState;</span>
<span class="hljs-addition">+    let update = firstPendingUpdate;</span>
<span class="hljs-addition">+    while (update) {</span>
<span class="hljs-addition">+      newState = getStateFromUpdate(update, newState);</span>
<span class="hljs-addition">+      update = update.next;</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+    workInProgress.memoizedState = newState;</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+}</span>
</code></pre>
<h3 id="t11710.5 ReactChildFiber.js">10.5 ReactChildFiber.js <a href="#t11710.5 ReactChildFiber.js"> # </a></h3>
<p>src\react-reconciler\src\ReactChildFiber.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">import</span> { REACT_ELEMENT_TYPE } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;shared/ReactSymbols&quot;</span>;
<span class="hljs-keyword">import</span> isArray <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;shared/isArray&quot;</span>;
<span class="hljs-keyword">import</span> { createFiberFromElement, FiberNode, createFiberFromText } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./ReactFiber&quot;</span>;
<span class="hljs-keyword">import</span> { Placement } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./ReactFiberFlags&quot;</span>;
<span class="hljs-keyword">import</span> { HostText } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./ReactWorkTags&quot;</span>;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createChildReconciler</span>(<span class="hljs-params">shouldTrackSideEffects</span>) </span>{
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reconcileSingleElement</span>(<span class="hljs-params">returnFiber, currentFirstChild, element</span>) </span>{
    <span class="hljs-keyword">const</span> created = createFiberFromElement(element);
    created.return = returnFiber;
    <span class="hljs-keyword">return</span> created;
  }
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">placeSingleChild</span>(<span class="hljs-params">newFiber</span>) </span>{
    <span class="hljs-keyword">if</span> (shouldTrackSideEffects) newFiber.flags |= Placement;
    <span class="hljs-keyword">return</span> newFiber;
  }
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reconcileSingleTextNode</span>(<span class="hljs-params">returnFiber, currentFirstChild, content</span>) </span>{
    <span class="hljs-keyword">const</span> created = <span class="hljs-keyword">new</span> FiberNode(HostText, { content }, <span class="hljs-literal">null</span>);
    created.return = returnFiber;
    <span class="hljs-keyword">return</span> created;
  }
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createChild</span>(<span class="hljs-params">returnFiber, newChild</span>) </span>{
    <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">typeof</span> newChild === <span class="hljs-string">&quot;string&quot;</span> &amp;&amp; newChild !== <span class="hljs-string">&quot;&quot;</span>) || <span class="hljs-keyword">typeof</span> newChild === <span class="hljs-string">&quot;number&quot;</span>) {
      <span class="hljs-keyword">const</span> created = createFiberFromText(<span class="hljs-string">`<span class="hljs-subst">${newChild}</span>`</span>);
      created.return = returnFiber;
      <span class="hljs-keyword">return</span> created;
    }

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> newChild === <span class="hljs-string">&quot;object&quot;</span> &amp;&amp; newChild !== <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">switch</span> (newChild.$$<span class="hljs-keyword">typeof</span>) {
        <span class="hljs-keyword">case</span> REACT_ELEMENT_TYPE: {
          <span class="hljs-keyword">const</span> created = createFiberFromElement(newChild);
          created.return = returnFiber;
          <span class="hljs-keyword">return</span> created;
        }
        <span class="hljs-attr">default</span>:
          <span class="hljs-keyword">break</span>;
      }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">placeChild</span>(<span class="hljs-params">newFiber, newIndex</span>) </span>{
    newFiber.index = newIndex;
    <span class="hljs-keyword">if</span> (shouldTrackSideEffects) newFiber.flags |= Placement;
  }
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reconcileChildrenArray</span>(<span class="hljs-params">returnFiber, currentFirstChild, newChildren</span>) </span>{
    <span class="hljs-keyword">let</span> resultingFirstChild = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">let</span> previousNewFiber = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">let</span> newIdx = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (; newIdx &lt; newChildren.length; newIdx++) {
      <span class="hljs-keyword">const</span> newFiber = createChild(returnFiber, newChildren[newIdx]);
      <span class="hljs-keyword">if</span> (newFiber === <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">continue</span>;
      }
      placeChild(newFiber, newIdx);
      <span class="hljs-keyword">if</span> (previousNewFiber === <span class="hljs-literal">null</span>) {
        resultingFirstChild = newFiber;
      } <span class="hljs-keyword">else</span> {
        previousNewFiber.sibling = newFiber;
      }
      previousNewFiber = newFiber;
    }
    <span class="hljs-keyword">return</span> resultingFirstChild;
  }
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reconcileChildFibers</span>(<span class="hljs-params">returnFiber, currentFirstChild, newChild</span>) </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> newChild === <span class="hljs-string">&quot;object&quot;</span> &amp;&amp; newChild !== <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">switch</span> (newChild.$$<span class="hljs-keyword">typeof</span>) {
        <span class="hljs-keyword">case</span> REACT_ELEMENT_TYPE: {
          <span class="hljs-keyword">return</span> placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild));
        }
        <span class="hljs-attr">default</span>:
          <span class="hljs-keyword">break</span>;
      }
      <span class="hljs-keyword">if</span> (isArray(newChild)) {
        <span class="hljs-keyword">return</span> reconcileChildrenArray(returnFiber, currentFirstChild, newChild);
      }
    }
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> newChild === <span class="hljs-string">&quot;string&quot;</span>) {
      <span class="hljs-keyword">return</span> placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, newChild));
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }
  <span class="hljs-keyword">return</span> reconcileChildFibers;
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> reconcileChildFibers = createChildReconciler(<span class="hljs-literal">true</span>);
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> mountChildFibers = createChildReconciler(<span class="hljs-literal">false</span>);
</code></pre>
<h3 id="t11810.6 ReactDOMHostConfig.js">10.6 ReactDOMHostConfig.js <a href="#t11810.6 ReactDOMHostConfig.js"> # </a></h3>
<p>src\react-dom-bindings\src\client\ReactDOMHostConfig.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">shouldSetTextContent</span>(<span class="hljs-params">type, props</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> props.children === <span class="hljs-string">&quot;string&quot;</span> || <span class="hljs-keyword">typeof</span> props.children === <span class="hljs-string">&quot;number&quot;</span>;
}
</code></pre>
<h3 id="t11910.7 logger.js">10.7 logger.js <a href="#t11910.7 logger.js"> # </a></h3>
<p>src\shared\logger.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> ReactWorkTags <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-reconciler/src/ReactWorkTags&quot;</span>;
<span class="hljs-keyword">const</span> ReactWorkTagsMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> tag <span class="hljs-keyword">in</span> ReactWorkTags) {
  ReactWorkTagsMap.set(ReactWorkTags[tag], tag);
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">logger</span>(<span class="hljs-params">prefix, workInProgress</span>) </span>{
  <span class="hljs-keyword">let</span> tagValue = workInProgress.tag;
  <span class="hljs-keyword">let</span> tagName = ReactWorkTagsMap.get(tagValue);
  <span class="hljs-keyword">let</span> str = <span class="hljs-string">` <span class="hljs-subst">${tagName}</span> `</span>;
  <span class="hljs-keyword">if</span> (tagName === <span class="hljs-string">&quot;HostComponent&quot;</span>) {
    str += <span class="hljs-string">` <span class="hljs-subst">${workInProgress.type}</span> `</span>;
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tagName === <span class="hljs-string">&quot;HostText&quot;</span>) {
    str += <span class="hljs-string">` <span class="hljs-subst">${workInProgress.pendingProps}</span> `</span>;
  }
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${prefix}</span> <span class="hljs-subst">${str}</span>`</span>);
}

<span class="hljs-keyword">let</span> indent = { <span class="hljs-attr">number</span>: <span class="hljs-number">0</span> };
<span class="hljs-keyword">export</span> { indent };
</code></pre>
<h3 id="t12010.8 assign.js">10.8 assign.js <a href="#t12010.8 assign.js"> # </a></h3>
<p>src\shared\assign.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> { assign } = <span class="hljs-built_in">Object</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> assign;
</code></pre>
<h3 id="t12110.9 isArray.js">10.9 isArray.js <a href="#t12110.9 isArray.js"> # </a></h3>
<p>src\shared\isArray.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> { isArray } = <span class="hljs-built_in">Array</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> isArray;
</code></pre>
<h3 id="t12210.10 ReactFiber.js">10.10 ReactFiber.js <a href="#t12210.10 ReactFiber.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiber.js</p>
<pre><code class="lang-diff">import {
  HostRoot,
<span class="hljs-addition">+ IndeterminateComponent,</span>
<span class="hljs-addition">+ HostComponent,</span>
<span class="hljs-addition">+ HostText,</span>
} from &quot;./ReactWorkTags&quot;;
import { NoFlags } from &quot;./ReactFiberFlags&quot;;
export function FiberNode(tag, pendingProps, key) {
  this.tag = tag;
  this.key = key;
  this.type = null;
  this.stateNode = null;

  this.return = null;
  this.child = null;
  this.sibling = null;

  this.pendingProps = pendingProps;
  this.memoizedProps = null;
  this.updateQueue = null;
  this.memoizedState = null;

  this.flags = NoFlags;
  this.subtreeFlags = NoFlags;
  this.alternate = null;
}
function createFiber(tag, pendingProps, key) {
  return new FiberNode(tag, pendingProps, key);
}
export function createHostRootFiber() {
  return createFiber(HostRoot, null, null);
}
// We use a double buffering pooling technique because we know that we&apos;ll
// only ever need at most two versions of a tree. We pool the &quot;other&quot; unused
// node that we&apos;re free to reuse. This is lazily created to avoid allocating
// extra objects for things that are never updated. It also allow us to
// reclaim the extra memory if needed.
//&#x6211;&#x4EEC;&#x4F7F;&#x7528;&#x53CC;&#x7F13;&#x51B2;&#x6C60;&#x6280;&#x672F;&#xFF0C;&#x56E0;&#x4E3A;&#x6211;&#x4EEC;&#x77E5;&#x9053;&#x4E00;&#x68F5;&#x6811;&#x6700;&#x591A;&#x53EA;&#x9700;&#x8981;&#x4E24;&#x4E2A;&#x7248;&#x672C;
//&#x6211;&#x4EEC;&#x5C06;&#x201C;&#x5176;&#x4ED6;&#x201D;&#x672A;&#x4F7F;&#x7528;&#x7684;&#x6211;&#x4EEC;&#x53EF;&#x4EE5;&#x81EA;&#x7531;&#x91CD;&#x7528;&#x7684;&#x8282;&#x70B9;
//&#x8FD9;&#x662F;&#x5EF6;&#x8FDF;&#x521B;&#x5EFA;&#x7684;&#xFF0C;&#x4EE5;&#x907F;&#x514D;&#x5206;&#x914D;&#x4ECE;&#x672A;&#x66F4;&#x65B0;&#x7684;&#x5185;&#x5BB9;&#x7684;&#x989D;&#x5916;&#x5BF9;&#x8C61;&#x3002;&#x5B83;&#x8FD8;&#x5141;&#x8BB8;&#x6211;&#x4EEC;&#x5982;&#x679C;&#x9700;&#x8981;&#xFF0C;&#x56DE;&#x6536;&#x989D;&#x5916;&#x7684;&#x5185;&#x5B58;
export function createWorkInProgress(current, pendingProps) {
  let workInProgress = current.alternate;
  if (workInProgress <span class="hljs-comment">=== null) {</span>
    workInProgress = createFiber(current.tag, pendingProps, current.key);
    workInProgress.type = current.type;
    workInProgress.stateNode = current.stateNode;
    workInProgress.alternate = current;
    current.alternate = workInProgress;
  } else {
    workInProgress.pendingProps = pendingProps;
    workInProgress.type = current.type;
    workInProgress.flags = NoFlags;
    workInProgress.subtreeFlags = NoFlags;
  }
  workInProgress.child = current.child;
  workInProgress.memoizedProps = current.memoizedProps;
  workInProgress.memoizedState = current.memoizedState;
  workInProgress.updateQueue = current.updateQueue;
  workInProgress.sibling = current.sibling;
  workInProgress.index = current.index;
  return workInProgress;
}
<span class="hljs-addition">+export function createFiberFromTypeAndProps(type, key, pendingProps) {</span>
<span class="hljs-addition">+  let fiberTag = IndeterminateComponent;</span>
<span class="hljs-addition">+  if (typeof type === &quot;string&quot;) {</span>
<span class="hljs-addition">+    fiberTag = HostComponent;</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+  const fiber = createFiber(fiberTag, pendingProps, key);</span>
<span class="hljs-addition">+  fiber.type = type;</span>
<span class="hljs-addition">+  return fiber;</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+export function createFiberFromElement(element) {</span>
<span class="hljs-addition">+  const { type } = element;</span>
<span class="hljs-addition">+  const { key } = element;</span>
<span class="hljs-addition">+  const pendingProps = element.props;</span>
<span class="hljs-addition">+  const fiber = createFiberFromTypeAndProps(type, key, pendingProps);</span>
<span class="hljs-addition">+  return fiber;</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+</span>
<span class="hljs-addition">+export function createFiberFromText(content) {</span>
<span class="hljs-addition">+  const fiber = createFiber(HostText, content, null);</span>
<span class="hljs-addition">+  return fiber;</span>
<span class="hljs-addition">+}</span>
</code></pre>
<h3 id="t12310.11 ReactFiberFlags.js">10.11 ReactFiberFlags.js <a href="#t12310.11 ReactFiberFlags.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberFlags.js</p>
<pre><code class="lang-diff">export const NoFlags = 0b00000000000000000000000000;
<span class="hljs-addition">+export const Placement = 0b00000000000000000000000010;</span>
<span class="hljs-addition">+export const MutationMask = Placement;</span>
</code></pre>
<h2 id="t12411.completeUnitOfWork">11.completeUnitOfWork <a href="#t12411.completeUnitOfWork"> # </a></h2>
<p><img src="./assets/img/2b253be8939b261b9845ba0999dd56b2.png" alt></p>
<h3 id="t12511.1 ReactFiberWorkLoop.js">11.1 ReactFiberWorkLoop.js <a href="#t12511.1 ReactFiberWorkLoop.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberWorkLoop.js</p>
<pre><code class="lang-diff">import { scheduleCallback } from &quot;scheduler&quot;;
import { createWorkInProgress } from &quot;./ReactFiber&quot;;
import { beginWork } from &quot;./ReactFiberBeginWork&quot;;
<span class="hljs-addition">+import { completeWork } from &quot;./ReactFiberCompleteWork&quot;;</span>
let workInProgress = null;
export function scheduleUpdateOnFiber(root) {
  ensureRootIsScheduled(root);
}
function ensureRootIsScheduled(root) {
  scheduleCallback(performConcurrentWorkOnRoot.bind(null, root));
}
function performConcurrentWorkOnRoot(root) {
  renderRootSync(root);
}
function prepareFreshStack(root) {
  workInProgress = createWorkInProgress(root.current, null);
}
function renderRootSync(root) {
  prepareFreshStack(root);
  workLoopSync();
}

function workLoopSync() {
  while (workInProgress !== null) {
    performUnitOfWork(workInProgress);
  }
}
function performUnitOfWork(unitOfWork) {
  const current = unitOfWork.alternate;
  const next = beginWork(current, unitOfWork);
  unitOfWork.memoizedProps = unitOfWork.pendingProps;
  if (next <span class="hljs-comment">=== null) {</span>
<span class="hljs-addition">+   completeUnitOfWork(unitOfWork);</span>
  } else {
    workInProgress = next;
  }
}

<span class="hljs-addition">+function completeUnitOfWork(unitOfWork) {</span>
<span class="hljs-addition">+  let completedWork = unitOfWork;</span>
<span class="hljs-addition">+  do {</span>
<span class="hljs-addition">+    const current = completedWork.alternate;</span>
<span class="hljs-addition">+    const returnFiber = completedWork.return;</span>
<span class="hljs-addition">+    completeWork(current, completedWork);</span>
<span class="hljs-addition">+    const siblingFiber = completedWork.sibling;</span>
<span class="hljs-addition">+    if (siblingFiber !== null) {</span>
<span class="hljs-addition">+      workInProgress = siblingFiber;</span>
<span class="hljs-addition">+      return;</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+    completedWork = returnFiber;</span>
<span class="hljs-addition">+    workInProgress = completedWork;</span>
<span class="hljs-addition">+  } while (completedWork !== null);</span>
<span class="hljs-addition">+}</span>
</code></pre>
<h3 id="t12611.2 ReactFiberCompleteWork.js">11.2 ReactFiberCompleteWork.js <a href="#t12611.2 ReactFiberCompleteWork.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberCompleteWork.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">import</span> {
  appendInitialChild,
  createInstance,
  createTextInstance,
  finalizeInitialChildren,
} <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-dom-bindings/src/client/ReactDOMHostConfig&quot;</span>;
<span class="hljs-keyword">import</span> { HostComponent, HostRoot, HostText } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./ReactWorkTags&quot;</span>;
<span class="hljs-keyword">import</span> { NoFlags } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./ReactFiberFlags&quot;</span>;
<span class="hljs-keyword">import</span> logger, { indent } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;shared/logger&quot;</span>;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bubbleProperties</span>(<span class="hljs-params">completedWork</span>) </span>{
  <span class="hljs-keyword">let</span> subtreeFlags = NoFlags;
  <span class="hljs-keyword">let</span> child = completedWork.child;
  <span class="hljs-keyword">while</span> (child !== <span class="hljs-literal">null</span>) {
    subtreeFlags |= child.subtreeFlags;
    subtreeFlags |= child.flags;
    child = child.sibling;
  }
  completedWork.subtreeFlags |= subtreeFlags;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">appendAllChildren</span>(<span class="hljs-params">parent, workInProgress</span>) </span>{
  <span class="hljs-comment">// &#x6211;&#x4EEC;&#x53EA;&#x6709;&#x521B;&#x5EFA;&#x7684;&#x9876;&#x7EA7;fiber&#xFF0C;&#x4F46;&#x9700;&#x8981;&#x9012;&#x5F52;&#x5176;&#x5B50;&#x8282;&#x70B9;&#x6765;&#x67E5;&#x627E;&#x6240;&#x6709;&#x7EC8;&#x7AEF;&#x8282;&#x70B9;</span>
  <span class="hljs-keyword">let</span> node = workInProgress.child;
  <span class="hljs-keyword">while</span> (node !== <span class="hljs-literal">null</span>) {
    <span class="hljs-comment">// &#x5982;&#x679C;&#x662F;&#x539F;&#x751F;&#x8282;&#x70B9;&#xFF0C;&#x76F4;&#x63A5;&#x6DFB;&#x52A0;&#x5230;&#x7236;&#x8282;&#x70B9;&#x4E0A;</span>
    <span class="hljs-keyword">if</span> (node.tag === HostComponent || node.tag === HostText) {
      appendInitialChild(parent, node.stateNode);
      <span class="hljs-comment">// &#x518D;&#x770B;&#x770B;&#x7B2C;&#x4E00;&#x4E2A;&#x8282;&#x8282;&#x70B9;&#x662F;&#x4E0D;&#x662F;&#x539F;&#x751F;&#x8282;&#x70B9;</span>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node.child !== <span class="hljs-literal">null</span>) {
      <span class="hljs-comment">// node.child.return = node</span>
      node = node.child;
      <span class="hljs-keyword">continue</span>;
    }
    <span class="hljs-keyword">if</span> (node === workInProgress) {
      <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-comment">// &#x5982;&#x679C;&#x6CA1;&#x6709;&#x5F1F;&#x5F1F;&#x5C31;&#x627E;&#x7236;&#x4EB2;&#x7684;&#x5F1F;&#x5F1F;</span>
    <span class="hljs-keyword">while</span> (node.sibling === <span class="hljs-literal">null</span>) {
      <span class="hljs-comment">// &#x5982;&#x679C;&#x627E;&#x5230;&#x4E86;&#x6839;&#x8282;&#x70B9;&#x6216;&#x8005;&#x56DE;&#x5230;&#x4E86;&#x539F;&#x8282;&#x70B9;&#x7ED3;&#x675F;</span>
      <span class="hljs-keyword">if</span> (node.return === <span class="hljs-literal">null</span> || node.return === workInProgress) {
        <span class="hljs-keyword">return</span>;
      }
      node = node.return;
    }
    <span class="hljs-comment">// node.sibling.return = node.return</span>
    <span class="hljs-comment">// &#x4E0B;&#x4E00;&#x4E2A;&#x5F1F;&#x5F1F;&#x8282;&#x70B9;</span>
    node = node.sibling;
  }
}

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">completeWork</span>(<span class="hljs-params">current, workInProgress</span>) </span>{
  indent.number -= <span class="hljs-number">2</span>;
  logger(<span class="hljs-string">&quot; &quot;</span>.repeat(indent.number) + <span class="hljs-string">&quot;completeWork&quot;</span>, workInProgress);
  <span class="hljs-keyword">const</span> newProps = workInProgress.pendingProps;
  <span class="hljs-keyword">switch</span> (workInProgress.tag) {
    <span class="hljs-keyword">case</span> HostComponent: {
      <span class="hljs-keyword">const</span> { type } = workInProgress;
      <span class="hljs-keyword">const</span> instance = createInstance(type, newProps, workInProgress);
      appendAllChildren(instance, workInProgress);
      workInProgress.stateNode = instance;
      finalizeInitialChildren(instance, type, newProps);
      bubbleProperties(workInProgress);
      <span class="hljs-keyword">break</span>;
    }
    <span class="hljs-keyword">case</span> HostRoot:
      bubbleProperties(workInProgress);
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> HostText: {
      <span class="hljs-keyword">const</span> newText = newProps;
      workInProgress.stateNode = createTextInstance(newText);
      bubbleProperties(workInProgress);
      <span class="hljs-keyword">break</span>;
    }
    <span class="hljs-attr">default</span>:
      <span class="hljs-keyword">break</span>;
  }
}
</code></pre>
<h3 id="t12711.3 ReactDOMHostConfig.js">11.3 ReactDOMHostConfig.js <a href="#t12711.3 ReactDOMHostConfig.js"> # </a></h3>
<p>src\react-dom-bindings\src\client\ReactDOMHostConfig.js</p>
<pre><code class="lang-diff"><span class="hljs-addition">+import { setInitialProperties } from &quot;./ReactDOMComponent&quot;;</span>
export function shouldSetTextContent(type, props) {
  return (
    typeof props.children <span class="hljs-comment">=== &quot;string&quot; || typeof props.children === &quot;number&quot;</span>
  );
}
<span class="hljs-addition">+export const appendInitialChild = (parent, child) =&gt; {</span>
<span class="hljs-addition">+  parent.appendChild(child);</span>
<span class="hljs-addition">+};</span>
<span class="hljs-addition">+export const createInstance = (type, props, internalInstanceHandle) =&gt; {</span>
<span class="hljs-addition">+  const domElement = document.createElement(type);</span>
<span class="hljs-addition">+  return domElement;</span>
<span class="hljs-addition">+};</span>
<span class="hljs-addition">+export const createTextInstance = (content) =&gt; document.createTextNode+(content);</span>
<span class="hljs-addition">+export function finalizeInitialChildren(domElement, type, props) {</span>
<span class="hljs-addition">+  setInitialProperties(domElement, type, props);</span>
<span class="hljs-addition">+}</span>
</code></pre>
<h3 id="t12811.4 ReactDOMComponent.js">11.4 ReactDOMComponent.js <a href="#t12811.4 ReactDOMComponent.js"> # </a></h3>
<p>src\react-dom-bindings\src\client\ReactDOMComponent.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">import</span> { setValueForStyles } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./CSSPropertyOperations&quot;</span>;
<span class="hljs-keyword">import</span> setTextContent <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./setTextContent&quot;</span>;
<span class="hljs-keyword">import</span> { setValueForProperty } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./DOMPropertyOperations&quot;</span>;
<span class="hljs-keyword">const</span> CHILDREN = <span class="hljs-string">&quot;children&quot;</span>;
<span class="hljs-keyword">const</span> STYLE = <span class="hljs-string">&quot;style&quot;</span>;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setInitialDOMProperties</span>(<span class="hljs-params">tag, domElement, nextProps</span>) </span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> propKey <span class="hljs-keyword">in</span> nextProps) {
    <span class="hljs-keyword">if</span> (nextProps.hasOwnProperty(propKey)) {
      <span class="hljs-keyword">const</span> nextProp = nextProps[propKey];
      <span class="hljs-keyword">if</span> (propKey === STYLE) {
        setValueForStyles(domElement, nextProp);
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (propKey === CHILDREN) {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> nextProp === <span class="hljs-string">&quot;string&quot;</span>) {
          setTextContent(domElement, nextProp);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> nextProp === <span class="hljs-string">&quot;number&quot;</span>) {
          setTextContent(domElement, <span class="hljs-string">`<span class="hljs-subst">${nextProp}</span>`</span>);
        }
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nextProp != <span class="hljs-literal">null</span>) {
        setValueForProperty(domElement, propKey, nextProp);
      }
    }
  }
}
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setInitialProperties</span>(<span class="hljs-params">domElement, tag, props</span>) </span>{
  setInitialDOMProperties(tag, domElement, props);
}
</code></pre>
<h3 id="t12911.5 CSSPropertyOperations.js">11.5 CSSPropertyOperations.js <a href="#t12911.5 CSSPropertyOperations.js"> # </a></h3>
<p>src\react-dom-bindings\src\client\CSSPropertyOperations.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setValueForStyles</span>(<span class="hljs-params">node, styles</span>) </span>{
  <span class="hljs-keyword">const</span> { style } = node;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> styleName <span class="hljs-keyword">in</span> styles) {
    <span class="hljs-keyword">if</span> (styles.hasOwnProperty(styleName)) {
      <span class="hljs-keyword">const</span> styleValue = styles[styleName];
      style[styleName] = styleValue;
    }
  }
}
</code></pre>
<h3 id="t13011.6 setTextContent.js">11.6 setTextContent.js <a href="#t13011.6 setTextContent.js"> # </a></h3>
<p>src\react-dom-bindings\src\client\setTextContent.js</p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setTextContent</span>(<span class="hljs-params">node, text</span>) </span>{
  node.textContent = text;
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> setTextContent;
</code></pre>
<h3 id="t13111.7 DOMPropertyOperations.js">11.7 DOMPropertyOperations.js <a href="#t13111.7 DOMPropertyOperations.js"> # </a></h3>
<p>src\react-dom-bindings\src\client\DOMPropertyOperations.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setValueForProperty</span>(<span class="hljs-params">node, name, value</span>) </span>{
  <span class="hljs-keyword">if</span> (value === <span class="hljs-literal">null</span>) {
    node.removeAttribute(name);
  } <span class="hljs-keyword">else</span> {
    node.setAttribute(name, value);
  }
}
</code></pre>
<h2 id="t13212.commitRoot">12.commitRoot <a href="#t13212.commitRoot"> # </a></h2>
<h3 id="t13312.1 ReactFiberWorkLoop.js">12.1 ReactFiberWorkLoop.js <a href="#t13312.1 ReactFiberWorkLoop.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberWorkLoop.js</p>
<pre><code class="lang-diff">import { scheduleCallback } from &quot;scheduler&quot;;
import { createWorkInProgress } from &quot;./ReactFiber&quot;;
import { beginWork } from &quot;./ReactFiberBeginWork&quot;;
import { completeWork } from &quot;./ReactFiberCompleteWork&quot;;
<span class="hljs-addition">+import { MutationMask, NoFlags } from &quot;./ReactFiberFlags&quot;;</span>
let workInProgress = null;
export function scheduleUpdateOnFiber(root) {
  ensureRootIsScheduled(root);
}
function ensureRootIsScheduled(root) {
  scheduleCallback(performConcurrentWorkOnRoot.bind(null, root));
}
function performConcurrentWorkOnRoot(root) {
  renderRootSync(root);
<span class="hljs-addition">+ const finishedWork = root.current.alternate;</span>
<span class="hljs-addition">+ printFiber(finishedWork);</span>
<span class="hljs-addition">+ console.log(`~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`);</span>
<span class="hljs-addition">+ root.finishedWork = finishedWork;</span>
<span class="hljs-addition">+ commitRoot(root);</span>
}
<span class="hljs-addition">+function commitRoot(root) {</span>
<span class="hljs-addition">+  const { finishedWork } = root;</span>
<span class="hljs-addition">+  const subtreeHasEffects =</span>
<span class="hljs-addition">+    (finishedWork.subtreeFlags &amp; MutationMask) !== NoFlags;</span>
<span class="hljs-addition">+  const rootHasEffect = (finishedWork.flags &amp; MutationMask) !== NoFlags;</span>
<span class="hljs-addition">+  if (subtreeHasEffects || rootHasEffect) {</span>
<span class="hljs-addition">+    console.log(&quot;commitRoot&quot;);</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+  root.current = finishedWork;</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+function printFiber(fiber) {</span>
<span class="hljs-addition">+  /*</span>
<span class="hljs-addition">+  fiber.flags &amp;= ~Forked;</span>
<span class="hljs-addition">+  fiber.flags &amp;= ~PlacementDEV;</span>
<span class="hljs-addition">+  fiber.flags &amp;= ~Snapshot;</span>
<span class="hljs-addition">+  fiber.flags &amp;= ~PerformedWork;</span>
<span class="hljs-addition">+  */</span>
<span class="hljs-addition">+  if (fiber.flags !== 0) {</span>
<span class="hljs-addition">+    console.log(</span>
<span class="hljs-addition">+      getFlags(fiber.flags),</span>
<span class="hljs-addition">+      getTag(fiber.tag),</span>
<span class="hljs-addition">+      typeof fiber.type === &quot;function&quot; ? fiber.type.name : fiber.type,</span>
<span class="hljs-addition">+      fiber.memoizedProps</span>
<span class="hljs-addition">+    );</span>
<span class="hljs-addition">+    if (fiber.deletions) {</span>
<span class="hljs-addition">+      for (let i = 0; i &lt; fiber.deletions.length; i++) {</span>
<span class="hljs-addition">+        const childToDelete = fiber.deletions[i];</span>
<span class="hljs-addition">+        console.log(getTag(childToDelete.tag), childToDelete.type, childToDelete.+memoizedProps);</span>
<span class="hljs-addition">+      }</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+  let child = fiber.child;</span>
<span class="hljs-addition">+  while (child) {</span>
<span class="hljs-addition">+    printFiber(child);</span>
<span class="hljs-addition">+    child = child.sibling;</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+function getTag(tag) {</span>
<span class="hljs-addition">+  switch (tag) {</span>
<span class="hljs-addition">+    case FunctionComponent:</span>
<span class="hljs-addition">+      return `FunctionComponent`;</span>
<span class="hljs-addition">+    case HostRoot:</span>
<span class="hljs-addition">+      return `HostRoot`;</span>
<span class="hljs-addition">+    case HostComponent:</span>
<span class="hljs-addition">+      return `HostComponent`;</span>
<span class="hljs-addition">+    case HostText:</span>
<span class="hljs-addition">+      return HostText;</span>
<span class="hljs-addition">+    default:</span>
<span class="hljs-addition">+      return tag;</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+function getFlags(flags) {</span>
<span class="hljs-addition">+  if (flags === (Update | Placement | ChildDeletion)) {</span>
<span class="hljs-addition">+    return `&#x81EA;&#x5DF1;&#x79FB;&#x52A8;&#x548C;&#x5B50;&#x5143;&#x7D20;&#x6709;&#x5220;&#x9664;`;</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+  if (flags === (ChildDeletion | Update)) {</span>
<span class="hljs-addition">+    return `&#x81EA;&#x5DF1;&#x6709;&#x66F4;&#x65B0;&#x548C;&#x5B50;&#x5143;&#x7D20;&#x6709;&#x5220;&#x9664;`;</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+  if (flags === ChildDeletion) {</span>
<span class="hljs-addition">+    return `&#x5B50;&#x5143;&#x7D20;&#x6709;&#x5220;&#x9664;`;</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+  if (flags === (Placement | Update)) {</span>
<span class="hljs-addition">+    return `&#x79FB;&#x52A8;&#x5E76;&#x66F4;&#x65B0;`;</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+  if (flags === Placement) {</span>
<span class="hljs-addition">+    return `&#x63D2;&#x5165;`;</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+  if (flags === Update) {</span>
<span class="hljs-addition">+    return `&#x66F4;&#x65B0;`;</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+  return flags;</span>
<span class="hljs-addition">+}</span>

function prepareFreshStack(root) {
  workInProgress = createWorkInProgress(root.current, null);
}
function renderRootSync(root) {
  prepareFreshStack(root);
  workLoopSync();
}

function workLoopSync() {
  while (workInProgress !== null) {
    performUnitOfWork(workInProgress);
  }
}
function performUnitOfWork(unitOfWork) {
  const current = unitOfWork.alternate;
  const next = beginWork(current, unitOfWork);
  unitOfWork.memoizedProps = unitOfWork.pendingProps;
  if (next <span class="hljs-comment">=== null) {</span>
    completeUnitOfWork(unitOfWork);
  } else {
    workInProgress = next;
  }
}

function completeUnitOfWork(unitOfWork) {
  let completedWork = unitOfWork;
  do {
    const current = completedWork.alternate;
    const returnFiber = completedWork.return;
    completeWork(current, completedWork);
    const siblingFiber = completedWork.sibling;
    if (siblingFiber !== null) {
      workInProgress = siblingFiber;
      return;
    }
    completedWork = returnFiber;
    workInProgress = completedWork;
  } while (completedWork !== null);
}
</code></pre>
<h2 id="t13413.commitMutationEffectsOnFiber">13.commitMutationEffectsOnFiber <a href="#t13413.commitMutationEffectsOnFiber"> # </a></h2>
<h3 id="t13513.1 ReactFiberWorkLoop.js">13.1 ReactFiberWorkLoop.js <a href="#t13513.1 ReactFiberWorkLoop.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberWorkLoop.js</p>
<pre><code class="lang-diff">import { scheduleCallback } from &quot;scheduler&quot;;
import { createWorkInProgress } from &quot;./ReactFiber&quot;;
import { beginWork } from &quot;./ReactFiberBeginWork&quot;;
import { completeWork } from &quot;./ReactFiberCompleteWork&quot;;
import { MutationMask, NoFlags } from &quot;./ReactFiberFlags&quot;;
<span class="hljs-addition">+import { commitMutationEffectsOnFiber } from &quot;./ReactFiberCommitWork&quot;;</span>
let workInProgress = null;
export function scheduleUpdateOnFiber(root) {
  ensureRootIsScheduled(root);
}
function ensureRootIsScheduled(root) {
  scheduleCallback(performConcurrentWorkOnRoot.bind(null, root));
}
function performConcurrentWorkOnRoot(root) {
  renderRootSync(root);
  const finishedWork = root.current.alternate;
  root.finishedWork = finishedWork;
  commitRoot(root);
}
function commitRoot(root) {
  const { finishedWork } = root;
  const subtreeHasEffects =
    (finishedWork.subtreeFlags &amp; MutationMask) !== NoFlags;
  const rootHasEffect = (finishedWork.flags &amp; MutationMask) !== NoFlags;
  if (subtreeHasEffects || rootHasEffect) {
<span class="hljs-addition">+   commitMutationEffectsOnFiber(finishedWork, root);</span>
  }
  root.current = finishedWork;
}
function prepareFreshStack(root) {
  workInProgress = createWorkInProgress(root.current, null);
}
function renderRootSync(root) {
  prepareFreshStack(root);
  workLoopSync();
}

function workLoopSync() {
  while (workInProgress !== null) {
    performUnitOfWork(workInProgress);
  }
}
function performUnitOfWork(unitOfWork) {
  const current = unitOfWork.alternate;
  const next = beginWork(current, unitOfWork);
  unitOfWork.memoizedProps = unitOfWork.pendingProps;
  if (next <span class="hljs-comment">=== null) {</span>
    completeUnitOfWork(unitOfWork);
  } else {
    workInProgress = next;
  }
}

function completeUnitOfWork(unitOfWork) {
  let completedWork = unitOfWork;
  do {
    const current = completedWork.alternate;
    const returnFiber = completedWork.return;
    completeWork(current, completedWork);
    const siblingFiber = completedWork.sibling;
    if (siblingFiber !== null) {
      workInProgress = siblingFiber;
      return;
    }
    completedWork = returnFiber;
    workInProgress = completedWork;
  } while (completedWork !== null);
}

</code></pre>
<h3 id="t13613.2 ReactFiberCommitWork.js">13.2 ReactFiberCommitWork.js <a href="#t13613.2 ReactFiberCommitWork.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberCommitWork.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">import</span> { HostRoot, HostComponent, HostText } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./ReactWorkTags&quot;</span>;
<span class="hljs-keyword">import</span> { MutationMask, Placement } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./ReactFiberFlags&quot;</span>;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">recursivelyTraverseMutationEffects</span>(<span class="hljs-params">root, parentFiber</span>) </span>{
  <span class="hljs-keyword">if</span> (parentFiber.subtreeFlags &amp; MutationMask) {
    <span class="hljs-keyword">let</span> { child } = parentFiber;
    <span class="hljs-keyword">while</span> (child !== <span class="hljs-literal">null</span>) {
      commitMutationEffectsOnFiber(child, root);
      child = child.sibling;
    }
  }
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">commitPlacement</span>(<span class="hljs-params">finishedWork</span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;commitPlacement&quot;</span>, finishedWork);
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">commitReconciliationEffects</span>(<span class="hljs-params">finishedWork</span>) </span>{
  <span class="hljs-keyword">const</span> { flags } = finishedWork;
  <span class="hljs-keyword">if</span> (flags &amp; Placement) {
    commitPlacement(finishedWork);
    finishedWork.flags &amp;= ~Placement;
  }
}
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">commitMutationEffectsOnFiber</span>(<span class="hljs-params">finishedWork, root</span>) </span>{
  <span class="hljs-keyword">switch</span> (finishedWork.tag) {
    <span class="hljs-keyword">case</span> HostRoot:
    <span class="hljs-keyword">case</span> HostComponent:
    <span class="hljs-keyword">case</span> HostText: {
      recursivelyTraverseMutationEffects(root, finishedWork);
      commitReconciliationEffects(finishedWork);
      <span class="hljs-keyword">break</span>;
    }
    <span class="hljs-attr">default</span>: {
      <span class="hljs-keyword">break</span>;
    }
  }
}
</code></pre>
<h2 id="t13714.commitPlacement">14.commitPlacement <a href="#t13714.commitPlacement"> # </a></h2>
<h3 id="t13814.1 ReactFiberCommitWork.js">14.1 ReactFiberCommitWork.js <a href="#t13814.1 ReactFiberCommitWork.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberCommitWork.js</p>
<pre><code class="lang-diff">import { HostRoot, HostComponent, HostText } from &quot;./ReactWorkTags&quot;;
import { MutationMask, Placement } from &quot;./ReactFiberFlags&quot;;
<span class="hljs-addition">+import {</span>
<span class="hljs-addition">+  insertBefore,</span>
<span class="hljs-addition">+  appendChild,</span>
<span class="hljs-addition">+} from &quot;react-dom-bindings/src/client/ReactDOMHostConfig&quot;;</span>
function recursivelyTraverseMutationEffects(root, parentFiber) {
  if (parentFiber.subtreeFlags &amp; MutationMask) {
    let { child } = parentFiber;
    while (child !== null) {
      commitMutationEffectsOnFiber(child, root);
      child = child.sibling;
    }
  }
}
<span class="hljs-addition">+function isHostParent(fiber) {</span>
<span class="hljs-addition">+  return fiber.tag === HostComponent || fiber.tag === HostRoot;</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+function getHostParentFiber(fiber) {</span>
<span class="hljs-addition">+  let parent = fiber.return;</span>
<span class="hljs-addition">+  while (parent !== null) {</span>
<span class="hljs-addition">+    if (isHostParent(parent)) {</span>
<span class="hljs-addition">+      return parent;</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+    parent = parent.return;</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+  return parent;</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+function insertOrAppendPlacementNode(node, before, parent) {</span>
<span class="hljs-addition">+  const { tag } = node;</span>
<span class="hljs-addition">+  const isHost = tag === HostComponent || tag === HostText;</span>
<span class="hljs-addition">+  if (isHost) {</span>
<span class="hljs-addition">+    const { stateNode } = node;</span>
<span class="hljs-addition">+    if (before) {</span>
<span class="hljs-addition">+      insertBefore(parent, stateNode, before);</span>
<span class="hljs-addition">+    } else {</span>
<span class="hljs-addition">+      appendChild(parent, stateNode);</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+  } else {</span>
<span class="hljs-addition">+    const { child } = node;</span>
<span class="hljs-addition">+    if (child !== null) {</span>
<span class="hljs-addition">+      insertOrAppendPlacementNode(child, before, parent);</span>
<span class="hljs-addition">+      let { sibling } = child;</span>
<span class="hljs-addition">+      while (sibling !== null) {</span>
<span class="hljs-addition">+        insertOrAppendPlacementNode(sibling, before, parent);</span>
<span class="hljs-addition">+        sibling = sibling.sibling;</span>
<span class="hljs-addition">+      }</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+function getHostSibling(fiber) {</span>
<span class="hljs-addition">+  let node = fiber;</span>
<span class="hljs-addition">+  siblings: while (true) {</span>
<span class="hljs-addition">+    // &#x5982;&#x679C;&#x6211;&#x4EEC;&#x6CA1;&#x6709;&#x627E;&#x5230;&#x4EFB;&#x4F55;&#x4E1C;&#x897F;&#xFF0C;&#x8BA9;&#x6211;&#x4EEC;&#x8BD5;&#x8BD5;&#x4E0B;&#x4E00;&#x4E2A;&#x5F1F;&#x5F1F;</span>
<span class="hljs-addition">+    while (node.sibling === null) {</span>
<span class="hljs-addition">+      if (node.return === null || isHostParent(node.return)) {</span>
<span class="hljs-addition">+        // &#x5982;&#x679C;&#x6211;&#x4EEC;&#x662F;&#x6839;Fiber&#x6216;&#x8005;&#x7236;&#x4EB2;&#x662F;&#x539F;&#x751F;&#x8282;&#x70B9;&#xFF0C;&#x6211;&#x4EEC;&#x5C31;&#x662F;&#x6700;&#x540E;&#x7684;&#x5F1F;&#x5F1F;</span>
<span class="hljs-addition">+        return null;</span>
<span class="hljs-addition">+      }</span>
<span class="hljs-addition">+      node = node.return;</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+    // node.sibling.return = node.return</span>
<span class="hljs-addition">+    node = node.sibling;</span>
<span class="hljs-addition">+    while (node.tag !== HostComponent &amp;&amp; node.tag !== HostText) {</span>
<span class="hljs-addition">+      // &#x5982;&#x679C;&#x5B83;&#x4E0D;&#x662F;&#x539F;&#x751F;&#x8282;&#x70B9;&#xFF0C;&#x5E76;&#x4E14;&#xFF0C;&#x6211;&#x4EEC;&#x53EF;&#x80FD;&#x5728;&#x5176;&#x4E2D;&#x6709;&#x4E00;&#x4E2A;&#x539F;&#x751F;&#x8282;&#x70B9;</span>
<span class="hljs-addition">+      // &#x8BD5;&#x7740;&#x5411;&#x4E0B;&#x641C;&#x7D22;&#xFF0C;&#x76F4;&#x5230;&#x627E;&#x5230;&#x4E3A;&#x6B62;</span>
<span class="hljs-addition">+      if (node.flags &amp; Placement) {</span>
<span class="hljs-addition">+        // &#x5982;&#x679C;&#x6211;&#x4EEC;&#x6CA1;&#x6709;&#x5B69;&#x5B50;&#xFF0C;&#x53EF;&#x4EE5;&#x8BD5;&#x8BD5;&#x5F1F;&#x5F1F;</span>
<span class="hljs-addition">+        continue siblings;</span>
<span class="hljs-addition">+      } else {</span>
<span class="hljs-addition">+        // node.child.return = node</span>
<span class="hljs-addition">+        node = node.child;</span>
<span class="hljs-addition">+      }</span>
<span class="hljs-addition">+    } // Check if this host node is stable or about to be placed.</span>
<span class="hljs-addition">+    // &#x68C0;&#x67E5;&#x6B64;&#x539F;&#x751F;&#x8282;&#x70B9;&#x662F;&#x5426;&#x7A33;&#x5B9A;&#x53EF;&#x4EE5;&#x653E;&#x7F6E;</span>
<span class="hljs-addition">+    if (!(node.flags &amp; Placement)) {</span>
<span class="hljs-addition">+      // &#x627E;&#x5230;&#x5B83;&#x4E86;!</span>
<span class="hljs-addition">+      return node.stateNode;</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+}</span>
function commitPlacement(finishedWork) {
<span class="hljs-addition">+  const parentFiber = getHostParentFiber(finishedWork);</span>
<span class="hljs-addition">+  switch (parentFiber.tag) {</span>
<span class="hljs-addition">+    case HostComponent: {</span>
<span class="hljs-addition">+      const parent = parentFiber.stateNode;</span>
<span class="hljs-addition">+      const before = getHostSibling(finishedWork);</span>
<span class="hljs-addition">+      insertOrAppendPlacementNode(finishedWork, before, parent);</span>
<span class="hljs-addition">+      break;</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+    case HostRoot: {</span>
<span class="hljs-addition">+      const parent = parentFiber.stateNode.containerInfo;</span>
<span class="hljs-addition">+      const before = getHostSibling(finishedWork);</span>
<span class="hljs-addition">+      insertOrAppendPlacementNode(finishedWork, before, parent);</span>
<span class="hljs-addition">+      break;</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+    default:</span>
<span class="hljs-addition">+      break;</span>
<span class="hljs-addition">+  }</span>
}
function commitReconciliationEffects(finishedWork) {
  const { flags } = finishedWork;
  if (flags &amp; Placement) {
    commitPlacement(finishedWork);
    finishedWork.flags &amp;= ~Placement;
  }
}
export function commitMutationEffectsOnFiber(finishedWork, root) {
  switch (finishedWork.tag) {
    case HostRoot:
    case HostComponent:
    case HostText: {
      recursivelyTraverseMutationEffects(root, finishedWork);
      commitReconciliationEffects(finishedWork);
      break;
    }
    default: {
      break;
    }
  }
}
</code></pre>
<h3 id="t13914.2 ReactDOMHostConfig.js">14.2 ReactDOMHostConfig.js <a href="#t13914.2 ReactDOMHostConfig.js"> # </a></h3>
<p>src\react-dom-bindings\src\client\ReactDOMHostConfig.js</p>
<pre><code class="lang-diff">import { setInitialProperties } from &quot;./ReactDOMComponent&quot;;
export function shouldSetTextContent(type, props) {
  return (
    typeof props.children <span class="hljs-comment">=== &quot;string&quot; || typeof props.children === &quot;number&quot;</span>
  );
}
export const appendInitialChild = (parent, child) =&gt; {
  parent.appendChild(child);
};
export const createInstance = (type, props, internalInstanceHandle) =&gt; {
  const domElement = document.createElement(type);
  return domElement;
};
export const createTextInstance = (content) =&gt; document.createTextNode(content);
export function finalizeInitialChildren(domElement, type, props) {
  setInitialProperties(domElement, type, props);
}
<span class="hljs-addition">+export function appendChild(parentInstance, child) {</span>
<span class="hljs-addition">+  parentInstance.appendChild(child);</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+export function insertBefore(parentInstance, child, beforeChild) {</span>
<span class="hljs-addition">+  parentInstance.insertBefore(child, beforeChild);</span>
<span class="hljs-addition">+}</span>
</code></pre>
<h2 id="t14015.&#x51FD;&#x6570;&#x7EC4;&#x4EF6;">15.&#x51FD;&#x6570;&#x7EC4;&#x4EF6; <a href="#t14015.&#x51FD;&#x6570;&#x7EC4;&#x4EF6;"> # </a></h2>
<h3 id="t14115.1 src\main.jsx">15.1 src\main.jsx <a href="#t14115.1 src\main.jsx"> # </a></h3>
<p>src\main.jsx</p>
<pre><code class="lang-diff">import { createRoot } from &quot;react-dom/client&quot;;
<span class="hljs-addition">+function FunctionComponent() {</span>
<span class="hljs-addition">+  return (</span>
<span class="hljs-addition">+    &lt;h1&gt;</span>
<span class="hljs-addition">+      hello&lt;span style={{ color: &quot;red&quot; }}&gt;world&lt;/span&gt;</span>
<span class="hljs-addition">+    &lt;/h1&gt;</span>
<span class="hljs-addition">+  );</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+let element = &lt;FunctionComponent /&gt;;</span>
const root = createRoot(document.getElementById(&quot;root&quot;));
root.render(element);
</code></pre>
<h3 id="t14215.2 ReactWorkTags.js">15.2 ReactWorkTags.js <a href="#t14215.2 ReactWorkTags.js"> # </a></h3>
<p>src\react-reconciler\src\ReactWorkTags.js</p>
<pre><code class="lang-diff"><span class="hljs-addition">+export const FunctionComponent = 0;</span>
<span class="hljs-addition">+export const IndeterminateComponent = 2;</span>
export const HostRoot = 3;
export const HostComponent = 5;
export const HostText = 6;
</code></pre>
<h3 id="t14315.3 ReactFiberBeginWork.js">15.3 ReactFiberBeginWork.js <a href="#t14315.3 ReactFiberBeginWork.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberBeginWork.js</p>
<pre><code class="lang-diff">import {
  HostRoot,
  HostComponent,
  HostText,
<span class="hljs-addition">+ IndeterminateComponent,</span>
<span class="hljs-addition">+ FunctionComponent,</span>
} from &quot;./ReactWorkTags&quot;;
import { processUpdateQueue } from &quot;./ReactFiberClassUpdateQueue&quot;;
import { mountChildFibers, reconcileChildFibers } from &quot;./ReactChildFiber&quot;;
import { shouldSetTextContent } from &quot;react-dom-bindings/src/client/ReactDOMHostConfig&quot;;
import logger, { indent } from &quot;shared/logger&quot;;
<span class="hljs-addition">+import { renderWithHooks } from &quot;react-reconciler/src/ReactFiberHooks&quot;;</span>
function reconcileChildren(current, workInProgress, nextChildren) {
  if (current <span class="hljs-comment">=== null) {</span>
    workInProgress.child = mountChildFibers(workInProgress, null, nextChildren);
  } else {
    workInProgress.child = reconcileChildFibers(
      workInProgress,
      current.child,
      nextChildren
    );
  }
}
function updateHostRoot(current, workInProgress) {
  processUpdateQueue(workInProgress);
  const nextState = workInProgress.memoizedState;
  const nextChildren = nextState.element;
  reconcileChildren(current, workInProgress, nextChildren);
  return workInProgress.child;
}
function updateHostComponent(current, workInProgress) {
  const { type } = workInProgress;
  const nextProps = workInProgress.pendingProps;
  let nextChildren = nextProps.children;
  const isDirectTextChild = shouldSetTextContent(type, nextProps);
  if (isDirectTextChild) {
    nextChildren = null;
  }
  reconcileChildren(current, workInProgress, nextChildren);
  return workInProgress.child;
}
<span class="hljs-addition">+function mountIndeterminateComponent(_current, workInProgress, Component) {</span>
<span class="hljs-addition">+  const props = workInProgress.pendingProps;</span>
<span class="hljs-addition">+  const value = renderWithHooks(null, workInProgress, Component, props);</span>
<span class="hljs-addition">+  workInProgress.tag = FunctionComponent;</span>
<span class="hljs-addition">+  reconcileChildren(null, workInProgress, value);</span>
<span class="hljs-addition">+  return workInProgress.child;</span>
<span class="hljs-addition">+}</span>
export function beginWork(current, workInProgress) {
  logger(&quot; &quot;.repeat(indent.number) + &quot;beginWork&quot;, workInProgress);
  indent.number += 2;
  switch (workInProgress.tag) {
<span class="hljs-addition">+   case IndeterminateComponent: {</span>
<span class="hljs-addition">+     return mountIndeterminateComponent(</span>
<span class="hljs-addition">+       current,</span>
<span class="hljs-addition">+       workInProgress,</span>
<span class="hljs-addition">+       workInProgress.type</span>
<span class="hljs-addition">+     );</span>
<span class="hljs-addition">+   }</span>
    case HostRoot:
      return updateHostRoot(current, workInProgress);
    case HostComponent:
      return updateHostComponent(current, workInProgress);
    case HostText:
    default:
      return null;
  }
}
</code></pre>
<h3 id="t14415.4 ReactFiberHooks.js">15.4 ReactFiberHooks.js <a href="#t14415.4 ReactFiberHooks.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberHooks.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">renderWithHooks</span>(<span class="hljs-params">current, workInProgress, Component, props</span>) </span>{
  <span class="hljs-keyword">const</span> children = Component(props);
  <span class="hljs-keyword">return</span> children;
}
</code></pre>
<h3 id="t14515.5 ReactFiberCommitWork.js">15.5 ReactFiberCommitWork.js <a href="#t14515.5 ReactFiberCommitWork.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberCommitWork.js</p>
<pre><code class="lang-diff">import {
  HostRoot,
  HostComponent,
  HostText,
<span class="hljs-addition">+ FunctionComponent,</span>
} from &quot;./ReactWorkTags&quot;;
import { MutationMask, Placement } from &quot;./ReactFiberFlags&quot;;
import {
  insertBefore,
  appendChild,
} from &quot;react-dom-bindings/src/client/ReactDOMHostConfig&quot;;
function recursivelyTraverseMutationEffects(root, parentFiber) {
  if (parentFiber.subtreeFlags &amp; MutationMask) {
    let { child } = parentFiber;
    while (child !== null) {
      commitMutationEffectsOnFiber(child, root);
      child = child.sibling;
    }
  }
}
function isHostParent(fiber) {
  return fiber.tag <span class="hljs-comment">=== HostComponent || fiber.tag === HostRoot;</span>
}
function getHostParentFiber(fiber) {
  let parent = fiber.return;
  while (parent !== null) {
    if (isHostParent(parent)) {
      return parent;
    }
    parent = parent.return;
  }
  return parent;
}
function insertOrAppendPlacementNode(node, before, parent) {
  const { tag } = node;
  const isHost = tag <span class="hljs-comment">=== HostComponent || tag === HostText;</span>
  if (isHost) {
    const { stateNode } = node;
    if (before) {
      insertBefore(parent, stateNode, before);
    } else {
      appendChild(parent, stateNode);
    }
  } else {
    const { child } = node;
    if (child !== null) {
      insertOrAppendPlacementNode(child, before, parent);
      let { sibling } = child;
      while (sibling !== null) {
        insertOrAppendPlacementNode(sibling, before, parent);
        sibling = sibling.sibling;
      }
    }
  }
}
function getHostSibling(fiber) {
  let node = fiber;
  siblings: while (true) {
    // &#x5982;&#x679C;&#x6211;&#x4EEC;&#x6CA1;&#x6709;&#x627E;&#x5230;&#x4EFB;&#x4F55;&#x4E1C;&#x897F;&#xFF0C;&#x8BA9;&#x6211;&#x4EEC;&#x8BD5;&#x8BD5;&#x4E0B;&#x4E00;&#x4E2A;&#x5F1F;&#x5F1F;
    while (node.sibling <span class="hljs-comment">=== null) {</span>
      if (node.return <span class="hljs-comment">=== null || isHostParent(node.return)) {</span>
        // &#x5982;&#x679C;&#x6211;&#x4EEC;&#x662F;&#x6839;Fiber&#x6216;&#x8005;&#x7236;&#x4EB2;&#x662F;&#x539F;&#x751F;&#x8282;&#x70B9;&#xFF0C;&#x6211;&#x4EEC;&#x5C31;&#x662F;&#x6700;&#x540E;&#x7684;&#x5F1F;&#x5F1F;
        return null;
      }
      node = node.return;
    }
    // node.sibling.return = node.return
    node = node.sibling;
    while (node.tag !== HostComponent &amp;&amp; node.tag !== HostText) {
      // &#x5982;&#x679C;&#x5B83;&#x4E0D;&#x662F;&#x539F;&#x751F;&#x8282;&#x70B9;&#xFF0C;&#x5E76;&#x4E14;&#xFF0C;&#x6211;&#x4EEC;&#x53EF;&#x80FD;&#x5728;&#x5176;&#x4E2D;&#x6709;&#x4E00;&#x4E2A;&#x539F;&#x751F;&#x8282;&#x70B9;
      // &#x8BD5;&#x7740;&#x5411;&#x4E0B;&#x641C;&#x7D22;&#xFF0C;&#x76F4;&#x5230;&#x627E;&#x5230;&#x4E3A;&#x6B62;
      if (node.flags &amp; Placement) {
        // &#x5982;&#x679C;&#x6211;&#x4EEC;&#x6CA1;&#x6709;&#x5B69;&#x5B50;&#xFF0C;&#x53EF;&#x4EE5;&#x8BD5;&#x8BD5;&#x5F1F;&#x5F1F;
        continue siblings;
      } else {
        // node.child.return = node
        node = node.child;
      }
    } // Check if this host node is stable or about to be placed.
    // &#x68C0;&#x67E5;&#x6B64;&#x539F;&#x751F;&#x8282;&#x70B9;&#x662F;&#x5426;&#x7A33;&#x5B9A;&#x53EF;&#x4EE5;&#x653E;&#x7F6E;
    if (!(node.flags &amp; Placement)) {
      // &#x627E;&#x5230;&#x5B83;&#x4E86;!
      return node.stateNode;
    }
  }
}
function commitPlacement(finishedWork) {
  const parentFiber = getHostParentFiber(finishedWork);
  switch (parentFiber.tag) {
    case HostComponent: {
      const parent = parentFiber.stateNode;
      const before = getHostSibling(finishedWork);
      insertOrAppendPlacementNode(finishedWork, before, parent);
      break;
    }
    case HostRoot: {
      const parent = parentFiber.stateNode.containerInfo;
      const before = getHostSibling(finishedWork);
      insertOrAppendPlacementNode(finishedWork, before, parent);
      break;
    }
    default:
      break;
  }
}
function commitReconciliationEffects(finishedWork) {
  const { flags } = finishedWork;
  if (flags &amp; Placement) {
    commitPlacement(finishedWork);
    finishedWork.flags &amp;= ~Placement;
  }
}
export function commitMutationEffectsOnFiber(finishedWork, root) {
  switch (finishedWork.tag) {
    case HostRoot:
<span class="hljs-addition">+   case FunctionComponent:</span>
    case HostComponent:
    case HostText: {
      recursivelyTraverseMutationEffects(root, finishedWork);
      commitReconciliationEffects(finishedWork);
      break;
    }
    default: {
      break;
    }
  }
}
</code></pre>
<h2 id="t14616.&#x6CE8;&#x518C;&#x4E8B;&#x4EF6;&#x540D;">16.&#x6CE8;&#x518C;&#x4E8B;&#x4EF6;&#x540D; <a href="#t14616.&#x6CE8;&#x518C;&#x4E8B;&#x4EF6;&#x540D;"> # </a></h2>
<h3 id="t14716.1 src\main.jsx">16.1 src\main.jsx <a href="#t14716.1 src\main.jsx"> # </a></h3>
<p>src\main.jsx</p>
<pre><code class="lang-diff">import { createRoot } from &quot;react-dom/client&quot;;
function FunctionComponent() {
  return (
<span class="hljs-addition">+   &lt;h1</span>
<span class="hljs-addition">+     onClick={() =&gt; console.log(&quot;onClick FunctionComponent&quot;)}</span>
<span class="hljs-addition">+     onClickCapture={() =&gt; console.log(&quot;onClickCapture FunctionComponent&quot;)}</span>
<span class="hljs-addition">+   &gt;</span>
<span class="hljs-addition">+     hello</span>
<span class="hljs-addition">+     &lt;span</span>
<span class="hljs-addition">+       style={{ color: &quot;red&quot; }}</span>
<span class="hljs-addition">+       onClick={() =&gt; console.log(&quot;onClick span&quot;)}</span>
<span class="hljs-addition">+       onClickCapture={() =&gt; console.log(&quot;onClickCapture span&quot;)}</span>
<span class="hljs-addition">+     &gt;</span>
<span class="hljs-addition">+       world</span>
<span class="hljs-addition">+     &lt;/span&gt;</span>
<span class="hljs-addition">+   &lt;/h1&gt;</span>
  );
}
let element = &lt;FunctionComponent /&gt;;
const root = createRoot(document.getElementById(&quot;root&quot;));
root.render(element);
</code></pre>
<h3 id="t14816.2 ReactDOMRoot.js">16.2 ReactDOMRoot.js <a href="#t14816.2 ReactDOMRoot.js"> # </a></h3>
<p>src\react-dom\src\client\ReactDOMRoot.js</p>
<pre><code class="lang-diff">import {
  createContainer,
  updateContainer,
} from &quot;react-reconciler/src/ReactFiberReconciler&quot;;
<span class="hljs-addition">+import { listenToAllSupportedEvents } from &quot;react-dom-bindings/src/events/DOMPluginEventSystem&quot;;</span>

function ReactDOMRoot(internalRoot) {
  this._internalRoot = internalRoot;
}
ReactDOMRoot.prototype.render = function render(children) {
  const root = this._internalRoot;
  root.containerInfo.innerHTML = &quot;&quot;;
  updateContainer(children, root);
};
export function createRoot(container) {
  const root = createContainer(container);
<span class="hljs-addition">+ listenToAllSupportedEvents(container);</span>
  return new ReactDOMRoot(root);
}
</code></pre>
<h3 id="t14916.3 DOMPluginEventSystem.js">16.3 DOMPluginEventSystem.js <a href="#t14916.3 DOMPluginEventSystem.js"> # </a></h3>
<p>src\react-dom-bindings\src\events\DOMPluginEventSystem.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">import</span> { allNativeEvents } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./EventRegistry&quot;</span>;
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> SimpleEventPlugin <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./plugins/SimpleEventPlugin&quot;</span>;
SimpleEventPlugin.registerEvents();
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">listenToAllSupportedEvents</span>(<span class="hljs-params">rootContainerElement</span>) </span>{
  allNativeEvents.forEach(<span class="hljs-function">(<span class="hljs-params">domEventName</span>) =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(domEventName);
  });
}
</code></pre>
<h3 id="t15016.4 EventRegistry.js">16.4 EventRegistry.js <a href="#t15016.4 EventRegistry.js"> # </a></h3>
<p>src\react-dom-bindings\src\events\EventRegistry.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> allNativeEvents = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">registerTwoPhaseEvent</span>(<span class="hljs-params">registrationName, dependencies</span>) </span>{
  registerDirectEvent(registrationName, dependencies);
  registerDirectEvent(registrationName + <span class="hljs-string">&quot;Capture&quot;</span>, dependencies);
}
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">registerDirectEvent</span>(<span class="hljs-params">registrationName, dependencies</span>) </span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; dependencies.length; i++) {
    allNativeEvents.add(dependencies[i]); <span class="hljs-comment">// click</span>
  }
}
</code></pre>
<h3 id="t15116.5 SimpleEventPlugin.js">16.5 SimpleEventPlugin.js <a href="#t15116.5 SimpleEventPlugin.js"> # </a></h3>
<p>src\react-dom-bindings\src\events\plugins\SimpleEventPlugin.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">import</span> { registerSimpleEvents } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../DOMEventProperties&quot;</span>;
<span class="hljs-keyword">export</span> { registerSimpleEvents <span class="hljs-keyword">as</span> registerEvents };
</code></pre>
<h3 id="t15216.6 DOMEventProperties.js">16.6 DOMEventProperties.js <a href="#t15216.6 DOMEventProperties.js"> # </a></h3>
<p>src\react-dom-bindings\src\events\DOMEventProperties.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">import</span> { registerTwoPhaseEvent } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./EventRegistry&quot;</span>;

<span class="hljs-keyword">const</span> simpleEventPluginEvents = [<span class="hljs-string">&quot;click&quot;</span>];
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">registerSimpleEvent</span>(<span class="hljs-params">domEventName, reactName</span>) </span>{
  registerTwoPhaseEvent(reactName, [domEventName]);
}

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">registerSimpleEvents</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; simpleEventPluginEvents.length; i++) {
    <span class="hljs-keyword">const</span> eventName = simpleEventPluginEvents[i]; <span class="hljs-comment">// click</span>
    <span class="hljs-keyword">const</span> domEventName = eventName.toLowerCase(); <span class="hljs-comment">// click</span>
    <span class="hljs-keyword">const</span> capitalizedEvent = eventName[<span class="hljs-number">0</span>].toUpperCase() + eventName.slice(<span class="hljs-number">1</span>); <span class="hljs-comment">// Click</span>
    registerSimpleEvent(domEventName, <span class="hljs-string">`on<span class="hljs-subst">${capitalizedEvent}</span>`</span>); <span class="hljs-comment">// click=&gt;onClick</span>
  }
}
</code></pre>
<h2 id="t15317.listenToNativeEvent">17.listenToNativeEvent <a href="#t15317.listenToNativeEvent"> # </a></h2>
<h3 id="t15417.1 DOMPluginEventSystem.js">17.1 DOMPluginEventSystem.js <a href="#t15417.1 DOMPluginEventSystem.js"> # </a></h3>
<p>src\react-dom-bindings\src\events\DOMPluginEventSystem.js</p>
<pre><code class="lang-diff">import { allNativeEvents } from &quot;./EventRegistry&quot;;
import * as SimpleEventPlugin from &quot;./plugins/SimpleEventPlugin&quot;;
<span class="hljs-addition">+import { createEventListenerWrapperWithPriority } from &quot;./ReactDOMEventListener&quot;;</span>
<span class="hljs-addition">+import { IS_CAPTURE_PHASE } from &quot;./EventSystemFlags&quot;;</span>
<span class="hljs-addition">+import { addEventCaptureListener, addEventBubbleListener } from &quot;./EventListener&quot;;</span>

SimpleEventPlugin.registerEvents();

export function listenToAllSupportedEvents(rootContainerElement) {
  allNativeEvents.forEach((domEventName) =&gt; {
<span class="hljs-addition">+   listenToNativeEvent(domEventName, true, rootContainerElement);</span>
<span class="hljs-addition">+   listenToNativeEvent(domEventName, false, rootContainerElement);</span>
  });
}

<span class="hljs-addition">+export function listenToNativeEvent(domEventName, isCapturePhaseListener, +target) {</span>
<span class="hljs-addition">+  let eventSystemFlags = 0; // &#x5192;&#x6CE1; = 0 &#x6355;&#x83B7; = 4</span>
<span class="hljs-addition">+  if (isCapturePhaseListener) {</span>
<span class="hljs-addition">+    eventSystemFlags |= IS_CAPTURE_PHASE;</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+  addTrappedEventListener(target, domEventName, eventSystemFlags, isCapturePhaseListener);</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+function addTrappedEventListener(targetContainer, domEventName, +eventSystemFlags, isCapturePhaseListener) {</span>
<span class="hljs-addition">+  const listener = createEventListenerWrapperWithPriority(targetContainer, domEventName, eventSystemFlags);</span>
<span class="hljs-addition">+  if (isCapturePhaseListener) {</span>
<span class="hljs-addition">+    addEventCaptureListener(targetContainer, domEventName, listener);</span>
<span class="hljs-addition">+  } else {</span>
<span class="hljs-addition">+    addEventBubbleListener(targetContainer, domEventName, listener);</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+}</span>
</code></pre>
<h3 id="t15517.2 EventSystemFlags.js">17.2 EventSystemFlags.js <a href="#t15517.2 EventSystemFlags.js"> # </a></h3>
<p>src\react-dom-bindings\src\events\EventSystemFlags.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> IS_CAPTURE_PHASE = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">2</span>;
</code></pre>
<h3 id="t15617.3 ReactDOMEventListener.js">17.3 ReactDOMEventListener.js <a href="#t15617.3 ReactDOMEventListener.js"> # </a></h3>
<p>src\react-dom-bindings\src\events\ReactDOMEventListener.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createEventListenerWrapperWithPriority</span>(<span class="hljs-params">targetContainer, domEventName, eventSystemFlags</span>) </span>{
  <span class="hljs-keyword">const</span> listenerWrapper = dispatchDiscreteEvent;
  <span class="hljs-keyword">return</span> listenerWrapper.bind(<span class="hljs-literal">null</span>, domEventName, eventSystemFlags, targetContainer);
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dispatchDiscreteEvent</span>(<span class="hljs-params">domEventName, eventSystemFlags, container, nativeEvent</span>) </span>{
  dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
}
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dispatchEvent</span>(<span class="hljs-params">domEventName, eventSystemFlags, targetContainer, nativeEvent</span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;dispatchEvent&quot;</span>, domEventName, eventSystemFlags, targetContainer, nativeEvent);
}
</code></pre>
<h3 id="t15717.4 EventListener.js">17.4 EventListener.js <a href="#t15717.4 EventListener.js"> # </a></h3>
<p>src\react-dom-bindings\src\events\EventListener.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addEventCaptureListener</span>(<span class="hljs-params">target, eventType, listener</span>) </span>{
  target.addEventListener(eventType, listener, <span class="hljs-literal">true</span>);
  <span class="hljs-keyword">return</span> listener;
}

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addEventBubbleListener</span>(<span class="hljs-params">target, eventType, listener</span>) </span>{
  target.addEventListener(eventType, listener, <span class="hljs-literal">false</span>);
  <span class="hljs-keyword">return</span> listener;
}
</code></pre>
<h2 id="t15818.extractEvents">18.extractEvents <a href="#t15818.extractEvents"> # </a></h2>
<h3 id="t15918.1 ReactDOMEventListener.js">18.1 ReactDOMEventListener.js <a href="#t15918.1 ReactDOMEventListener.js"> # </a></h3>
<p>src\react-dom-bindings\src\events\ReactDOMEventListener.js</p>
<pre><code class="lang-diff"><span class="hljs-addition">+import getEventTarget from &quot;./getEventTarget&quot;;</span>
<span class="hljs-addition">+import { getClosestInstanceFromNode } from &quot;../client/ReactDOMComponentTree&quot;;</span>
<span class="hljs-addition">+import { dispatchEventForPluginEventSystem } from &quot;./DOMPluginEventSystem&quot;;</span>

<span class="hljs-addition">+export function createEventListenerWrapperWithPriority(</span>
<span class="hljs-addition">+  targetContainer,</span>
<span class="hljs-addition">+  domEventName,</span>
<span class="hljs-addition">+  eventSystemFlags</span>
<span class="hljs-addition">+) {</span>
<span class="hljs-addition">+  const listenerWrapper = dispatchDiscreteEvent;</span>
<span class="hljs-addition">+  return listenerWrapper.bind(null, domEventName, eventSystemFlags, targetContainer);</span>
<span class="hljs-addition">+}</span>

<span class="hljs-addition">+function dispatchDiscreteEvent(domEventName, eventSystemFlags, container, nativeEvent) {</span>
<span class="hljs-addition">+  dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);</span>
<span class="hljs-addition">+}</span>
export function dispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
<span class="hljs-addition">+ const nativeEventTarget = getEventTarget(nativeEvent);</span>
<span class="hljs-addition">+ const targetInst = getClosestInstanceFromNode(nativeEventTarget);</span>
<span class="hljs-addition">+ dispatchEventForPluginEventSystem(</span>
<span class="hljs-addition">+   domEventName,</span>
<span class="hljs-addition">+   eventSystemFlags,</span>
<span class="hljs-addition">+   nativeEvent,</span>
<span class="hljs-addition">+   targetInst,</span>
<span class="hljs-addition">+   targetContainer</span>
<span class="hljs-addition">+ );</span>
}
</code></pre>
<h3 id="t16018.2 getEventTarget.js">18.2 getEventTarget.js <a href="#t16018.2 getEventTarget.js"> # </a></h3>
<p>src\react-dom-bindings\src\events\getEventTarget.js</p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getEventTarget</span>(<span class="hljs-params">nativeEvent</span>) </span>{
  <span class="hljs-keyword">const</span> target = nativeEvent.target || nativeEvent.srcElement || <span class="hljs-built_in">window</span>;
  <span class="hljs-keyword">return</span> target;
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> getEventTarget;
</code></pre>
<h3 id="t16118.3 ReactDOMComponentTree.js">18.3 ReactDOMComponentTree.js <a href="#t16118.3 ReactDOMComponentTree.js"> # </a></h3>
<p>src\react-dom-bindings\src\client\ReactDOMComponentTree.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> randomKey = <span class="hljs-built_in">Math</span>.random().toString(<span class="hljs-number">36</span>).slice(<span class="hljs-number">2</span>);
<span class="hljs-keyword">const</span> internalInstanceKey = <span class="hljs-string">&quot;__reactFiber$&quot;</span> + randomKey;
<span class="hljs-keyword">const</span> internalPropsKey = <span class="hljs-string">&quot;__reactProps$&quot;</span> + randomKey;

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getClosestInstanceFromNode</span>(<span class="hljs-params">targetNode</span>) </span>{
  <span class="hljs-keyword">const</span> targetInst = targetNode[internalInstanceKey];
  <span class="hljs-keyword">if</span> (targetInst) {
    <span class="hljs-keyword">return</span> targetInst;
  }
  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
}

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getFiberCurrentPropsFromNode</span>(<span class="hljs-params">node</span>) </span>{
  <span class="hljs-keyword">return</span> node[internalPropsKey] || <span class="hljs-literal">null</span>;
}

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">precacheFiberNode</span>(<span class="hljs-params">hostInst, node</span>) </span>{
  node[internalInstanceKey] = hostInst;
}

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateFiberProps</span>(<span class="hljs-params">node, props</span>) </span>{
  node[internalPropsKey] = props;
}
</code></pre>
<h3 id="t16218.4 DOMPluginEventSystem.js">18.4 DOMPluginEventSystem.js <a href="#t16218.4 DOMPluginEventSystem.js"> # </a></h3>
<p>src\react-dom-bindings\src\events\DOMPluginEventSystem.js</p>
<pre><code class="lang-diff">import { allNativeEvents } from &quot;./EventRegistry&quot;;
import * as SimpleEventPlugin from &quot;./plugins/SimpleEventPlugin&quot;;
import { createEventListenerWrapperWithPriority } from &quot;./ReactDOMEventListener&quot;;
import { IS_CAPTURE_PHASE } from &quot;./EventSystemFlags&quot;;
import { addEventCaptureListener, addEventBubbleListener } from &quot;./EventListener&quot;;
<span class="hljs-addition">+import getEventTarget from &quot;./getEventTarget&quot;;</span>
<span class="hljs-addition">+import getListener from &quot;./getListener&quot;;</span>
<span class="hljs-addition">+import { HostComponent } from &quot;react-reconciler/src/ReactWorkTags&quot;;</span>

SimpleEventPlugin.registerEvents();

export function listenToAllSupportedEvents(rootContainerElement) {
  allNativeEvents.forEach((domEventName) =&gt; {
    listenToNativeEvent(domEventName, true, rootContainerElement);
    listenToNativeEvent(domEventName, false, rootContainerElement);
  });
}

export function listenToNativeEvent(domEventName, isCapturePhaseListener, target) {
  let eventSystemFlags = 0; // &#x5192;&#x6CE1; = 0 &#x6355;&#x83B7; = 4
  if (isCapturePhaseListener) {
    eventSystemFlags |= IS_CAPTURE_PHASE;
  }
  addTrappedEventListener(target, domEventName, eventSystemFlags, isCapturePhaseListener);
}
function addTrappedEventListener(targetContainer, domEventName, eventSystemFlags, isCapturePhaseListener) {
  const listener = createEventListenerWrapperWithPriority(targetContainer, domEventName, eventSystemFlags);
  if (isCapturePhaseListener) {
    addEventCaptureListener(targetContainer, domEventName, listener);
  } else {
    addEventBubbleListener(targetContainer, domEventName, listener);
  }
}
<span class="hljs-addition">+export function dispatchEventForPluginEventSystem(</span>
<span class="hljs-addition">+  domEventName,</span>
<span class="hljs-addition">+  eventSystemFlags,</span>
<span class="hljs-addition">+  nativeEvent,</span>
<span class="hljs-addition">+  targetInst,</span>
<span class="hljs-addition">+  targetContainer</span>
<span class="hljs-addition">+) {</span>
<span class="hljs-addition">+  dispatchEventsForPlugins(domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer);</span>
<span class="hljs-addition">+}</span>

<span class="hljs-addition">+function dispatchEventsForPlugins(domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer) {</span>
<span class="hljs-addition">+  const nativeEventTarget = getEventTarget(nativeEvent);</span>
<span class="hljs-addition">+  const dispatchQueue = [];</span>
<span class="hljs-addition">+  extractEvents(</span>
<span class="hljs-addition">+    dispatchQueue,</span>
<span class="hljs-addition">+    domEventName,</span>
<span class="hljs-addition">+    targetInst,</span>
<span class="hljs-addition">+    nativeEvent,</span>
<span class="hljs-addition">+    nativeEventTarget,</span>
<span class="hljs-addition">+    eventSystemFlags,</span>
<span class="hljs-addition">+    targetContainer</span>
<span class="hljs-addition">+  );</span>
<span class="hljs-addition">+  console.log(&quot;dispatchQueue&quot;, dispatchQueue);</span>
<span class="hljs-addition">+}</span>

<span class="hljs-addition">+function extractEvents(</span>
<span class="hljs-addition">+  dispatchQueue,</span>
<span class="hljs-addition">+  domEventName,</span>
<span class="hljs-addition">+  targetInst,</span>
<span class="hljs-addition">+  nativeEvent,</span>
<span class="hljs-addition">+  nativeEventTarget,</span>
<span class="hljs-addition">+  eventSystemFlags,</span>
<span class="hljs-addition">+  targetContainer</span>
<span class="hljs-addition">+) {</span>
<span class="hljs-addition">+  SimpleEventPlugin.extractEvents(</span>
<span class="hljs-addition">+    dispatchQueue,</span>
<span class="hljs-addition">+    domEventName,</span>
<span class="hljs-addition">+    targetInst,</span>
<span class="hljs-addition">+    nativeEvent,</span>
<span class="hljs-addition">+    nativeEventTarget,</span>
<span class="hljs-addition">+    eventSystemFlags,</span>
<span class="hljs-addition">+    targetContainer</span>
<span class="hljs-addition">+  );</span>
<span class="hljs-addition">+}</span>

<span class="hljs-addition">+export function accumulateSinglePhaseListeners(targetFiber, reactName, nativeEventType, inCapturePhase) {</span>
<span class="hljs-addition">+  const captureName = reactName + &quot;Capture&quot;;</span>
<span class="hljs-addition">+  const reactEventName = inCapturePhase ? captureName : reactName;</span>
<span class="hljs-addition">+  const listeners = [];</span>
<span class="hljs-addition">+  let instance = targetFiber;</span>
<span class="hljs-addition">+  while (instance !== null) {</span>
<span class="hljs-addition">+    const { stateNode, tag } = instance;</span>
<span class="hljs-addition">+    if (tag === HostComponent &amp;&amp; stateNode !== null) {</span>
<span class="hljs-addition">+      if (reactEventName !== null) {</span>
<span class="hljs-addition">+        const listener = getListener(instance, reactEventName);</span>
<span class="hljs-addition">+        if (listener !== null &amp;&amp; listener !== undefined) {</span>
<span class="hljs-addition">+          listeners.push(createDispatchListener(instance, listener, stateNode));</span>
<span class="hljs-addition">+        }</span>
<span class="hljs-addition">+      }</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+    instance = instance.return;</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+  return listeners;</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+function createDispatchListener(instance, listener, currentTarget) {</span>
<span class="hljs-addition">+  return {</span>
<span class="hljs-addition">+    instance,</span>
<span class="hljs-addition">+    listener,</span>
<span class="hljs-addition">+    currentTarget,</span>
<span class="hljs-addition">+  };</span>
<span class="hljs-addition">+}</span>
</code></pre>
<h3 id="t16318.5 getListener.js">18.5 getListener.js <a href="#t16318.5 getListener.js"> # </a></h3>
<p>src\react-dom-bindings\src\events\getListener.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">import</span> { getFiberCurrentPropsFromNode } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../client/ReactDOMComponentTree&quot;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getListener</span>(<span class="hljs-params">inst, registrationName</span>) </span>{
  <span class="hljs-keyword">const</span> stateNode = inst.stateNode;
  <span class="hljs-keyword">if</span> (stateNode === <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }
  <span class="hljs-keyword">const</span> props = getFiberCurrentPropsFromNode(stateNode);
  <span class="hljs-keyword">if</span> (props === <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }
  <span class="hljs-keyword">const</span> listener = props[registrationName];
  <span class="hljs-keyword">return</span> listener;
}
</code></pre>
<h3 id="t16418.6 SimpleEventPlugin.js">18.6 SimpleEventPlugin.js <a href="#t16418.6 SimpleEventPlugin.js"> # </a></h3>
<p>src\react-dom-bindings\src\events\plugins\SimpleEventPlugin.js</p>
<pre><code class="lang-diff">import { registerSimpleEvents, topLevelEventsToReactNames } from &quot;../DOMEventProperties&quot;;
import { SyntheticMouseEvent } from &quot;../SyntheticEvent&quot;;
import { IS_CAPTURE_PHASE } from &quot;../EventSystemFlags&quot;;
import { accumulateSinglePhaseListeners } from &quot;../DOMPluginEventSystem&quot;;

<span class="hljs-addition">+function extractEvents(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags) {</span>
<span class="hljs-addition">+  const reactName = topLevelEventsToReactNames.get(domEventName);</span>
<span class="hljs-addition">+  let SyntheticEventCtor;</span>
<span class="hljs-addition">+  switch (domEventName) {</span>
<span class="hljs-addition">+    case &quot;click&quot;:</span>
<span class="hljs-addition">+      SyntheticEventCtor = SyntheticMouseEvent;</span>
<span class="hljs-addition">+      break;</span>
<span class="hljs-addition">+    default:</span>
<span class="hljs-addition">+      break;</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+  const inCapturePhase = (eventSystemFlags &amp; IS_CAPTURE_PHASE) !== 0;</span>
<span class="hljs-addition">+  const listeners = accumulateSinglePhaseListeners(targetInst, reactName, nativeEvent.type, inCapturePhase);</span>
<span class="hljs-addition">+  if (listeners.length &gt; 0) {</span>
<span class="hljs-addition">+    const event = new SyntheticEventCtor(reactName, domEventName, targetInst, nativeEvent, nativeEventTarget);</span>
<span class="hljs-addition">+    dispatchQueue.push({</span>
<span class="hljs-addition">+      event,</span>
<span class="hljs-addition">+      listeners,</span>
<span class="hljs-addition">+    });</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+export { registerSimpleEvents as registerEvents, extractEvents };</span>
</code></pre>
<h3 id="t16518.7 SyntheticEvent.js">18.7 SyntheticEvent.js <a href="#t16518.7 SyntheticEvent.js"> # </a></h3>
<p>src\react-dom-bindings\src\events\SyntheticEvent.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">import</span> assign <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;shared/assign&quot;</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">functionThatReturnsTrue</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">functionThatReturnsFalse</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
}
<span class="hljs-keyword">const</span> MouseEventInterface = {
  <span class="hljs-attr">clientX</span>: <span class="hljs-number">0</span>,
  <span class="hljs-attr">clientY</span>: <span class="hljs-number">0</span>,
};
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createSyntheticEvent</span>(<span class="hljs-params">Interface</span>) </span>{
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SyntheticBaseEvent</span>(<span class="hljs-params">reactName, reactEventType, targetInst, nativeEvent, nativeEventTarget</span>) </span>{
    <span class="hljs-keyword">this</span>._reactName = reactName;
    <span class="hljs-keyword">this</span>.type = reactEventType;
    <span class="hljs-keyword">this</span>._targetInst = targetInst;
    <span class="hljs-keyword">this</span>.nativeEvent = nativeEvent;
    <span class="hljs-keyword">this</span>.target = nativeEventTarget;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> propName <span class="hljs-keyword">in</span> Interface) {
      <span class="hljs-keyword">if</span> (!Interface.hasOwnProperty(propName)) {
        <span class="hljs-keyword">continue</span>;
      }
      <span class="hljs-keyword">this</span>[propName] = nativeEvent[propName];
    }
    <span class="hljs-keyword">this</span>.isDefaultPrevented = functionThatReturnsFalse;
    <span class="hljs-keyword">this</span>.isPropagationStopped = functionThatReturnsFalse;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  }

  assign(SyntheticBaseEvent.prototype, {
    preventDefault() {
      <span class="hljs-keyword">const</span> event = <span class="hljs-keyword">this</span>.nativeEvent;
      <span class="hljs-keyword">if</span> (event.preventDefault) {
        event.preventDefault();
      } <span class="hljs-keyword">else</span> {
        event.returnValue = <span class="hljs-literal">false</span>;
      }
      <span class="hljs-keyword">this</span>.isDefaultPrevented = functionThatReturnsTrue;
    },
    stopPropagation() {
      <span class="hljs-keyword">const</span> event = <span class="hljs-keyword">this</span>.nativeEvent;
      <span class="hljs-keyword">if</span> (event.stopPropagation) {
        event.stopPropagation();
      } <span class="hljs-keyword">else</span> {
        event.cancelBubble = <span class="hljs-literal">true</span>;
      }
      <span class="hljs-keyword">this</span>.isPropagationStopped = functionThatReturnsTrue;
    },
  });
  <span class="hljs-keyword">return</span> SyntheticBaseEvent;
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface);
</code></pre>
<h3 id="t16618.8 ReactDOMHostConfig.js">18.8 ReactDOMHostConfig.js <a href="#t16618.8 ReactDOMHostConfig.js"> # </a></h3>
<p>src\react-dom-bindings\src\client\ReactDOMHostConfig.js</p>
<pre><code class="lang-diff">import { setInitialProperties } from &quot;./ReactDOMComponent&quot;;
<span class="hljs-addition">+import { precacheFiberNode, updateFiberProps } from &quot;./ReactDOMComponentTree&quot;;</span>

export function shouldSetTextContent(type, props) {
  return typeof props.children <span class="hljs-comment">=== &quot;string&quot; || typeof props.children === &quot;number&quot;;</span>
}
export const appendInitialChild = (parent, child) =&gt; {
  parent.appendChild(child);
};
export const createInstance = (type, props, internalInstanceHandle) =&gt; {
  const domElement = document.createElement(type);
<span class="hljs-addition">+ precacheFiberNode(internalInstanceHandle, domElement);</span>
<span class="hljs-addition">+ updateFiberProps(domElement, props);</span>
  return domElement;
};
export const createTextInstance = (content) =&gt; document.createTextNode(content);
export function finalizeInitialChildren(domElement, type, props) {
  setInitialProperties(domElement, type, props);
}
export function appendChild(parentInstance, child) {
  parentInstance.appendChild(child);
}
export function insertBefore(parentInstance, child, beforeChild) {
  parentInstance.insertBefore(child, beforeChild);
}
</code></pre>
<h3 id="t16718.9 DOMEventProperties.js">18.9 DOMEventProperties.js <a href="#t16718.9 DOMEventProperties.js"> # </a></h3>
<p>src\react-dom-bindings\src\events\DOMEventProperties.js</p>
<pre><code class="lang-diff">import { registerTwoPhaseEvent } from &quot;./EventRegistry&quot;;
<span class="hljs-addition">+export const topLevelEventsToReactNames = new Map();</span>
const simpleEventPluginEvents = [&quot;click&quot;];
function registerSimpleEvent(domEventName, reactName) {
<span class="hljs-addition">+ topLevelEventsToReactNames.set(domEventName, reactName);</span>
  registerTwoPhaseEvent(reactName, [domEventName]);
}

export function registerSimpleEvents() {
  for (let i = 0; i &lt; simpleEventPluginEvents.length; i++) {
    const eventName = simpleEventPluginEvents[i]; // click
    const domEventName = eventName.toLowerCase(); // click
    const capitalizedEvent = eventName[0].toUpperCase() + eventName.slice(1); // Click
    registerSimpleEvent(domEventName, `on${capitalizedEvent}`); // click=&gt;onClick
  }
}

</code></pre>
<h2 id="t16819.processDispatchQueue">19.processDispatchQueue <a href="#t16819.processDispatchQueue"> # </a></h2>
<h3 id="t16919.1 DOMPluginEventSystem.js">19.1 DOMPluginEventSystem.js <a href="#t16919.1 DOMPluginEventSystem.js"> # </a></h3>
<p>src\react-dom-bindings\src\events\DOMPluginEventSystem.js</p>
<pre><code class="lang-diff">import { allNativeEvents } from &quot;./EventRegistry&quot;;
import * as SimpleEventPlugin from &quot;./plugins/SimpleEventPlugin&quot;;
import { createEventListenerWrapperWithPriority } from &quot;./ReactDOMEventListener&quot;;
import { IS_CAPTURE_PHASE } from &quot;./EventSystemFlags&quot;;
import { addEventCaptureListener, addEventBubbleListener } from &quot;./EventListener&quot;;
import getEventTarget from &quot;./getEventTarget&quot;;
import getListener from &quot;./getListener&quot;;
import { HostComponent } from &quot;react-reconciler/src/ReactWorkTags&quot;;

SimpleEventPlugin.registerEvents();

export function listenToAllSupportedEvents(rootContainerElement) {
  allNativeEvents.forEach((domEventName) =&gt; {
    listenToNativeEvent(domEventName, true, rootContainerElement);
    listenToNativeEvent(domEventName, false, rootContainerElement);
  });
}

export function listenToNativeEvent(domEventName, isCapturePhaseListener, target) {
  let eventSystemFlags = 0; // &#x5192;&#x6CE1; = 0 &#x6355;&#x83B7; = 4
  if (isCapturePhaseListener) {
    eventSystemFlags |= IS_CAPTURE_PHASE;
  }
  addTrappedEventListener(target, domEventName, eventSystemFlags, isCapturePhaseListener);
}
function addTrappedEventListener(targetContainer, domEventName, eventSystemFlags, isCapturePhaseListener) {
  const listener = createEventListenerWrapperWithPriority(targetContainer, domEventName, eventSystemFlags);
  if (isCapturePhaseListener) {
    addEventCaptureListener(targetContainer, domEventName, listener);
  } else {
    addEventBubbleListener(targetContainer, domEventName, listener);
  }
}
export function dispatchEventForPluginEventSystem(
  domEventName,
  eventSystemFlags,
  nativeEvent,
  targetInst,
  targetContainer
) {
  dispatchEventsForPlugins(domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer);
}

function dispatchEventsForPlugins(domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer) {
  const nativeEventTarget = getEventTarget(nativeEvent);
  const dispatchQueue = [];
  extractEvents(
    dispatchQueue,
    domEventName,
    targetInst,
    nativeEvent,
    nativeEventTarget,
    eventSystemFlags,
    targetContainer
  );
<span class="hljs-addition">+ processDispatchQueue(dispatchQueue, eventSystemFlags);</span>
}

<span class="hljs-addition">+export function processDispatchQueue(dispatchQueue, eventSystemFlags) {</span>
<span class="hljs-addition">+  const inCapturePhase = (eventSystemFlags &amp; IS_CAPTURE_PHASE) !== 0;</span>
<span class="hljs-addition">+  for (let i = 0; i &lt; dispatchQueue.length; i++) {</span>
<span class="hljs-addition">+    const { event, listeners } = dispatchQueue[i];</span>
<span class="hljs-addition">+    processDispatchQueueItemsInOrder(event, listeners, inCapturePhase); //  event system doesn&apos;t use pooling.</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+function processDispatchQueueItemsInOrder(event, dispatchListeners, inCapturePhase) {</span>
<span class="hljs-addition">+  if (inCapturePhase) {</span>
<span class="hljs-addition">+    for (let i = dispatchListeners.length - 1; i &gt;= 0; i--) {</span>
<span class="hljs-addition">+      const { currentTarget, listener } = dispatchListeners[i];</span>
<span class="hljs-addition">+      if (event.isPropagationStopped()) {</span>
<span class="hljs-addition">+        return;</span>
<span class="hljs-addition">+      }</span>
<span class="hljs-addition">+      executeDispatch(event, listener, currentTarget);</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+  } else {</span>
<span class="hljs-addition">+    for (let i = 0; i &lt; dispatchListeners.length; i++) {</span>
<span class="hljs-addition">+      const { currentTarget, listener } = dispatchListeners[i];</span>
<span class="hljs-addition">+      if (event.isPropagationStopped()) {</span>
<span class="hljs-addition">+        return;</span>
<span class="hljs-addition">+      }</span>
<span class="hljs-addition">+      executeDispatch(event, listener, currentTarget);</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+function executeDispatch(event, listener, currentTarget) {</span>
<span class="hljs-addition">+  event.currentTarget = currentTarget;</span>
<span class="hljs-addition">+  listener(event);</span>
<span class="hljs-addition">+  event.currentTarget = null;</span>
<span class="hljs-addition">+}</span>
function extractEvents(
  dispatchQueue,
  domEventName,
  targetInst,
  nativeEvent,
  nativeEventTarget,
  eventSystemFlags,
  targetContainer
) {
  SimpleEventPlugin.extractEvents(
    dispatchQueue,
    domEventName,
    targetInst,
    nativeEvent,
    nativeEventTarget,
    eventSystemFlags,
    targetContainer
  );
}

export function accumulateSinglePhaseListeners(targetFiber, reactName, nativeEventType, inCapturePhase) {
  const captureName = reactName + &quot;Capture&quot;;
  const reactEventName = inCapturePhase ? captureName : reactName;
  const listeners = [];
  let instance = targetFiber;
  while (instance !== null) {
    const { stateNode, tag } = instance;
    if (tag <span class="hljs-comment">=== HostComponent &amp;&amp; stateNode !== null) {</span>
      if (reactEventName !== null) {
        const listener = getListener(instance, reactEventName);
        if (listener !== null &amp;&amp; listener !== undefined) {
          listeners.push(createDispatchListener(instance, listener, stateNode));
        }
      }
    }
    instance = instance.return;
  }

  return listeners;
}
function createDispatchListener(instance, listener, currentTarget) {
  return {
    instance,
    listener,
    currentTarget,
  };
}
</code></pre>
<h2 id="t17020.dispatchReducerAction">20.dispatchReducerAction <a href="#t17020.dispatchReducerAction"> # </a></h2>
<h3 id="t17120.1 src\main.jsx">20.1 src\main.jsx <a href="#t17120.1 src\main.jsx"> # </a></h3>
<p>src\main.jsx</p>
<pre><code class="lang-diff">import * as React from &quot;react&quot;;
import { createRoot } from &quot;react-dom/client&quot;;
<span class="hljs-addition">+const reducer = (state, action) =&gt; {</span>
<span class="hljs-addition">+  if (action.type === &quot;add&quot;) return state + 1;</span>
<span class="hljs-addition">+  return state;</span>
<span class="hljs-addition">+};</span>
function FunctionComponent() {
<span class="hljs-addition">+  const [number, setNumber] = React.useReducer(reducer, 0);</span>
<span class="hljs-addition">+  return &lt;button onClick={() =&gt; setNumber({ type: &quot;add&quot; })}&gt;{number}&lt;/button&gt;;</span>
}
let element = &lt;FunctionComponent /&gt;;
const root = createRoot(document.getElementById(&quot;root&quot;));
root.render(element);
</code></pre>
<h3 id="t17220.2 ReactFiberHooks.js">20.2 ReactFiberHooks.js <a href="#t17220.2 ReactFiberHooks.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberHooks.js</p>
<pre><code class="lang-diff"><span class="hljs-addition">+import ReactSharedInternals from &quot;shared/ReactSharedInternals&quot;;</span>
<span class="hljs-addition">+</span>
<span class="hljs-addition">+const { ReactCurrentDispatcher } = ReactSharedInternals;</span>
<span class="hljs-addition">+let currentlyRenderingFiber = null;</span>
<span class="hljs-addition">+let workInProgressHook = null;</span>
<span class="hljs-addition">+</span>
<span class="hljs-addition">+function mountWorkInProgressHook() {</span>
<span class="hljs-addition">+  const hook = {</span>
<span class="hljs-addition">+    memoizedState: null,</span>
<span class="hljs-addition">+    queue: null,</span>
<span class="hljs-addition">+    next: null,</span>
<span class="hljs-addition">+  };</span>
<span class="hljs-addition">+  if (workInProgressHook === null) {</span>
<span class="hljs-addition">+    currentlyRenderingFiber.memoizedState = workInProgressHook = hook;</span>
<span class="hljs-addition">+  } else {</span>
<span class="hljs-addition">+    workInProgressHook = workInProgressHook.next = hook;</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+  return workInProgressHook;</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+function dispatchReducerAction(fiber, queue, action) {</span>
<span class="hljs-addition">+  console.log(&quot;dispatchReducerAction&quot;, action);</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+const HooksDispatcherOnMountInDEV = {</span>
<span class="hljs-addition">+  useReducer:mountReducer</span>
<span class="hljs-addition">+};</span>
<span class="hljs-addition">+function useReducer(reducer, initialArg){</span>
<span class="hljs-addition">+    const hook = mountWorkInProgressHook();</span>
<span class="hljs-addition">+    hook.memoizedState = initialArg;</span>
<span class="hljs-addition">+    const queue = {</span>
<span class="hljs-addition">+      pending: null,</span>
<span class="hljs-addition">+      dispatch: null,</span>
<span class="hljs-addition">+    };</span>
<span class="hljs-addition">+    hook.queue = queue;</span>
<span class="hljs-addition">+    const dispatch = (queue.dispatch = dispatchReducerAction.bind(null, currentlyRenderingFiber, queue));</span>
<span class="hljs-addition">+    return [hook.memoizedState, dispatch];</span>
}
export function renderWithHooks(current, workInProgress, Component, props) {
<span class="hljs-addition">+ currentlyRenderingFiber = workInProgress;</span>
<span class="hljs-addition">+ if (current !== null &amp;&amp; current.memoizedState !== null) {</span>
<span class="hljs-addition">+ } else {</span>
<span class="hljs-addition">+   ReactCurrentDispatcher.current = HooksDispatcherOnMountInDEV;</span>
<span class="hljs-addition">+ }</span>
  const children = Component(props);
<span class="hljs-addition">+ currentlyRenderingFiber = null;</span>
  return children;
}
</code></pre>
<h3 id="t17320.3 react\index.js">20.3 react\index.js <a href="#t17320.3 react\index.js"> # </a></h3>
<p>src\react\index.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">export</span> { __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, useReducer } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./src/React&quot;</span>;
</code></pre>
<h3 id="t17420.4 React.js">20.4 React.js <a href="#t17420.4 React.js"> # </a></h3>
<p>src\react\src\React.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">import</span> { useReducer } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./ReactHooks&quot;</span>;
<span class="hljs-keyword">import</span> ReactSharedInternals <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./ReactSharedInternals&quot;</span>;

<span class="hljs-keyword">export</span> { useReducer, ReactSharedInternals <span class="hljs-keyword">as</span> __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED };
</code></pre>
<h3 id="t17520.5 ReactHooks.js">20.5 ReactHooks.js <a href="#t17520.5 ReactHooks.js"> # </a></h3>
<p>src\react\src\ReactHooks.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">import</span> ReactCurrentDispatcher <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./ReactCurrentDispatcher&quot;</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolveDispatcher</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> dispatcher = ReactCurrentDispatcher.current;
  <span class="hljs-keyword">return</span> dispatcher;
}

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">useReducer</span>(<span class="hljs-params">reducer, initialArg, init</span>) </span>{
  <span class="hljs-keyword">const</span> dispatcher = resolveDispatcher();
  <span class="hljs-keyword">return</span> dispatcher.useReducer(reducer, initialArg, init);
}
</code></pre>
<h3 id="t17620.6 ReactCurrentDispatcher.js">20.6 ReactCurrentDispatcher.js <a href="#t17620.6 ReactCurrentDispatcher.js"> # </a></h3>
<p>src\react\src\ReactCurrentDispatcher.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> ReactCurrentDispatcher = {
  <span class="hljs-attr">current</span>: <span class="hljs-literal">null</span>,
};
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> ReactCurrentDispatcher;
</code></pre>
<h3 id="t17720.7 ReactSharedInternals.js">20.7 ReactSharedInternals.js <a href="#t17720.7 ReactSharedInternals.js"> # </a></h3>
<p>src\react\src\ReactSharedInternals.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">import</span> ReactCurrentDispatcher <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./ReactCurrentDispatcher&quot;</span>;

<span class="hljs-keyword">const</span> ReactSharedInternals = {
  ReactCurrentDispatcher,
};
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> ReactSharedInternals;
</code></pre>
<h3 id="t17820.8 ReactSharedInternals.js">20.8 ReactSharedInternals.js <a href="#t17820.8 ReactSharedInternals.js"> # </a></h3>
<p>src\shared\ReactSharedInternals.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;

<span class="hljs-keyword">const</span> ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> ReactSharedInternals;
</code></pre>
<h2 id="t17921.HooksDispatcherOnUpdateInDEV">21.HooksDispatcherOnUpdateInDEV <a href="#t17921.HooksDispatcherOnUpdateInDEV"> # </a></h2>
<h3 id="t18021.1 ReactFiberHooks.js">21.1 ReactFiberHooks.js <a href="#t18021.1 ReactFiberHooks.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberHooks.js</p>
<pre><code class="lang-diff">import ReactSharedInternals from &quot;shared/ReactSharedInternals&quot;;
<span class="hljs-addition">+import { enqueueConcurrentHookUpdate } from &quot;./ReactFiberConcurrentUpdates&quot;;</span>
<span class="hljs-addition">+import { scheduleUpdateOnFiber } from &quot;./ReactFiberWorkLoop&quot;;</span>

const { ReactCurrentDispatcher } = ReactSharedInternals;
let currentlyRenderingFiber = null;
let workInProgressHook = null;
<span class="hljs-addition">+let currentHook = null;</span>

function mountWorkInProgressHook() {
  const hook = {
    memoizedState: null,
    queue: null,
    next: null,
  };
  if (workInProgressHook <span class="hljs-comment">=== null) {</span>
    currentlyRenderingFiber.memoizedState = workInProgressHook = hook;
  } else {
    workInProgressHook = workInProgressHook.next = hook;
  }
  return workInProgressHook;
}
function dispatchReducerAction(fiber, queue, action) {
<span class="hljs-addition">+ const update = {</span>
<span class="hljs-addition">+   action,</span>
<span class="hljs-addition">+   next: null,</span>
<span class="hljs-addition">+ };</span>
<span class="hljs-addition">+ const root = enqueueConcurrentHookUpdate(fiber, queue, update);</span>
<span class="hljs-addition">+ scheduleUpdateOnFiber(root, fiber);</span>
}
const HooksDispatcherOnMountInDEV = {
  useReducer:mountReducer
};
function mountReducer(reducer, initialArg) {
    const hook = mountWorkInProgressHook();
    hook.memoizedState = initialArg;
    const queue = {
      pending: null,
      dispatch: null,
    };
    hook.queue = queue;
    const dispatch = (queue.dispatch = dispatchReducerAction.bind(null, currentlyRenderingFiber, queue));
    return [hook.memoizedState, dispatch];
}
<span class="hljs-addition">+function updateWorkInProgressHook() {</span>
<span class="hljs-addition">+  if (currentHook === null) {</span>
<span class="hljs-addition">+    const current = currentlyRenderingFiber.alternate</span>
<span class="hljs-addition">+    currentHook = current.memoizedState</span>
<span class="hljs-addition">+  } else {</span>
<span class="hljs-addition">+    currentHook = currentHook.next</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+  const newHook = {</span>
<span class="hljs-addition">+    memoizedState: currentHook.memoizedState,</span>
<span class="hljs-addition">+    queue: currentHook.queue,</span>
<span class="hljs-addition">+    next: null</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+  if (workInProgressHook === null) {</span>
<span class="hljs-addition">+    currentlyRenderingFiber.memoizedState = workInProgressHook = newHook</span>
<span class="hljs-addition">+  } else {</span>
<span class="hljs-addition">+    workInProgressHook = workInProgressHook.next = newHook</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+  return workInProgressHook</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+const HooksDispatcherOnUpdateInDEV = {</span>
<span class="hljs-addition">+  useReducer&#xFF1A;updateReducer</span>
<span class="hljs-addition">+};</span>
<span class="hljs-addition">+function updateReducer(reducer) {</span>
<span class="hljs-addition">+  const hook = updateWorkInProgressHook()</span>
<span class="hljs-addition">+  const queue = hook.queue</span>
<span class="hljs-addition">+  queue.lastRenderedReducer = reducer</span>
<span class="hljs-addition">+  const current = currentHook</span>
<span class="hljs-addition">+  const pendingQueue = queue.pending</span>
<span class="hljs-addition">+  let newState = current.memoizedState</span>
<span class="hljs-addition">+  if (pendingQueue !== null) {</span>
<span class="hljs-addition">+    queue.pending = null</span>
<span class="hljs-addition">+    const first = pendingQueue.next</span>
<span class="hljs-addition">+    let update = first</span>
<span class="hljs-addition">+    do {</span>
<span class="hljs-addition">+      if (update.hasEagerState) {</span>
<span class="hljs-addition">+        newState = update.eagerState</span>
<span class="hljs-addition">+      } else {</span>
<span class="hljs-addition">+        const action = update.action</span>
<span class="hljs-addition">+        newState = reducer(newState, action)</span>
<span class="hljs-addition">+      }</span>
<span class="hljs-addition">+      update = update.next</span>
<span class="hljs-addition">+    } while (update !== null &amp;&amp; update !== first)</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+  hook.memoizedState = queue.lastRenderedState = newState</span>
<span class="hljs-addition">+  return [hook.memoizedState, queue.dispatch]</span>
<span class="hljs-addition">+},</span>
export function renderWithHooks(current, workInProgress, Component, props) {
  currentlyRenderingFiber = workInProgress;
  if (current !== null &amp;&amp; current.memoizedState !== null) {
<span class="hljs-addition">+   ReactCurrentDispatcher.current = HooksDispatcherOnUpdateInDEV;</span>
  } else {
    ReactCurrentDispatcher.current = HooksDispatcherOnMountInDEV;
  }
  const children = Component(props);
  currentlyRenderingFiber = null;
<span class="hljs-addition">+ workInProgressHook = null;</span>
<span class="hljs-addition">+ currentHook = null;</span>
  return children;
}
</code></pre>
<h3 id="t18121.2 ReactFiberConcurrentUpdates.js">21.2 ReactFiberConcurrentUpdates.js <a href="#t18121.2 ReactFiberConcurrentUpdates.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberConcurrentUpdates.js</p>
<pre><code class="lang-diff">import { HostRoot } from &quot;./ReactWorkTags&quot;;

<span class="hljs-addition">+const concurrentQueues = [];</span>
<span class="hljs-addition">+let concurrentQueuesIndex = 0;</span>

export function markUpdateLaneFromFiberToRoot(sourceFiber) {
  let node = sourceFiber;
  let parent = sourceFiber.return;
  while (parent !== null) {
    node = parent;
    parent = parent.return;
  }
  if (node.tag <span class="hljs-comment">=== HostRoot) {</span>
    const root = node.stateNode;
    return root;
  }
  return null;
}
<span class="hljs-addition">+export function enqueueConcurrentHookUpdate(fiber, queue, update) {</span>
<span class="hljs-addition">+  enqueueUpdate(fiber, queue, update);</span>
<span class="hljs-addition">+  return getRootForUpdatedFiber(fiber);</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+function enqueueUpdate(fiber, queue, update) {</span>
<span class="hljs-addition">+  concurrentQueues[concurrentQueuesIndex++] = fiber;</span>
<span class="hljs-addition">+  concurrentQueues[concurrentQueuesIndex++] = queue;</span>
<span class="hljs-addition">+  concurrentQueues[concurrentQueuesIndex++] = update;</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+function getRootForUpdatedFiber(sourceFiber) {</span>
<span class="hljs-addition">+  let node = sourceFiber;</span>
<span class="hljs-addition">+  let parent = node.return;</span>
<span class="hljs-addition">+  while (parent !== null) {</span>
<span class="hljs-addition">+    node = parent;</span>
<span class="hljs-addition">+    parent = node.return;</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+  return node.tag === HostRoot ? node.stateNode : null;</span>
<span class="hljs-addition">+}</span>

<span class="hljs-addition">+export function finishQueueingConcurrentUpdates() {</span>
<span class="hljs-addition">+  const endIndex = concurrentQueuesIndex;</span>
<span class="hljs-addition">+  concurrentQueuesIndex = 0;</span>
<span class="hljs-addition">+  let i = 0;</span>
<span class="hljs-addition">+  while (i &lt; endIndex) {</span>
<span class="hljs-addition">+    const fiber = concurrentQueues[i++];</span>
<span class="hljs-addition">+    const queue = concurrentQueues[i++];</span>
<span class="hljs-addition">+    const update = concurrentQueues[i++];</span>
<span class="hljs-addition">+    if (queue !== null &amp;&amp; update !== null) {</span>
<span class="hljs-addition">+      const pending = queue.pending;</span>
<span class="hljs-addition">+      if (pending === null) {</span>
<span class="hljs-addition">+        update.next = update;</span>
<span class="hljs-addition">+      } else {</span>
<span class="hljs-addition">+        update.next = pending.next;</span>
<span class="hljs-addition">+        pending.next = update;</span>
<span class="hljs-addition">+      }</span>
<span class="hljs-addition">+      queue.pending = update;</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+}</span>

</code></pre>
<h3 id="t18221.3 ReactFiberWorkLoop.js">21.3 ReactFiberWorkLoop.js <a href="#t18221.3 ReactFiberWorkLoop.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberWorkLoop.js</p>
<pre><code class="lang-diff">import { scheduleCallback } from &quot;scheduler&quot;;
import { createWorkInProgress } from &quot;./ReactFiber&quot;;
import { beginWork } from &quot;./ReactFiberBeginWork&quot;;
import { completeWork } from &quot;./ReactFiberCompleteWork&quot;;
import { MutationMask, NoFlags } from &quot;./ReactFiberFlags&quot;;
import { commitMutationEffectsOnFiber } from &quot;./ReactFiberCommitWork&quot;;
<span class="hljs-addition">+import { finishQueueingConcurrentUpdates } from &quot;./ReactFiberConcurrentUpdates&quot;;</span>

let workInProgress = null;
export function scheduleUpdateOnFiber(root) {
  ensureRootIsScheduled(root);
}
function ensureRootIsScheduled(root) {
  scheduleCallback(performConcurrentWorkOnRoot.bind(null, root));
}
function performConcurrentWorkOnRoot(root) {
  renderRootSync(root);
  const finishedWork = root.current.alternate;
  root.finishedWork = finishedWork;
  commitRoot(root);
}
function commitRoot(root) {
  const { finishedWork } = root;
  const subtreeHasEffects = (finishedWork.subtreeFlags &amp; MutationMask) !== NoFlags;
  const rootHasEffect = (finishedWork.flags &amp; MutationMask) !== NoFlags;
  if (subtreeHasEffects || rootHasEffect) {
    commitMutationEffectsOnFiber(finishedWork, root);
  }
  root.current = finishedWork;
}
function prepareFreshStack(root) {
  workInProgress = createWorkInProgress(root.current, null);
<span class="hljs-addition">+ finishQueueingConcurrentUpdates();</span>
}
function renderRootSync(root) {
  prepareFreshStack(root);
  workLoopSync();
}

function workLoopSync() {
  while (workInProgress !== null) {
    performUnitOfWork(workInProgress);
  }
}
function performUnitOfWork(unitOfWork) {
  const current = unitOfWork.alternate;
  const next = beginWork(current, unitOfWork);
  unitOfWork.memoizedProps = unitOfWork.pendingProps;
  if (next <span class="hljs-comment">=== null) {</span>
    completeUnitOfWork(unitOfWork);
  } else {
    workInProgress = next;
  }
}

function completeUnitOfWork(unitOfWork) {
  let completedWork = unitOfWork;
  do {
    const current = completedWork.alternate;
    const returnFiber = completedWork.return;
    completeWork(current, completedWork);
    const siblingFiber = completedWork.sibling;
    if (siblingFiber !== null) {
      workInProgress = siblingFiber;
      return;
    }
    completedWork = returnFiber;
    workInProgress = completedWork;
  } while (completedWork !== null);
}
</code></pre>
<h3 id="t18321.4 ReactFiberBeginWork.js">21.4 ReactFiberBeginWork.js <a href="#t18321.4 ReactFiberBeginWork.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberBeginWork.js</p>
<pre><code class="lang-diff">import { HostRoot, HostComponent, HostText, IndeterminateComponent, FunctionComponent } from &quot;./ReactWorkTags&quot;;
import { processUpdateQueue } from &quot;./ReactFiberClassUpdateQueue&quot;;
import { mountChildFibers, reconcileChildFibers } from &quot;./ReactChildFiber&quot;;
import { shouldSetTextContent } from &quot;react-dom-bindings/src/client/ReactDOMHostConfig&quot;;
import logger, { indent } from &quot;shared/logger&quot;;
import { renderWithHooks } from &quot;react-reconciler/src/ReactFiberHooks&quot;;
function reconcileChildren(current, workInProgress, nextChildren) {
  if (current <span class="hljs-comment">=== null) {</span>
    workInProgress.child = mountChildFibers(workInProgress, null, nextChildren);
  } else {
    workInProgress.child = reconcileChildFibers(workInProgress, current.child, nextChildren);
  }
}
function updateHostRoot(current, workInProgress) {
  processUpdateQueue(workInProgress);
  const nextState = workInProgress.memoizedState;
  const nextChildren = nextState.element;
  reconcileChildren(current, workInProgress, nextChildren);
  return workInProgress.child;
}
function updateHostComponent(current, workInProgress) {
  const { type } = workInProgress;
  const nextProps = workInProgress.pendingProps;
  let nextChildren = nextProps.children;
  const isDirectTextChild = shouldSetTextContent(type, nextProps);
  if (isDirectTextChild) {
    nextChildren = null;
  }
  reconcileChildren(current, workInProgress, nextChildren);
  return workInProgress.child;
}
function mountIndeterminateComponent(_current, workInProgress, Component) {
  const props = workInProgress.pendingProps;
  const value = renderWithHooks(null, workInProgress, Component, props);
  workInProgress.tag = FunctionComponent;
  reconcileChildren(null, workInProgress, value);
  return workInProgress.child;
}
<span class="hljs-addition">+function updateFunctionComponent(current, workInProgress, Component, nextProps) {</span>
<span class="hljs-addition">+  const nextChildren = renderWithHooks(current, workInProgress, Component, nextProps);</span>
<span class="hljs-addition">+  reconcileChildren(current, workInProgress, nextChildren);</span>
<span class="hljs-addition">+  return workInProgress.child;</span>
<span class="hljs-addition">+}</span>
export function beginWork(current, workInProgress) {
  //logger(&quot; &quot;.repeat(indent.number) + &quot;beginWork&quot;, workInProgress);
  indent.number += 2;
  switch (workInProgress.tag) {
    case IndeterminateComponent: {
      return mountIndeterminateComponent(current, workInProgress, workInProgress.type);
    }
<span class="hljs-addition">+   case FunctionComponent: {</span>
<span class="hljs-addition">+     const Component = workInProgress.type;</span>
<span class="hljs-addition">+     const resolvedProps = workInProgress.pendingProps;</span>
<span class="hljs-addition">+     return updateFunctionComponent(current, workInProgress, Component, resolvedProps);</span>
<span class="hljs-addition">+   }</span>
    case HostRoot:
      return updateHostRoot(current, workInProgress);
    case HostComponent:
      return updateHostComponent(current, workInProgress);
    case HostText:
    default:
      return null;
  }
}
</code></pre>
<h3 id="t18421.5 ReactChildFiber.js">21.5 ReactChildFiber.js <a href="#t18421.5 ReactChildFiber.js"> # </a></h3>
<p>src\react-reconciler\src\ReactChildFiber.js</p>
<pre><code class="lang-diff">import { REACT_ELEMENT_TYPE } from &quot;shared/ReactSymbols&quot;;
import isArray from &quot;shared/isArray&quot;;
import { createFiberFromElement, FiberNode, createFiberFromText, createWorkInProgress } from &quot;./ReactFiber&quot;;
import { Placement } from &quot;./ReactFiberFlags&quot;;
import { HostText } from &quot;./ReactWorkTags&quot;;
function createChildReconciler(shouldTrackSideEffects) {
<span class="hljs-addition">+ function useFiber(fiber, pendingProps) {</span>
<span class="hljs-addition">+   const clone = createWorkInProgress(fiber, pendingProps);</span>
<span class="hljs-addition">+   clone.index = 0;</span>
<span class="hljs-addition">+   clone.sibling = null;</span>
<span class="hljs-addition">+   return clone;</span>
<span class="hljs-addition">+ }</span>
  function reconcileSingleElement(returnFiber, currentFirstChild, element) {
<span class="hljs-addition">+   const key = element.key;</span>
<span class="hljs-addition">+   let child = currentFirstChild;</span>
<span class="hljs-addition">+   while (child !== null) {</span>
<span class="hljs-addition">+     if (child.key === key) {</span>
<span class="hljs-addition">+       const elementType = element.type;</span>
<span class="hljs-addition">+       if (child.type === elementType) {</span>
<span class="hljs-addition">+         const existing = useFiber(child, element.props);</span>
<span class="hljs-addition">+         existing.return = returnFiber;</span>
<span class="hljs-addition">+         return existing;</span>
<span class="hljs-addition">+       }</span>
<span class="hljs-addition">+     }</span>
<span class="hljs-addition">+     child = child.sibling;</span>
<span class="hljs-addition">+   }</span>
    const created = createFiberFromElement(element);
    created.return = returnFiber;
    return created;
  }
  function placeSingleChild(newFiber) {
<span class="hljs-addition">+   if (shouldTrackSideEffects &amp;&amp; newFiber.alternate === null) {</span>
      newFiber.flags |= Placement;
    }
    return newFiber;
  }
  function reconcileSingleTextNode(returnFiber, currentFirstChild, content) {
    const created = new FiberNode(HostText, { content }, null);
    created.return = returnFiber;
    return created;
  }
  function createChild(returnFiber, newChild) {
    if ((typeof newChild <span class="hljs-comment">=== &quot;string&quot; &amp;&amp; newChild !== &quot;&quot;) || typeof newChild === &quot;number&quot;) {</span>
      const created = createFiberFromText(`${newChild}`);
      created.return = returnFiber;
      return created;
    }

    if (typeof newChild <span class="hljs-comment">=== &quot;object&quot; &amp;&amp; newChild !== null) {</span>
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE: {
          const created = createFiberFromElement(newChild);
          created.return = returnFiber;
          return created;
        }
        default:
          break;
      }
    }
    return null;
  }
  function placeChild(newFiber, newIndex) {
    newFiber.index = newIndex;
    if (shouldTrackSideEffects) newFiber.flags |= Placement;
  }
  function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren) {
    let resultingFirstChild = null;
    let previousNewFiber = null;
    let newIdx = 0;
    for (; newIdx &lt; newChildren.length; newIdx++) {
      const newFiber = createChild(returnFiber, newChildren[newIdx]);
      if (newFiber <span class="hljs-comment">=== null) {</span>
        continue;
      }
      placeChild(newFiber, newIdx);
      if (previousNewFiber <span class="hljs-comment">=== null) {</span>
        resultingFirstChild = newFiber;
      } else {
        previousNewFiber.sibling = newFiber;
      }
      previousNewFiber = newFiber;
    }
    return resultingFirstChild;
  }
  function reconcileChildFibers(returnFiber, currentFirstChild, newChild) {
    if (typeof newChild <span class="hljs-comment">=== &quot;object&quot; &amp;&amp; newChild !== null) {</span>
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE: {
          return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild));
        }
        default:
          break;
      }
      if (isArray(newChild)) {
        return reconcileChildrenArray(returnFiber, currentFirstChild, newChild);
      }
    }
    if (typeof newChild <span class="hljs-comment">=== &quot;string&quot;) {</span>
      return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, newChild));
    }
    return null;
  }
  return reconcileChildFibers;
}
export const reconcileChildFibers = createChildReconciler(true);
export const mountChildFibers = createChildReconciler(false);

</code></pre>
<h3 id="t18521.6 ReactFiberCompleteWork.js">21.6 ReactFiberCompleteWork.js <a href="#t18521.6 ReactFiberCompleteWork.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberCompleteWork.js</p>
<pre><code class="lang-diff">import {
  appendInitialChild,
  createInstance,
  createTextInstance,
  finalizeInitialChildren,
<span class="hljs-addition">+ prepareUpdate,</span>
} from &quot;react-dom-bindings/src/client/ReactDOMHostConfig&quot;;
import { HostComponent, HostRoot, HostText } from &quot;./ReactWorkTags&quot;;
<span class="hljs-addition">+import { NoFlags, Update } from &quot;./ReactFiberFlags&quot;;</span>
import logger, { indent } from &quot;shared/logger&quot;;
function bubbleProperties(completedWork) {
  let subtreeFlags = NoFlags;
  let child = completedWork.child;
  while (child !== null) {
    subtreeFlags |= child.subtreeFlags;
    subtreeFlags |= child.flags;
    child = child.sibling;
  }
  completedWork.subtreeFlags |= subtreeFlags;
}

function appendAllChildren(parent, workInProgress) {
  // &#x6211;&#x4EEC;&#x53EA;&#x6709;&#x521B;&#x5EFA;&#x7684;&#x9876;&#x7EA7;fiber&#xFF0C;&#x4F46;&#x9700;&#x8981;&#x9012;&#x5F52;&#x5176;&#x5B50;&#x8282;&#x70B9;&#x6765;&#x67E5;&#x627E;&#x6240;&#x6709;&#x7EC8;&#x7AEF;&#x8282;&#x70B9;
  let node = workInProgress.child;
  while (node !== null) {
    // &#x5982;&#x679C;&#x662F;&#x539F;&#x751F;&#x8282;&#x70B9;&#xFF0C;&#x76F4;&#x63A5;&#x6DFB;&#x52A0;&#x5230;&#x7236;&#x8282;&#x70B9;&#x4E0A;
    if (node.tag <span class="hljs-comment">=== HostComponent || node.tag === HostText) {</span>
      appendInitialChild(parent, node.stateNode);
      // &#x518D;&#x770B;&#x770B;&#x7B2C;&#x4E00;&#x4E2A;&#x8282;&#x8282;&#x70B9;&#x662F;&#x4E0D;&#x662F;&#x539F;&#x751F;&#x8282;&#x70B9;
    } else if (node.child !== null) {
      // node.child.return = node
      node = node.child;
      continue;
    }
    if (node <span class="hljs-comment">=== workInProgress) {</span>
      return;
    }
    // &#x5982;&#x679C;&#x6CA1;&#x6709;&#x5F1F;&#x5F1F;&#x5C31;&#x627E;&#x7236;&#x4EB2;&#x7684;&#x5F1F;&#x5F1F;
    while (node.sibling <span class="hljs-comment">=== null) {</span>
      // &#x5982;&#x679C;&#x627E;&#x5230;&#x4E86;&#x6839;&#x8282;&#x70B9;&#x6216;&#x8005;&#x56DE;&#x5230;&#x4E86;&#x539F;&#x8282;&#x70B9;&#x7ED3;&#x675F;
      if (node.return <span class="hljs-comment">=== null || node.return === workInProgress) {</span>
        return;
      }
      node = node.return;
    }
    // node.sibling.return = node.return
    // &#x4E0B;&#x4E00;&#x4E2A;&#x5F1F;&#x5F1F;&#x8282;&#x70B9;
    node = node.sibling;
  }
}
<span class="hljs-addition">+function markUpdate(workInProgress) {</span>
<span class="hljs-addition">+  workInProgress.flags |= Update;</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+function updateHostComponent(current, workInProgress, type, newProps) {</span>
<span class="hljs-addition">+  const oldProps = current.memoizedProps;</span>
<span class="hljs-addition">+  const instance = workInProgress.stateNode;</span>
<span class="hljs-addition">+  const updatePayload = prepareUpdate(instance, type, oldProps, newProps);</span>
<span class="hljs-addition">+  workInProgress.updateQueue = updatePayload;</span>
<span class="hljs-addition">+  if (updatePayload) {</span>
<span class="hljs-addition">+    markUpdate(workInProgress);</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+}</span>
export function completeWork(current, workInProgress) {
  indent.number -= 2;
  //logger(&quot; &quot;.repeat(indent.number) + &quot;completeWork&quot;, workInProgress);
  const newProps = workInProgress.pendingProps;
  switch (workInProgress.tag) {
    case HostComponent: {
      const { type } = workInProgress;
<span class="hljs-addition">+     if (current !== null &amp;&amp; workInProgress.stateNode != null) {</span>
<span class="hljs-addition">+       updateHostComponent(current, workInProgress, type, newProps);</span>
<span class="hljs-addition">+       console.log(&quot;updatePayload&quot;, workInProgress.updateQueue);</span>
<span class="hljs-addition">+     } else {</span>
        const instance = createInstance(type, newProps, workInProgress);
        appendAllChildren(instance, workInProgress);
        workInProgress.stateNode = instance;
        finalizeInitialChildren(instance, type, newProps);
<span class="hljs-addition">+     }</span>
<span class="hljs-addition">+     bubbleProperties(workInProgress);</span>
      break;
    }
    case HostRoot:
      bubbleProperties(workInProgress);
      break;
    case HostText: {
      const newText = newProps;
      workInProgress.stateNode = createTextInstance(newText);
      bubbleProperties(workInProgress);
      break;
    }
    default:
      break;
  }
}

</code></pre>
<h3 id="t18621.7 ReactFiberFlags.js">21.7 ReactFiberFlags.js <a href="#t18621.7 ReactFiberFlags.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberFlags.js</p>
<pre><code class="lang-diff">export const NoFlags = 0b00000000000000000000000000;
export const Placement = 0b00000000000000000000000010;
<span class="hljs-addition">+export const Update = 0b00000000000000000000000100;</span>
<span class="hljs-addition">+export const MutationMask = Placement | Update;</span>
</code></pre>
<h3 id="t18721.8 ReactDOMHostConfig.js">21.8 ReactDOMHostConfig.js <a href="#t18721.8 ReactDOMHostConfig.js"> # </a></h3>
<p>src\react-dom-bindings\src\client\ReactDOMHostConfig.js</p>
<pre><code class="lang-diff"><span class="hljs-addition">+import { setInitialProperties, diffProperties } from &quot;./ReactDOMComponent&quot;;</span>
import { precacheFiberNode, updateFiberProps } from &quot;./ReactDOMComponentTree&quot;;

export function shouldSetTextContent(type, props) {
  return typeof props.children <span class="hljs-comment">=== &quot;string&quot; || typeof props.children === &quot;number&quot;;</span>
}
export const appendInitialChild = (parent, child) =&gt; {
  parent.appendChild(child);
};
export const createInstance = (type, props, internalInstanceHandle) =&gt; {
  const domElement = document.createElement(type);
  precacheFiberNode(internalInstanceHandle, domElement);
  updateFiberProps(domElement, props);
  return domElement;
};
export const createTextInstance = (content) =&gt; document.createTextNode(content);
export function finalizeInitialChildren(domElement, type, props) {
  setInitialProperties(domElement, type, props);
}
export function appendChild(parentInstance, child) {
  parentInstance.appendChild(child);
}
export function insertBefore(parentInstance, child, beforeChild) {
  parentInstance.insertBefore(child, beforeChild);
}

<span class="hljs-addition">+export function prepareUpdate(domElement, type, oldProps, newProps) {</span>
<span class="hljs-addition">+  return diffProperties(domElement, type, oldProps, newProps);</span>
<span class="hljs-addition">+}</span>
</code></pre>
<h3 id="t18821.9 ReactDOMComponent.js">21.9 ReactDOMComponent.js <a href="#t18821.9 ReactDOMComponent.js"> # </a></h3>
<p>src\react-dom-bindings\src\client\ReactDOMComponent.js</p>
<pre><code class="lang-diff">import { setValueForStyles } from &quot;./CSSPropertyOperations&quot;;
import setTextContent from &quot;./setTextContent&quot;;
import { setValueForProperty } from &quot;./DOMPropertyOperations&quot;;
const CHILDREN = &quot;children&quot;;
const STYLE = &quot;style&quot;;
function setInitialDOMProperties(tag, domElement, nextProps) {
  for (const propKey in nextProps) {
    if (nextProps.hasOwnProperty(propKey)) {
      const nextProp = nextProps[propKey];
      if (propKey <span class="hljs-comment">=== STYLE) {</span>
        setValueForStyles(domElement, nextProp);
      } else if (propKey <span class="hljs-comment">=== CHILDREN) {</span>
        if (typeof nextProp <span class="hljs-comment">=== &quot;string&quot;) {</span>
          setTextContent(domElement, nextProp);
        } else if (typeof nextProp <span class="hljs-comment">=== &quot;number&quot;) {</span>
          setTextContent(domElement, `${nextProp}`);
        }
      } else if (nextProp != null) {
        setValueForProperty(domElement, propKey, nextProp);
      }
    }
  }
}
export function setInitialProperties(domElement, tag, props) {
  setInitialDOMProperties(tag, domElement, props);
}

<span class="hljs-addition">+export function diffProperties(domElement, tag, lastProps, nextProps) {</span>
<span class="hljs-addition">+  let updatePayload = null;</span>
<span class="hljs-addition">+  let propKey;</span>
<span class="hljs-addition">+  let styleName;</span>
<span class="hljs-addition">+  let styleUpdates = null;</span>
<span class="hljs-addition">+  for (propKey in lastProps) {</span>
<span class="hljs-addition">+    if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey) || lastProps[propKey] == null) {</span>
<span class="hljs-addition">+      continue;</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+    if (propKey === STYLE) {</span>
<span class="hljs-addition">+      const lastStyle = lastProps[propKey];</span>
<span class="hljs-addition">+      for (styleName in lastStyle) {</span>
<span class="hljs-addition">+        if (lastStyle.hasOwnProperty(styleName)) {</span>
<span class="hljs-addition">+          if (!styleUpdates) {</span>
<span class="hljs-addition">+            styleUpdates = {};</span>
<span class="hljs-addition">+          }</span>
<span class="hljs-addition">+          styleUpdates[styleName] = &quot;&quot;;</span>
<span class="hljs-addition">+        }</span>
<span class="hljs-addition">+      }</span>
<span class="hljs-addition">+    } else {</span>
<span class="hljs-addition">+      (updatePayload = updatePayload || []).push(propKey, null);</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+  for (propKey in nextProps) {</span>
<span class="hljs-addition">+    const nextProp = nextProps[propKey];</span>
<span class="hljs-addition">+    const lastProp = lastProps != null ? lastProps[propKey] : undefined;</span>
<span class="hljs-addition">+    if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp || (nextProp == null &amp;&amp; lastProp == null)) {</span>
<span class="hljs-addition">+      continue;</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+    if (propKey === STYLE) {</span>
<span class="hljs-addition">+      if (lastProp) {</span>
<span class="hljs-addition">+        for (styleName in lastProp) {</span>
<span class="hljs-addition">+          if (lastProp.hasOwnProperty(styleName) &amp;&amp; (!nextProp || !nextProp.hasOwnProperty(styleName))) {</span>
<span class="hljs-addition">+            if (!styleUpdates) {</span>
<span class="hljs-addition">+              styleUpdates = {};</span>
<span class="hljs-addition">+            }</span>
<span class="hljs-addition">+            styleUpdates[styleName] = &quot;&quot;;</span>
<span class="hljs-addition">+          }</span>
<span class="hljs-addition">+        }</span>
<span class="hljs-addition">+        for (styleName in nextProp) {</span>
<span class="hljs-addition">+          if (nextProp.hasOwnProperty(styleName) &amp;&amp; lastProp[styleName] !== nextProp[styleName]) {</span>
<span class="hljs-addition">+            if (!styleUpdates) {</span>
<span class="hljs-addition">+              styleUpdates = {};</span>
<span class="hljs-addition">+            }</span>
<span class="hljs-addition">+            styleUpdates[styleName] = nextProp[styleName];</span>
<span class="hljs-addition">+          }</span>
<span class="hljs-addition">+        }</span>
<span class="hljs-addition">+      } else {</span>
<span class="hljs-addition">+        if (!styleUpdates) {</span>
<span class="hljs-addition">+          if (!updatePayload) {</span>
<span class="hljs-addition">+            updatePayload = [];</span>
<span class="hljs-addition">+          }</span>
<span class="hljs-addition">+          updatePayload.push(propKey, styleUpdates);</span>
<span class="hljs-addition">+        }</span>
<span class="hljs-addition">+        styleUpdates = nextProp;</span>
<span class="hljs-addition">+      }</span>
<span class="hljs-addition">+    } else if (propKey === CHILDREN) {</span>
<span class="hljs-addition">+      if (typeof nextProp === &quot;string&quot; || typeof nextProp === &quot;number&quot;) {</span>
<span class="hljs-addition">+        (updatePayload = updatePayload || []).push(propKey, &quot;&quot; + nextProp);</span>
<span class="hljs-addition">+      }</span>
<span class="hljs-addition">+    } else {</span>
<span class="hljs-addition">+      (updatePayload = updatePayload || []).push(propKey, nextProp);</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+  if (styleUpdates) {</span>
<span class="hljs-addition">+    (updatePayload = updatePayload || []).push(STYLE, styleUpdates);</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+  return updatePayload;</span>
<span class="hljs-addition">+}</span>
</code></pre>
<h2 id="t18922.commitUpdate">22.commitUpdate <a href="#t18922.commitUpdate"> # </a></h2>
<h3 id="t19022.1 DOMPluginEventSystem.js">22.1 DOMPluginEventSystem.js <a href="#t19022.1 DOMPluginEventSystem.js"> # </a></h3>
<p>src\react-dom-bindings\src\events\DOMPluginEventSystem.js</p>
<pre><code class="lang-diff">import { allNativeEvents } from &quot;./EventRegistry&quot;;
import * as SimpleEventPlugin from &quot;./plugins/SimpleEventPlugin&quot;;
import { createEventListenerWrapperWithPriority } from &quot;./ReactDOMEventListener&quot;;
import { IS_CAPTURE_PHASE } from &quot;./EventSystemFlags&quot;;
import { addEventCaptureListener, addEventBubbleListener } from &quot;./EventListener&quot;;
import getEventTarget from &quot;./getEventTarget&quot;;
import getListener from &quot;./getListener&quot;;
import { HostComponent } from &quot;react-reconciler/src/ReactWorkTags&quot;;

SimpleEventPlugin.registerEvents();
<span class="hljs-addition">+const listeningMarker = &quot;_reactListening&quot; + Math.random().toString(36).slice(2);</span>
export function listenToAllSupportedEvents(rootContainerElement) {
<span class="hljs-addition">+ if (!rootContainerElement[listeningMarker]) {</span>
<span class="hljs-addition">+   rootContainerElement[listeningMarker] = true;</span>
    allNativeEvents.forEach((domEventName) =&gt; {
      listenToNativeEvent(domEventName, true, rootContainerElement);
      listenToNativeEvent(domEventName, false, rootContainerElement);
    });
<span class="hljs-addition">+ }</span>
}

export function listenToNativeEvent(domEventName, isCapturePhaseListener, target) {
  let eventSystemFlags = 0; // &#x5192;&#x6CE1; = 0 &#x6355;&#x83B7; = 4
  if (isCapturePhaseListener) {
    eventSystemFlags |= IS_CAPTURE_PHASE;
  }
  addTrappedEventListener(target, domEventName, eventSystemFlags, isCapturePhaseListener);
}
function addTrappedEventListener(targetContainer, domEventName, eventSystemFlags, isCapturePhaseListener) {
  const listener = createEventListenerWrapperWithPriority(targetContainer, domEventName, eventSystemFlags);
  if (isCapturePhaseListener) {
    addEventCaptureListener(targetContainer, domEventName, listener);
  } else {
    addEventBubbleListener(targetContainer, domEventName, listener);
  }
}
export function dispatchEventForPluginEventSystem(
  domEventName,
  eventSystemFlags,
  nativeEvent,
  targetInst,
  targetContainer
) {
  dispatchEventsForPlugins(domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer);
}

function dispatchEventsForPlugins(domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer) {
  const nativeEventTarget = getEventTarget(nativeEvent);
  const dispatchQueue = [];
  extractEvents(
    dispatchQueue,
    domEventName,
    targetInst,
    nativeEvent,
    nativeEventTarget,
    eventSystemFlags,
    targetContainer
  );
  processDispatchQueue(dispatchQueue, eventSystemFlags);
}

export function processDispatchQueue(dispatchQueue, eventSystemFlags) {
  const inCapturePhase = (eventSystemFlags &amp; IS_CAPTURE_PHASE) !== 0;
  for (let i = 0; i &lt; dispatchQueue.length; i++) {
    const { event, listeners } = dispatchQueue[i];
    processDispatchQueueItemsInOrder(event, listeners, inCapturePhase); //  event system doesn&apos;t use pooling.
  }
}
function processDispatchQueueItemsInOrder(event, dispatchListeners, inCapturePhase) {
  if (inCapturePhase) {
    for (let i = dispatchListeners.length - 1; i &gt;= 0; i--) {
      const { currentTarget, listener } = dispatchListeners[i];
      if (event.isPropagationStopped()) {
        return;
      }
      executeDispatch(event, listener, currentTarget);
    }
  } else {
    for (let i = 0; i &lt; dispatchListeners.length; i++) {
      const { currentTarget, listener } = dispatchListeners[i];
      if (event.isPropagationStopped()) {
        return;
      }
      executeDispatch(event, listener, currentTarget);
    }
  }
}
function executeDispatch(event, listener, currentTarget) {
  event.currentTarget = currentTarget;
  listener(event);
  event.currentTarget = null;
}
function extractEvents(
  dispatchQueue,
  domEventName,
  targetInst,
  nativeEvent,
  nativeEventTarget,
  eventSystemFlags,
  targetContainer
) {
  SimpleEventPlugin.extractEvents(
    dispatchQueue,
    domEventName,
    targetInst,
    nativeEvent,
    nativeEventTarget,
    eventSystemFlags,
    targetContainer
  );
}

export function accumulateSinglePhaseListeners(targetFiber, reactName, nativeEventType, inCapturePhase) {
  const captureName = reactName + &quot;Capture&quot;;
  const reactEventName = inCapturePhase ? captureName : reactName;
  const listeners = [];
  let instance = targetFiber;
  while (instance !== null) {
    const { stateNode, tag } = instance;
    if (tag <span class="hljs-comment">=== HostComponent &amp;&amp; stateNode !== null) {</span>
      if (reactEventName !== null) {
        const listener = getListener(instance, reactEventName);
        if (listener !== null &amp;&amp; listener !== undefined) {
          listeners.push(createDispatchListener(instance, listener, stateNode));
        }
      }
    }
    instance = instance.return;
  }

  return listeners;
}
function createDispatchListener(instance, listener, currentTarget) {
  return {
    instance,
    listener,
    currentTarget,
  };
}

</code></pre>
<h3 id="t19122.2 ReactFiberCompleteWork.js">22.2 ReactFiberCompleteWork.js <a href="#t19122.2 ReactFiberCompleteWork.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberCompleteWork.js</p>
<pre><code class="lang-diff">import {
  appendInitialChild,
  createInstance,
  createTextInstance,
  finalizeInitialChildren,
  prepareUpdate,
} from &quot;react-dom-bindings/src/client/ReactDOMHostConfig&quot;;
<span class="hljs-addition">+import { HostComponent, HostRoot, HostText, FunctionComponent } from &quot;./ReactWorkTags&quot;;</span>
import { NoFlags, Update } from &quot;./ReactFiberFlags&quot;;
import logger, { indent } from &quot;shared/logger&quot;;
function bubbleProperties(completedWork) {
  let subtreeFlags = NoFlags;
  let child = completedWork.child;
  while (child !== null) {
    subtreeFlags |= child.subtreeFlags;
    subtreeFlags |= child.flags;
    child = child.sibling;
  }
  completedWork.subtreeFlags |= subtreeFlags;
}

function appendAllChildren(parent, workInProgress) {
  // &#x6211;&#x4EEC;&#x53EA;&#x6709;&#x521B;&#x5EFA;&#x7684;&#x9876;&#x7EA7;fiber&#xFF0C;&#x4F46;&#x9700;&#x8981;&#x9012;&#x5F52;&#x5176;&#x5B50;&#x8282;&#x70B9;&#x6765;&#x67E5;&#x627E;&#x6240;&#x6709;&#x7EC8;&#x7AEF;&#x8282;&#x70B9;
  let node = workInProgress.child;
  while (node !== null) {
    // &#x5982;&#x679C;&#x662F;&#x539F;&#x751F;&#x8282;&#x70B9;&#xFF0C;&#x76F4;&#x63A5;&#x6DFB;&#x52A0;&#x5230;&#x7236;&#x8282;&#x70B9;&#x4E0A;
    if (node.tag <span class="hljs-comment">=== HostComponent || node.tag === HostText) {</span>
      appendInitialChild(parent, node.stateNode);
      // &#x518D;&#x770B;&#x770B;&#x7B2C;&#x4E00;&#x4E2A;&#x8282;&#x8282;&#x70B9;&#x662F;&#x4E0D;&#x662F;&#x539F;&#x751F;&#x8282;&#x70B9;
    } else if (node.child !== null) {
      // node.child.return = node
      node = node.child;
      continue;
    }
    if (node <span class="hljs-comment">=== workInProgress) {</span>
      return;
    }
    // &#x5982;&#x679C;&#x6CA1;&#x6709;&#x5F1F;&#x5F1F;&#x5C31;&#x627E;&#x7236;&#x4EB2;&#x7684;&#x5F1F;&#x5F1F;
    while (node.sibling <span class="hljs-comment">=== null) {</span>
      // &#x5982;&#x679C;&#x627E;&#x5230;&#x4E86;&#x6839;&#x8282;&#x70B9;&#x6216;&#x8005;&#x56DE;&#x5230;&#x4E86;&#x539F;&#x8282;&#x70B9;&#x7ED3;&#x675F;
      if (node.return <span class="hljs-comment">=== null || node.return === workInProgress) {</span>
        return;
      }
      node = node.return;
    }
    // node.sibling.return = node.return
    // &#x4E0B;&#x4E00;&#x4E2A;&#x5F1F;&#x5F1F;&#x8282;&#x70B9;
    node = node.sibling;
  }
}
function markUpdate(workInProgress) {
  workInProgress.flags |= Update;
}
function updateHostComponent(current, workInProgress, type, newProps) {
  const oldProps = current.memoizedProps;
  const instance = workInProgress.stateNode;
  const updatePayload = prepareUpdate(instance, type, oldProps, newProps);
  workInProgress.updateQueue = updatePayload;
  if (updatePayload) {
    markUpdate(workInProgress);
  }
}
export function completeWork(current, workInProgress) {
  indent.number -= 2;
  //logger(&quot; &quot;.repeat(indent.number) + &quot;completeWork&quot;, workInProgress);
  const newProps = workInProgress.pendingProps;
  switch (workInProgress.tag) {
    case HostComponent: {
      const { type } = workInProgress;
      if (current !== null &amp;&amp; workInProgress.stateNode != null) {
        updateHostComponent(current, workInProgress, type, newProps);
      } else {
        const instance = createInstance(type, newProps, workInProgress);
        appendAllChildren(instance, workInProgress);
        workInProgress.stateNode = instance;
        finalizeInitialChildren(instance, type, newProps);
      }
      bubbleProperties(workInProgress);
      break;
    }
<span class="hljs-addition">+   case FunctionComponent:</span>
<span class="hljs-addition">+     bubbleProperties(workInProgress);</span>
<span class="hljs-addition">+     break;</span>
    case HostRoot:
      bubbleProperties(workInProgress);
      break;
    case HostText: {
      const newText = newProps;
      workInProgress.stateNode = createTextInstance(newText);
      bubbleProperties(workInProgress);
      break;
    }
    default:
      break;
  }
}
</code></pre>
<h3 id="t19222.3 ReactFiberCommitWork.js">22.3 ReactFiberCommitWork.js <a href="#t19222.3 ReactFiberCommitWork.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberCommitWork.js</p>
<pre><code class="lang-diff"><span class="hljs-addition">+import { HostRoot, HostComponent, HostText, FunctionComponent } from &quot;./ReactWorkTags&quot;;</span>
<span class="hljs-addition">+import { MutationMask, Placement, Update } from &quot;./ReactFiberFlags&quot;;</span>
<span class="hljs-addition">+import { insertBefore, appendChild, commitUpdate } from &quot;react-dom-bindings/src/client/ReactDOMHostConfig&quot;;</span>
function recursivelyTraverseMutationEffects(root, parentFiber) {
  if (parentFiber.subtreeFlags &amp; MutationMask) {
    let { child } = parentFiber;
    while (child !== null) {
      commitMutationEffectsOnFiber(child, root);
      child = child.sibling;
    }
  }
}
function isHostParent(fiber) {
  return fiber.tag <span class="hljs-comment">=== HostComponent || fiber.tag === HostRoot;</span>
}
function getHostParentFiber(fiber) {
  let parent = fiber.return;
  while (parent !== null) {
    if (isHostParent(parent)) {
      return parent;
    }
    parent = parent.return;
  }
  return parent;
}
function insertOrAppendPlacementNode(node, before, parent) {
  const { tag } = node;
  const isHost = tag <span class="hljs-comment">=== HostComponent || tag === HostText;</span>
  if (isHost) {
    const { stateNode } = node;
    if (before) {
      insertBefore(parent, stateNode, before);
    } else {
      appendChild(parent, stateNode);
    }
  } else {
    const { child } = node;
    if (child !== null) {
      insertOrAppendPlacementNode(child, before, parent);
      let { sibling } = child;
      while (sibling !== null) {
        insertOrAppendPlacementNode(sibling, before, parent);
        sibling = sibling.sibling;
      }
    }
  }
}
function getHostSibling(fiber) {
  let node = fiber;
  siblings: while (true) {
    // &#x5982;&#x679C;&#x6211;&#x4EEC;&#x6CA1;&#x6709;&#x627E;&#x5230;&#x4EFB;&#x4F55;&#x4E1C;&#x897F;&#xFF0C;&#x8BA9;&#x6211;&#x4EEC;&#x8BD5;&#x8BD5;&#x4E0B;&#x4E00;&#x4E2A;&#x5F1F;&#x5F1F;
    while (node.sibling <span class="hljs-comment">=== null) {</span>
      if (node.return <span class="hljs-comment">=== null || isHostParent(node.return)) {</span>
        // &#x5982;&#x679C;&#x6211;&#x4EEC;&#x662F;&#x6839;Fiber&#x6216;&#x8005;&#x7236;&#x4EB2;&#x662F;&#x539F;&#x751F;&#x8282;&#x70B9;&#xFF0C;&#x6211;&#x4EEC;&#x5C31;&#x662F;&#x6700;&#x540E;&#x7684;&#x5F1F;&#x5F1F;
        return null;
      }
      node = node.return;
    }
    // node.sibling.return = node.return
    node = node.sibling;
    while (node.tag !== HostComponent &amp;&amp; node.tag !== HostText) {
      // &#x5982;&#x679C;&#x5B83;&#x4E0D;&#x662F;&#x539F;&#x751F;&#x8282;&#x70B9;&#xFF0C;&#x5E76;&#x4E14;&#xFF0C;&#x6211;&#x4EEC;&#x53EF;&#x80FD;&#x5728;&#x5176;&#x4E2D;&#x6709;&#x4E00;&#x4E2A;&#x539F;&#x751F;&#x8282;&#x70B9;
      // &#x8BD5;&#x7740;&#x5411;&#x4E0B;&#x641C;&#x7D22;&#xFF0C;&#x76F4;&#x5230;&#x627E;&#x5230;&#x4E3A;&#x6B62;
      if (node.flags &amp; Placement) {
        // &#x5982;&#x679C;&#x6211;&#x4EEC;&#x6CA1;&#x6709;&#x5B69;&#x5B50;&#xFF0C;&#x53EF;&#x4EE5;&#x8BD5;&#x8BD5;&#x5F1F;&#x5F1F;
        continue siblings;
      } else {
        // node.child.return = node
        node = node.child;
      }
    } // Check if this host node is stable or about to be placed.
    // &#x68C0;&#x67E5;&#x6B64;&#x539F;&#x751F;&#x8282;&#x70B9;&#x662F;&#x5426;&#x7A33;&#x5B9A;&#x53EF;&#x4EE5;&#x653E;&#x7F6E;
    if (!(node.flags &amp; Placement)) {
      // &#x627E;&#x5230;&#x5B83;&#x4E86;!
      return node.stateNode;
    }
  }
}
function commitPlacement(finishedWork) {
  const parentFiber = getHostParentFiber(finishedWork);
  switch (parentFiber.tag) {
    case HostComponent: {
      const parent = parentFiber.stateNode;
      const before = getHostSibling(finishedWork);
      insertOrAppendPlacementNode(finishedWork, before, parent);
      break;
    }
    case HostRoot: {
      const parent = parentFiber.stateNode.containerInfo;
      const before = getHostSibling(finishedWork);
      insertOrAppendPlacementNode(finishedWork, before, parent);
      break;
    }
    default:
      break;
  }
}
function commitReconciliationEffects(finishedWork) {
  const { flags } = finishedWork;
  if (flags &amp; Placement) {
    commitPlacement(finishedWork);
    finishedWork.flags &amp;= ~Placement;
  }
}
export function commitMutationEffectsOnFiber(finishedWork, root) {
<span class="hljs-addition">+ const current = finishedWork.alternate;</span>
<span class="hljs-addition">+ const flags = finishedWork.flags;</span>
  switch (finishedWork.tag) {
<span class="hljs-addition">+    case HostRoot: {</span>
<span class="hljs-addition">+      recursivelyTraverseMutationEffects(root, finishedWork);</span>
<span class="hljs-addition">+      commitReconciliationEffects(finishedWork);</span>
<span class="hljs-addition">+      break;</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+    case FunctionComponent: {</span>
<span class="hljs-addition">+      recursivelyTraverseMutationEffects(root, finishedWork);</span>
<span class="hljs-addition">+      commitReconciliationEffects(finishedWork);</span>
<span class="hljs-addition">+      break;</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+    case HostComponent: {</span>
<span class="hljs-addition">+      recursivelyTraverseMutationEffects(root, finishedWork);</span>
<span class="hljs-addition">+      commitReconciliationEffects(finishedWork);</span>
<span class="hljs-addition">+      if (flags &amp; Update) {</span>
<span class="hljs-addition">+        const instance = finishedWork.stateNode;</span>
<span class="hljs-addition">+        if (instance != null) {</span>
<span class="hljs-addition">+          const newProps = finishedWork.memoizedProps;</span>
<span class="hljs-addition">+          const oldProps = current !== null ? current.memoizedProps : newProps;</span>
<span class="hljs-addition">+          const type = finishedWork.type;</span>
<span class="hljs-addition">+          const updatePayload = finishedWork.updateQueue;</span>
<span class="hljs-addition">+          finishedWork.updateQueue = null;</span>
<span class="hljs-addition">+          if (updatePayload !== null) {</span>
<span class="hljs-addition">+            commitUpdate(instance, updatePayload, type, oldProps, newProps, finishedWork);</span>
<span class="hljs-addition">+          }</span>
<span class="hljs-addition">+        }</span>
<span class="hljs-addition">+      }</span>
<span class="hljs-addition">+      break;</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+    case HostText: {</span>
<span class="hljs-addition">+      recursivelyTraverseMutationEffects(root, finishedWork);</span>
<span class="hljs-addition">+      commitReconciliationEffects(finishedWork);</span>
<span class="hljs-addition">+      break;</span>
<span class="hljs-addition">+    }</span>
    default: {
      break;
    }
  }
}

</code></pre>
<h3 id="t19322.4 ReactDOMHostConfig.js">22.4 ReactDOMHostConfig.js <a href="#t19322.4 ReactDOMHostConfig.js"> # </a></h3>
<p>src\react-dom-bindings\src\client\ReactDOMHostConfig.js</p>
<pre><code class="lang-diff"><span class="hljs-addition">+import { setInitialProperties, diffProperties, updateProperties } from &quot;./ReactDOMComponent&quot;;</span>
import { precacheFiberNode, updateFiberProps } from &quot;./ReactDOMComponentTree&quot;;

export function shouldSetTextContent(type, props) {
  return typeof props.children <span class="hljs-comment">=== &quot;string&quot; || typeof props.children === &quot;number&quot;;</span>
}
export const appendInitialChild = (parent, child) =&gt; {
  parent.appendChild(child);
};
export const createInstance = (type, props, internalInstanceHandle) =&gt; {
  const domElement = document.createElement(type);
  precacheFiberNode(internalInstanceHandle, domElement);
  updateFiberProps(domElement, props);
  return domElement;
};
export const createTextInstance = (content) =&gt; document.createTextNode(content);
export function finalizeInitialChildren(domElement, type, props) {
  setInitialProperties(domElement, type, props);
}
export function appendChild(parentInstance, child) {
  parentInstance.appendChild(child);
}
export function insertBefore(parentInstance, child, beforeChild) {
  parentInstance.insertBefore(child, beforeChild);
}

export function prepareUpdate(domElement, type, oldProps, newProps) {
  return diffProperties(domElement, type, oldProps, newProps);
}

<span class="hljs-addition">+export function commitUpdate(domElement, updatePayload, type, oldProps, newProps) {</span>
<span class="hljs-addition">+  updateProperties(domElement, updatePayload, type, oldProps, newProps);</span>
<span class="hljs-addition">+  updateFiberProps(domElement, newProps);</span>
<span class="hljs-addition">+}</span>
</code></pre>
<h3 id="t19422.5 ReactDOMComponent.js">22.5 ReactDOMComponent.js <a href="#t19422.5 ReactDOMComponent.js"> # </a></h3>
<p>src\react-dom-bindings\src\client\ReactDOMComponent.js</p>
<pre><code class="lang-diff">import { setValueForStyles } from &quot;./CSSPropertyOperations&quot;;
import setTextContent from &quot;./setTextContent&quot;;
import { setValueForProperty } from &quot;./DOMPropertyOperations&quot;;
const CHILDREN = &quot;children&quot;;
const STYLE = &quot;style&quot;;
function setInitialDOMProperties(tag, domElement, nextProps) {
  for (const propKey in nextProps) {
    if (nextProps.hasOwnProperty(propKey)) {
      const nextProp = nextProps[propKey];
      if (propKey <span class="hljs-comment">=== STYLE) {</span>
        setValueForStyles(domElement, nextProp);
      } else if (propKey <span class="hljs-comment">=== CHILDREN) {</span>
        if (typeof nextProp <span class="hljs-comment">=== &quot;string&quot;) {</span>
          setTextContent(domElement, nextProp);
        } else if (typeof nextProp <span class="hljs-comment">=== &quot;number&quot;) {</span>
          setTextContent(domElement, `${nextProp}`);
        }
      } else if (nextProp != null) {
        setValueForProperty(domElement, propKey, nextProp);
      }
    }
  }
}
export function setInitialProperties(domElement, tag, props) {
  setInitialDOMProperties(tag, domElement, props);
}

export function diffProperties(domElement, tag, lastProps, nextProps) {
  let updatePayload = null;
  let propKey;
  let styleName;
  let styleUpdates = null;
  for (propKey in lastProps) {
    if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey) || lastProps[propKey] == null) {
      continue;
    }
    if (propKey <span class="hljs-comment">=== STYLE) {</span>
      const lastStyle = lastProps[propKey];
      for (styleName in lastStyle) {
        if (lastStyle.hasOwnProperty(styleName)) {
          if (!styleUpdates) {
            styleUpdates = {};
          }
          styleUpdates[styleName] = &quot;&quot;;
        }
      }
    } else {
      (updatePayload = updatePayload || []).push(propKey, null);
    }
  }
  for (propKey in nextProps) {
    const nextProp = nextProps[propKey];
    const lastProp = lastProps != null ? lastProps[propKey] : undefined;
    if (!nextProps.hasOwnProperty(propKey) || nextProp <span class="hljs-comment">=== lastProp || (nextProp == null &amp;&amp; lastProp == null)) {</span>
      continue;
    }
    if (propKey <span class="hljs-comment">=== STYLE) {</span>
      if (lastProp) {
        for (styleName in lastProp) {
          if (lastProp.hasOwnProperty(styleName) &amp;&amp; (!nextProp || !nextProp.hasOwnProperty(styleName))) {
            if (!styleUpdates) {
              styleUpdates = {};
            }
            styleUpdates[styleName] = &quot;&quot;;
          }
        }
        for (styleName in nextProp) {
          if (nextProp.hasOwnProperty(styleName) &amp;&amp; lastProp[styleName] !== nextProp[styleName]) {
            if (!styleUpdates) {
              styleUpdates = {};
            }
            styleUpdates[styleName] = nextProp[styleName];
          }
        }
      } else {
        if (!styleUpdates) {
          if (!updatePayload) {
            updatePayload = [];
          }
          updatePayload.push(propKey, styleUpdates);
        }
        styleUpdates = nextProp;
      }
    } else if (propKey <span class="hljs-comment">=== CHILDREN) {</span>
      if (typeof nextProp <span class="hljs-comment">=== &quot;string&quot; || typeof nextProp === &quot;number&quot;) {</span>
        (updatePayload = updatePayload || []).push(propKey, &quot;&quot; + nextProp);
      }
    } else {
      (updatePayload = updatePayload || []).push(propKey, nextProp);
    }
  }
  if (styleUpdates) {
    (updatePayload = updatePayload || []).push(STYLE, styleUpdates);
  }
  return updatePayload;
}

<span class="hljs-addition">+export function updateProperties(domElement, updatePayload) {</span>
<span class="hljs-addition">+  updateDOMProperties(domElement, updatePayload);</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+</span>
<span class="hljs-addition">+function updateDOMProperties(domElement, updatePayload) {</span>
<span class="hljs-addition">+  for (let i = 0; i &lt; updatePayload.length; i += 2) {</span>
<span class="hljs-addition">+    const propKey = updatePayload[i];</span>
<span class="hljs-addition">+    const propValue = updatePayload[i + 1];</span>
<span class="hljs-addition">+    if (propKey === STYLE) {</span>
<span class="hljs-addition">+      setValueForStyles(domElement, propValue);</span>
<span class="hljs-addition">+    } else if (propKey === CHILDREN) {</span>
<span class="hljs-addition">+      setTextContent(domElement, propValue);</span>
<span class="hljs-addition">+    } else {</span>
<span class="hljs-addition">+      setValueForProperty(domElement, propKey, propValue);</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+}</span>
</code></pre>
<h2 id="t19523.useState">23.useState <a href="#t19523.useState"> # </a></h2>
<h3 id="t19623.1 src\main.jsx">23.1 src\main.jsx <a href="#t19623.1 src\main.jsx"> # </a></h3>
<p>src\main.jsx</p>
<pre><code class="lang-diff">import * as React from &quot;react&quot;;
import { createRoot } from &quot;react-dom/client&quot;;

function FunctionComponent() {
  console.log(&quot;FunctionComponent render&quot;);
<span class="hljs-addition">+ const [number, setNumber] = React.useState(0);</span>
<span class="hljs-addition">+ return &lt;button onClick={() =&gt; setNumber(number + 1)}&gt;{number}&lt;/button&gt;;</span>
}
let element = &lt;FunctionComponent /&gt;;
const root = createRoot(document.getElementById(&quot;root&quot;));
root.render(element);
</code></pre>
<h3 id="t19723.2 react\index.js">23.2 react\index.js <a href="#t19723.2 react\index.js"> # </a></h3>
<p>src\react\index.js</p>
<pre><code class="lang-diff"><span class="hljs-addition">+export { __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, useReducer, useState } from &quot;./src/React&quot;;</span>
</code></pre>
<h3 id="t19823.3 React.js">23.3 React.js <a href="#t19823.3 React.js"> # </a></h3>
<p>src\react\src\React.js</p>
<pre><code class="lang-diff"><span class="hljs-addition">+import { useReducer, useState } from &quot;./ReactHooks&quot;;</span>
import ReactSharedInternals from &quot;./ReactSharedInternals&quot;;

<span class="hljs-addition">+export { useReducer, useState, ReactSharedInternals as __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED };</span>

</code></pre>
<h3 id="t19923.4 ReactHooks.js">23.4 ReactHooks.js <a href="#t19923.4 ReactHooks.js"> # </a></h3>
<p>src\react\src\ReactHooks.js</p>
<pre><code class="lang-diff">import ReactCurrentDispatcher from &quot;./ReactCurrentDispatcher&quot;;

function resolveDispatcher() {
  const dispatcher = ReactCurrentDispatcher.current;
  return dispatcher;
}

export function useReducer(reducer, initialArg, init) {
  const dispatcher = resolveDispatcher();
  return dispatcher.useReducer(reducer, initialArg, init);
}

<span class="hljs-addition">+export function useState(initialState) {</span>
<span class="hljs-addition">+  const dispatcher = resolveDispatcher();</span>
<span class="hljs-addition">+  return dispatcher.useState(initialState);</span>
<span class="hljs-addition">+}</span>

</code></pre>
<h3 id="t20023.5 objectIs.js">23.5 objectIs.js <a href="#t20023.5 objectIs.js"> # </a></h3>
<p>src\shared\objectIs.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> objectIs = <span class="hljs-built_in">Object</span>.is;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> objectIs;
</code></pre>
<h3 id="t20123.6 ReactFiberHooks.js">23.6 ReactFiberHooks.js <a href="#t20123.6 ReactFiberHooks.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberHooks.js</p>
<pre><code class="lang-diff">import ReactSharedInternals from &quot;shared/ReactSharedInternals&quot;;
import { enqueueConcurrentHookUpdate } from &quot;./ReactFiberConcurrentUpdates&quot;;
import { scheduleUpdateOnFiber } from &quot;./ReactFiberWorkLoop&quot;;
<span class="hljs-addition">+import is from &quot;shared/objectIs&quot;;</span>

const { ReactCurrentDispatcher } = ReactSharedInternals;
let currentlyRenderingFiber = null;
let workInProgressHook = null;
let currentHook = null;

const HooksDispatcherOnMountInDEV = {
  useReducer: mountReducer,
<span class="hljs-addition">+ useState: mountState,</span>
};
const HooksDispatcherOnUpdateInDEV = {
  useReducer: updateReducer,
<span class="hljs-addition">+ useState: updateState,</span>
};
<span class="hljs-addition">+function basicStateReducer(state, action) {</span>
<span class="hljs-addition">+  return typeof action === &quot;function&quot; ? action(state) : action;</span>
<span class="hljs-addition">+}</span>
function mountReducer(reducer, initialArg) {
  const hook = mountWorkInProgressHook();
  hook.memoizedState = initialArg;
  const queue = {
    pending: null,
    dispatch: null,
  };
  hook.queue = queue;
  const dispatch = (queue.dispatch = dispatchReducerAction.bind(null, currentlyRenderingFiber, queue));
  return [hook.memoizedState, dispatch];
}
function updateReducer(reducer) {
  const hook = updateWorkInProgressHook()
  const queue = hook.queue
  queue.lastRenderedReducer = reducer
  const current = currentHook
  const pendingQueue = queue.pending
  let newState = current.memoizedState
  if (pendingQueue !== null) {
    queue.pending = null
    const first = pendingQueue.next
    let update = first
    do {
      if (update.hasEagerState) {
        newState = update.eagerState
      } else {
        const action = update.action
        newState = reducer(newState, action)
      }
      update = update.next
    } while (update !== null &amp;&amp; update !== first)
  }
  hook.memoizedState = queue.lastRenderedState = newState
  return [hook.memoizedState, queue.dispatch]
}
<span class="hljs-addition">+function mountState(initialState) {</span>
<span class="hljs-addition">+  const hook = mountWorkInProgressHook();</span>
<span class="hljs-addition">+  hook.memoizedState =  hook.baseState = initialState;</span>
<span class="hljs-addition">+  const queue = {</span>
<span class="hljs-addition">+    pending: null,</span>
<span class="hljs-addition">+    dispatch: null,</span>
<span class="hljs-addition">+    lastRenderedReducer: basicStateReducer,</span>
<span class="hljs-addition">+    lastRenderedState: initialState,</span>
<span class="hljs-addition">+  };</span>
<span class="hljs-addition">+  hook.queue = queue;</span>
<span class="hljs-addition">+  const dispatch = (queue.dispatch = dispatchSetState.bind(null, currentlyRenderingFiber, queue));</span>
<span class="hljs-addition">+  return [hook.memoizedState, dispatch];</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+function dispatchSetState(fiber, queue, action) {</span>
<span class="hljs-addition">+  const update = {</span>
<span class="hljs-addition">+    action,</span>
<span class="hljs-addition">+    hasEagerState: false,</span>
<span class="hljs-addition">+    eagerState: null,</span>
<span class="hljs-addition">+    next: null,</span>
<span class="hljs-addition">+  };</span>
<span class="hljs-addition">+  const lastRenderedReducer = queue.lastRenderedReducer;</span>
<span class="hljs-addition">+  const currentState = queue.lastRenderedState;</span>
<span class="hljs-addition">+  const eagerState = lastRenderedReducer(currentState, action);</span>
<span class="hljs-addition">+  update.hasEagerState = true;</span>
<span class="hljs-addition">+  update.eagerState = eagerState;</span>
<span class="hljs-addition">+  if (is(eagerState, currentState)) {</span>
<span class="hljs-addition">+    return;</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+  const root = enqueueConcurrentHookUpdate(fiber, queue, update);</span>
<span class="hljs-addition">+  scheduleUpdateOnFiber(root, fiber);</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+function updateState(initialState) {</span>
<span class="hljs-addition">+  return updateReducer(basicStateReducer, initialState);</span>
<span class="hljs-addition">+}</span>
function mountWorkInProgressHook() {
  const hook = {
    memoizedState: null,
    queue: null,
    next: null,
  };
  if (workInProgressHook <span class="hljs-comment">=== null) {</span>
    currentlyRenderingFiber.memoizedState = workInProgressHook = hook;
  } else {
    workInProgressHook = workInProgressHook.next = hook;
  }
  return workInProgressHook;
}
function dispatchReducerAction(fiber, queue, action) {
  const update = {
    action,
    next: null,
  };
  const root = enqueueConcurrentHookUpdate(fiber, queue, update);
  scheduleUpdateOnFiber(root, fiber);
}

function updateWorkInProgressHook() {
  if (currentHook <span class="hljs-comment">=== null) {</span>
    const current = currentlyRenderingFiber.alternate
    currentHook = current.memoizedState
  } else {
    currentHook = currentHook.next
  }
  const newHook = {
    memoizedState: currentHook.memoizedState,
    queue: currentHook.queue,
    next: null
  }
  if (workInProgressHook <span class="hljs-comment">=== null) {</span>
    currentlyRenderingFiber.memoizedState = workInProgressHook = newHook
  } else {
    workInProgressHook = workInProgressHook.next = newHook
  }
  return workInProgressHook
}

export function renderWithHooks(current, workInProgress, Component, props) {
  currentlyRenderingFiber = workInProgress;
  if (current !== null &amp;&amp; current.memoizedState !== null) {
    ReactCurrentDispatcher.current = HooksDispatcherOnUpdateInDEV;
  } else {
    ReactCurrentDispatcher.current = HooksDispatcherOnMountInDEV;
  }
  const children = Component(props);
  currentlyRenderingFiber = null;
  workInProgressHook = null;
  currentHook = null;
  return children;
}
</code></pre>
<h2 id="t20224.&#x5355;&#x8282;&#x70B9;(key &#x76F8;&#x540C;,&#x7C7B;&#x578B;&#x76F8;&#x540C;)">24.&#x5355;&#x8282;&#x70B9;(key &#x76F8;&#x540C;,&#x7C7B;&#x578B;&#x76F8;&#x540C;) <a href="#t20224.&#x5355;&#x8282;&#x70B9;(key &#x76F8;&#x540C;,&#x7C7B;&#x578B;&#x76F8;&#x540C;)"> # </a></h2>
<h3 id="t20324.1 src\main.jsx">24.1 src\main.jsx <a href="#t20324.1 src\main.jsx"> # </a></h3>
<p>src\main.jsx</p>
<pre><code class="lang-diff">import * as React from &quot;react&quot;;
import { createRoot } from &quot;react-dom/client&quot;;

<span class="hljs-addition">+function FunctionComponent() {</span>
<span class="hljs-addition">+  const [number, setNumber] = React.useState(0);</span>
<span class="hljs-addition">+  return number === 0 ? (</span>
<span class="hljs-addition">+    &lt;div onClick={() =&gt; setNumber(number + 1)} key=&quot;title&quot; id=&quot;title&quot;&gt;</span>
<span class="hljs-addition">+      title</span>
<span class="hljs-addition">+    &lt;/div&gt;</span>
<span class="hljs-addition">+  ) : (</span>
<span class="hljs-addition">+    &lt;div onClick={() =&gt; setNumber(number + 1)} key=&quot;title&quot; id=&quot;title2&quot;&gt;</span>
<span class="hljs-addition">+      title2</span>
<span class="hljs-addition">+    &lt;/div&gt;</span>
<span class="hljs-addition">+  );</span>
<span class="hljs-addition">+}</span>
let element = &lt;FunctionComponent /&gt;;
const root = createRoot(document.getElementById(&quot;root&quot;));
root.render(element);
</code></pre>
<h2 id="t20425.&#x5355;&#x8282;&#x70B9; key &#x4E0D;&#x540C;,&#x7C7B;&#x578B;&#x76F8;&#x540C;">25.&#x5355;&#x8282;&#x70B9; key &#x4E0D;&#x540C;,&#x7C7B;&#x578B;&#x76F8;&#x540C; <a href="#t20425.&#x5355;&#x8282;&#x70B9; key &#x4E0D;&#x540C;,&#x7C7B;&#x578B;&#x76F8;&#x540C;"> # </a></h2>
<ul>
<li>&#x5355;&#x8282;&#x70B9; key &#x4E0D;&#x540C;,&#x7C7B;&#x578B;&#x76F8;&#x540C;&#xFF0C;&#x5220;&#x9664;&#x8001;&#x8282;&#x70B9;&#xFF0C;&#x6DFB;&#x52A0;&#x65B0;&#x8282;&#x70B9;</li>
</ul>
<h3 id="t20525.1 main.jsx">25.1 main.jsx <a href="#t20525.1 main.jsx"> # </a></h3>
<p>src\main.jsx</p>
<pre><code class="lang-diff">import * as React from &quot;react&quot;;
import { createRoot } from &quot;react-dom/client&quot;;

function FunctionComponent() {
  const [number, setNumber] = React.useState(0);
<span class="hljs-addition">+  return number === 0 ? (</span>
<span class="hljs-addition">+    &lt;div onClick={() =&gt; setNumber(number + 1)} key=&quot;title1&quot; id=&quot;title&quot;&gt;</span>
<span class="hljs-addition">+      title</span>
<span class="hljs-addition">+    &lt;/div&gt;</span>
<span class="hljs-addition">+  ) : (</span>
<span class="hljs-addition">+    &lt;div onClick={() =&gt; setNumber(number + 1)} key=&quot;title2&quot; id=&quot;title2&quot;&gt;</span>
<span class="hljs-addition">+      title2</span>
<span class="hljs-addition">+    &lt;/div&gt;</span>
  );
}
let element = &lt;FunctionComponent /&gt;;
const root = createRoot(document.getElementById(&quot;root&quot;));
root.render(element);
</code></pre>
<h3 id="t20625.2 ReactFiberFlags.js">25.2 ReactFiberFlags.js <a href="#t20625.2 ReactFiberFlags.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberFlags.js</p>
<pre><code class="lang-diff">export const NoFlags = 0b00000000000000000000000000;
export const Placement = 0b00000000000000000000000010;
export const Update = 0b00000000000000000000000100;
<span class="hljs-addition">+export const ChildDeletion = 0b00000000000000000000001000;</span>
export const MutationMask = Placement | Update;
</code></pre>
<h3 id="t20725.3 ReactFiber.js">25.3 ReactFiber.js <a href="#t20725.3 ReactFiber.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiber.js</p>
<pre><code class="lang-diff">export function FiberNode(tag, pendingProps, key) {
  this.tag = tag;
  this.key = key;
  this.type = null;
  this.stateNode = null;

  this.return = null;
  this.child = null;
  this.sibling = null;

  this.pendingProps = pendingProps;
  this.memoizedProps = null;
  this.updateQueue = null;
  this.memoizedState = null;

  this.flags = NoFlags;
  this.subtreeFlags = NoFlags;
<span class="hljs-addition">+ this.deletions = null;</span>
  this.alternate = null;
}
</code></pre>
<h3 id="t20825.4 ReactDOMHostConfig.js">25.4 ReactDOMHostConfig.js <a href="#t20825.4 ReactDOMHostConfig.js"> # </a></h3>
<p>src\react-dom-bindings\src\client\ReactDOMHostConfig.js</p>
<pre><code class="lang-diff"><span class="hljs-addition">+export function removeChild(parentInstance, child) {</span>
<span class="hljs-addition">+  parentInstance.removeChild(child);</span>
<span class="hljs-addition">+}</span>
</code></pre>
<h3 id="t20925.5 ReactChildFiber.js">25.5 ReactChildFiber.js <a href="#t20925.5 ReactChildFiber.js"> # </a></h3>
<p>src\react-reconciler\src\ReactChildFiber.js</p>
<pre><code class="lang-diff">import { REACT_ELEMENT_TYPE } from &quot;shared/ReactSymbols&quot;;
import isArray from &quot;shared/isArray&quot;;
import { createFiberFromElement, FiberNode, createFiberFromText, createWorkInProgress } from &quot;./ReactFiber&quot;;
<span class="hljs-addition">+import { Placement, ChildDeletion } from &quot;./ReactFiberFlags&quot;;</span>
import { HostText } from &quot;./ReactWorkTags&quot;;
function createChildReconciler(shouldTrackSideEffects) {
  function useFiber(fiber, pendingProps) {
    const clone = createWorkInProgress(fiber, pendingProps);
    clone.index = 0;
    clone.sibling = null;
    return clone;
  }
<span class="hljs-addition">+ function deleteChild(returnFiber, childToDelete) {</span>
<span class="hljs-addition">+   if (!shouldTrackSideEffects) {</span>
<span class="hljs-addition">+     return;</span>
<span class="hljs-addition">+   }</span>
<span class="hljs-addition">+   const deletions = returnFiber.deletions;</span>
<span class="hljs-addition">+   if (deletions === null) {</span>
<span class="hljs-addition">+     returnFiber.deletions = [childToDelete];</span>
<span class="hljs-addition">+     returnFiber.flags |= ChildDeletion;</span>
<span class="hljs-addition">+   } else {</span>
<span class="hljs-addition">+     deletions.push(childToDelete);</span>
<span class="hljs-addition">+   }</span>
<span class="hljs-addition">+ }</span>
  function reconcileSingleElement(returnFiber, currentFirstChild, element) {
    const key = element.key;
    let child = currentFirstChild;
    while (child !== null) {
      if (child.key <span class="hljs-comment">=== key) {</span>
        const elementType = element.type;
        if (child.type <span class="hljs-comment">=== elementType) {</span>
          const existing = useFiber(child, element.props);
          existing.return = returnFiber;
          return existing;
        }
<span class="hljs-addition">+     } else {</span>
<span class="hljs-addition">+       deleteChild(returnFiber, child);</span>
<span class="hljs-addition">+     }</span>
      child = child.sibling;
    }
    const created = createFiberFromElement(element);
    created.return = returnFiber;
    return created;
  }
  function placeSingleChild(newFiber) {
    if (shouldTrackSideEffects &amp;&amp; newFiber.alternate <span class="hljs-comment">=== null) {</span>
      newFiber.flags |= Placement;
    }
    return newFiber;
  }
  function reconcileSingleTextNode(returnFiber, currentFirstChild, content) {
    const created = new FiberNode(HostText, { content }, null);
    created.return = returnFiber;
    return created;
  }
  function createChild(returnFiber, newChild) {
    if ((typeof newChild <span class="hljs-comment">=== &quot;string&quot; &amp;&amp; newChild !== &quot;&quot;) || typeof newChild === &quot;number&quot;) {</span>
      const created = createFiberFromText(`${newChild}`);
      created.return = returnFiber;
      return created;
    }

    if (typeof newChild <span class="hljs-comment">=== &quot;object&quot; &amp;&amp; newChild !== null) {</span>
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE: {
          const created = createFiberFromElement(newChild);
          created.return = returnFiber;
          return created;
        }
        default:
          break;
      }
    }
    return null;
  }
  function placeChild(newFiber, newIndex) {
    newFiber.index = newIndex;
    if (shouldTrackSideEffects) newFiber.flags |= Placement;
  }
  function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren) {
    let resultingFirstChild = null;
    let previousNewFiber = null;
    let newIdx = 0;
    for (; newIdx &lt; newChildren.length; newIdx++) {
      const newFiber = createChild(returnFiber, newChildren[newIdx]);
      if (newFiber <span class="hljs-comment">=== null) {</span>
        continue;
      }
      placeChild(newFiber, newIdx);
      if (previousNewFiber <span class="hljs-comment">=== null) {</span>
        resultingFirstChild = newFiber;
      } else {
        previousNewFiber.sibling = newFiber;
      }
      previousNewFiber = newFiber;
    }
    return resultingFirstChild;
  }
  function reconcileChildFibers(returnFiber, currentFirstChild, newChild) {
    if (typeof newChild <span class="hljs-comment">=== &quot;object&quot; &amp;&amp; newChild !== null) {</span>
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE: {
          return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild));
        }
        default:
          break;
      }
      if (isArray(newChild)) {
        return reconcileChildrenArray(returnFiber, currentFirstChild, newChild);
      }
    }
    if (typeof newChild <span class="hljs-comment">=== &quot;string&quot;) {</span>
      return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, newChild));
    }
    return null;
  }
  return reconcileChildFibers;
}
export const reconcileChildFibers = createChildReconciler(true);
export const mountChildFibers = createChildReconciler(false);

</code></pre>
<h3 id="t21025.6 ReactFiberCommitWork.js">25.6 ReactFiberCommitWork.js <a href="#t21025.6 ReactFiberCommitWork.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberCommitWork.js</p>
<pre><code class="lang-diff">import { HostRoot, HostComponent, HostText, FunctionComponent } from &quot;./ReactWorkTags&quot;;
import { MutationMask, Placement, Update } from &quot;./ReactFiberFlags&quot;;
import {
  insertBefore,
  appendChild,
  commitUpdate,
<span class="hljs-addition">+ removeChild,</span>
} from &quot;react-dom-bindings/src/client/ReactDOMHostConfig&quot;;
<span class="hljs-addition">+let hostParent = null;</span>
<span class="hljs-addition">+function commitDeletionEffects(root, returnFiber, deletedFiber) {</span>
<span class="hljs-addition">+  let parent = returnFiber;</span>
<span class="hljs-addition">+  findParent: while (parent !== null) {</span>
<span class="hljs-addition">+    switch (parent.tag) {</span>
<span class="hljs-addition">+      case HostComponent: {</span>
<span class="hljs-addition">+        hostParent = parent.stateNode;</span>
<span class="hljs-addition">+        break findParent;</span>
<span class="hljs-addition">+      }</span>
<span class="hljs-addition">+      case HostRoot: {</span>
<span class="hljs-addition">+        hostParent = parent.stateNode.containerInfo;</span>
<span class="hljs-addition">+        break findParent;</span>
<span class="hljs-addition">+      }</span>
<span class="hljs-addition">+      default:</span>
<span class="hljs-addition">+        break;</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+    parent = parent.return;</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+  commitDeletionEffectsOnFiber(root, returnFiber, deletedFiber);</span>
<span class="hljs-addition">+  hostParent = null;</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+function commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, deletedFiber) {</span>
<span class="hljs-addition">+  switch (deletedFiber.tag) {</span>
<span class="hljs-addition">+    case HostComponent:</span>
<span class="hljs-addition">+    case HostText: {</span>
<span class="hljs-addition">+      recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);</span>
<span class="hljs-addition">+      if (hostParent !== null) {</span>
<span class="hljs-addition">+          removeChild(hostParent, deletedFiber.stateNode);</span>
<span class="hljs-addition">+      }</span>
<span class="hljs-addition">+      break;</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+    default:</span>
<span class="hljs-addition">+      break;</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+function recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, parent) {</span>
<span class="hljs-addition">+  let child = parent.child;</span>
<span class="hljs-addition">+  while (child !== null) {</span>
<span class="hljs-addition">+    commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, child);</span>
<span class="hljs-addition">+    child = child.sibling;</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+}</span>
function recursivelyTraverseMutationEffects(root, parentFiber) {
<span class="hljs-addition">+ const deletions = parentFiber.deletions;</span>
<span class="hljs-addition">+ if (deletions !== null) {</span>
<span class="hljs-addition">+   for (let i = 0; i &lt; deletions.length; i++) {</span>
<span class="hljs-addition">+     const childToDelete = deletions[i];</span>
<span class="hljs-addition">+     commitDeletionEffects(root, parentFiber, childToDelete);</span>
<span class="hljs-addition">+   }</span>
<span class="hljs-addition">+ }</span>
  if (parentFiber.subtreeFlags &amp; MutationMask) {
    let { child } = parentFiber;
    while (child !== null) {
      commitMutationEffectsOnFiber(child, root);
      child = child.sibling;
    }
  }
}
function isHostParent(fiber) {
  return fiber.tag <span class="hljs-comment">=== HostComponent || fiber.tag === HostRoot;</span>
}
function getHostParentFiber(fiber) {
  let parent = fiber.return;
  while (parent !== null) {
    if (isHostParent(parent)) {
      return parent;
    }
    parent = parent.return;
  }
  return parent;
}
function insertOrAppendPlacementNode(node, before, parent) {
  const { tag } = node;
  const isHost = tag <span class="hljs-comment">=== HostComponent || tag === HostText;</span>
  if (isHost) {
    const { stateNode } = node;
    if (before) {
      insertBefore(parent, stateNode, before);
    } else {
      appendChild(parent, stateNode);
    }
  } else {
    const { child } = node;
    if (child !== null) {
      insertOrAppendPlacementNode(child, before, parent);
      let { sibling } = child;
      while (sibling !== null) {
        insertOrAppendPlacementNode(sibling, before, parent);
        sibling = sibling.sibling;
      }
    }
  }
}
function getHostSibling(fiber) {
  let node = fiber;
  siblings: while (true) {
    // &#x5982;&#x679C;&#x6211;&#x4EEC;&#x6CA1;&#x6709;&#x627E;&#x5230;&#x4EFB;&#x4F55;&#x4E1C;&#x897F;&#xFF0C;&#x8BA9;&#x6211;&#x4EEC;&#x8BD5;&#x8BD5;&#x4E0B;&#x4E00;&#x4E2A;&#x5F1F;&#x5F1F;
    while (node.sibling <span class="hljs-comment">=== null) {</span>
      if (node.return <span class="hljs-comment">=== null || isHostParent(node.return)) {</span>
        // &#x5982;&#x679C;&#x6211;&#x4EEC;&#x662F;&#x6839;Fiber&#x6216;&#x8005;&#x7236;&#x4EB2;&#x662F;&#x539F;&#x751F;&#x8282;&#x70B9;&#xFF0C;&#x6211;&#x4EEC;&#x5C31;&#x662F;&#x6700;&#x540E;&#x7684;&#x5F1F;&#x5F1F;
        return null;
      }
      node = node.return;
    }
    // node.sibling.return = node.return
    node = node.sibling;
    while (node.tag !== HostComponent &amp;&amp; node.tag !== HostText) {
      // &#x5982;&#x679C;&#x5B83;&#x4E0D;&#x662F;&#x539F;&#x751F;&#x8282;&#x70B9;&#xFF0C;&#x5E76;&#x4E14;&#xFF0C;&#x6211;&#x4EEC;&#x53EF;&#x80FD;&#x5728;&#x5176;&#x4E2D;&#x6709;&#x4E00;&#x4E2A;&#x539F;&#x751F;&#x8282;&#x70B9;
      // &#x8BD5;&#x7740;&#x5411;&#x4E0B;&#x641C;&#x7D22;&#xFF0C;&#x76F4;&#x5230;&#x627E;&#x5230;&#x4E3A;&#x6B62;
      if (node.flags &amp; Placement) {
        // &#x5982;&#x679C;&#x6211;&#x4EEC;&#x6CA1;&#x6709;&#x5B69;&#x5B50;&#xFF0C;&#x53EF;&#x4EE5;&#x8BD5;&#x8BD5;&#x5F1F;&#x5F1F;
        continue siblings;
      } else {
        // node.child.return = node
        node = node.child;
      }
    } // Check if this host node is stable or about to be placed.
    // &#x68C0;&#x67E5;&#x6B64;&#x539F;&#x751F;&#x8282;&#x70B9;&#x662F;&#x5426;&#x7A33;&#x5B9A;&#x53EF;&#x4EE5;&#x653E;&#x7F6E;
    if (!(node.flags &amp; Placement)) {
      // &#x627E;&#x5230;&#x5B83;&#x4E86;!
      return node.stateNode;
    }
  }
}
function commitPlacement(finishedWork) {
  const parentFiber = getHostParentFiber(finishedWork);
  switch (parentFiber.tag) {
    case HostComponent: {
      const parent = parentFiber.stateNode;
      const before = getHostSibling(finishedWork);
      insertOrAppendPlacementNode(finishedWork, before, parent);
      break;
    }
    case HostRoot: {
      const parent = parentFiber.stateNode.containerInfo;
      const before = getHostSibling(finishedWork);
      insertOrAppendPlacementNode(finishedWork, before, parent);
      break;
    }
    default:
      break;
  }
}
function commitReconciliationEffects(finishedWork) {
  const { flags } = finishedWork;
  if (flags &amp; Placement) {
    commitPlacement(finishedWork);
    finishedWork.flags &amp;= ~Placement;
  }
}
export function commitMutationEffectsOnFiber(finishedWork, root) {
  const current = finishedWork.alternate;
  const flags = finishedWork.flags;
  switch (finishedWork.tag) {
    case HostRoot: {
      recursivelyTraverseMutationEffects(root, finishedWork);
      commitReconciliationEffects(finishedWork);
      break;
    }
    case FunctionComponent: {
      recursivelyTraverseMutationEffects(root, finishedWork);
      commitReconciliationEffects(finishedWork);
      break;
    }
    case HostComponent: {
      recursivelyTraverseMutationEffects(root, finishedWork);
      commitReconciliationEffects(finishedWork);
      if (flags &amp; Update) {
        const instance = finishedWork.stateNode;
        if (instance != null) {
          const newProps = finishedWork.memoizedProps;
          const oldProps = current !== null ? current.memoizedProps : newProps;
          const type = finishedWork.type;
          const updatePayload = finishedWork.updateQueue;
          finishedWork.updateQueue = null;
          if (updatePayload !== null) {
            commitUpdate(instance, updatePayload, type, oldProps, newProps, finishedWork);
          }
        }
      }
      break;
    }
    case HostText: {
      recursivelyTraverseMutationEffects(root, finishedWork);
      commitReconciliationEffects(finishedWork);
      break;
    }
    default: {
      break;
    }
  }
}

</code></pre>
<h2 id="t21126.&#x5355;&#x8282;&#x70B9; key &#x76F8;&#x540C;,&#x7C7B;&#x578B;&#x4E0D;&#x540C;">26.&#x5355;&#x8282;&#x70B9; key &#x76F8;&#x540C;,&#x7C7B;&#x578B;&#x4E0D;&#x540C; <a href="#t21126.&#x5355;&#x8282;&#x70B9; key &#x76F8;&#x540C;,&#x7C7B;&#x578B;&#x4E0D;&#x540C;"> # </a></h2>
<h3 id="t21226.1 src\main.jsx">26.1 src\main.jsx <a href="#t21226.1 src\main.jsx"> # </a></h3>
<p>src\main.jsx</p>
<pre><code class="lang-diff">import * as React from &quot;react&quot;;
import { createRoot } from &quot;react-dom/client&quot;;

function FunctionComponent() {
  const [number, setNumber] = React.useState(0);
<span class="hljs-addition">+  return number === 0 ? (</span>
<span class="hljs-addition">+    &lt;div onClick={() =&gt; setNumber(number + 1)} key=&quot;title1&quot; id=&quot;title1&quot;&gt;</span>
<span class="hljs-addition">+      title1</span>
<span class="hljs-addition">+    &lt;/div&gt;</span>
<span class="hljs-addition">+  ) : (</span>
<span class="hljs-addition">+    &lt;p onClick={() =&gt; setNumber(number + 1)} key=&quot;title1&quot; id=&quot;title1&quot;&gt;</span>
<span class="hljs-addition">+      title1</span>
<span class="hljs-addition">+    &lt;/p&gt;</span>
<span class="hljs-addition">+  );</span>
}
let element = &lt;FunctionComponent /&gt;;
const root = createRoot(document.getElementById(&quot;root&quot;));
root.render(element);

</code></pre>
<h3 id="t21326.2 ReactChildFiber.js">26.2 ReactChildFiber.js <a href="#t21326.2 ReactChildFiber.js"> # </a></h3>
<p>src\react-reconciler\src\ReactChildFiber.js</p>
<pre><code class="lang-diff">import { REACT_ELEMENT_TYPE } from &quot;shared/ReactSymbols&quot;;
import isArray from &quot;shared/isArray&quot;;
import { createFiberFromElement, FiberNode, createFiberFromText, createWorkInProgress } from &quot;./ReactFiber&quot;;
import { Placement, ChildDeletion } from &quot;./ReactFiberFlags&quot;;
import { HostText } from &quot;./ReactWorkTags&quot;;
function createChildReconciler(shouldTrackSideEffects) {
  function useFiber(fiber, pendingProps) {
    const clone = createWorkInProgress(fiber, pendingProps);
    clone.index = 0;
    clone.sibling = null;
    return clone;
  }
  function deleteChild(returnFiber, childToDelete) {
    if (!shouldTrackSideEffects) {
      return;
    }
    const deletions = returnFiber.deletions;
    if (deletions <span class="hljs-comment">=== null) {</span>
      returnFiber.deletions = [childToDelete];
      returnFiber.flags |= ChildDeletion;
    } else {
      deletions.push(childToDelete);
    }
  }
<span class="hljs-addition">+ function deleteRemainingChildren(returnFiber, currentFirstChild) {</span>
<span class="hljs-addition">+   if (!shouldTrackSideEffects) {</span>
<span class="hljs-addition">+     return null;</span>
<span class="hljs-addition">+   }</span>
<span class="hljs-addition">+   let childToDelete = currentFirstChild;</span>
<span class="hljs-addition">+   while (childToDelete !== null) {</span>
<span class="hljs-addition">+     deleteChild(returnFiber, childToDelete);</span>
<span class="hljs-addition">+     childToDelete = childToDelete.sibling;</span>
<span class="hljs-addition">+   }</span>
<span class="hljs-addition">+   return null;</span>
<span class="hljs-addition">+ }</span>
  function reconcileSingleElement(returnFiber, currentFirstChild, element) {
    const key = element.key;
    let child = currentFirstChild;
    while (child !== null) {
      if (child.key <span class="hljs-comment">=== key) {</span>
        const elementType = element.type;
        if (child.type <span class="hljs-comment">=== elementType) {</span>
<span class="hljs-addition">+         deleteRemainingChildren(returnFiber, child.sibling);</span>
          const existing = useFiber(child, element.props);
          existing.return = returnFiber;
          return existing;
        }
<span class="hljs-addition">+       deleteRemainingChildren(returnFiber, child);</span>
<span class="hljs-addition">+       break;</span>
      } else {
        deleteChild(returnFiber, child);
      }
      child = child.sibling;
    }
    const created = createFiberFromElement(element);
    created.return = returnFiber;
    return created;
  }
  function placeSingleChild(newFiber) {
    if (shouldTrackSideEffects &amp;&amp; newFiber.alternate <span class="hljs-comment">=== null) {</span>
      newFiber.flags |= Placement;
    }
    return newFiber;
  }
  function reconcileSingleTextNode(returnFiber, currentFirstChild, content) {
    const created = new FiberNode(HostText, { content }, null);
    created.return = returnFiber;
    return created;
  }
  function createChild(returnFiber, newChild) {
    if ((typeof newChild <span class="hljs-comment">=== &quot;string&quot; &amp;&amp; newChild !== &quot;&quot;) || typeof newChild === &quot;number&quot;) {</span>
      const created = createFiberFromText(`${newChild}`);
      created.return = returnFiber;
      return created;
    }

    if (typeof newChild <span class="hljs-comment">=== &quot;object&quot; &amp;&amp; newChild !== null) {</span>
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE: {
          const created = createFiberFromElement(newChild);
          created.return = returnFiber;
          return created;
        }
        default:
          break;
      }
    }
    return null;
  }
  function placeChild(newFiber, newIndex) {
    newFiber.index = newIndex;
    if (shouldTrackSideEffects) newFiber.flags |= Placement;
  }
  function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren) {
    let resultingFirstChild = null;
    let previousNewFiber = null;
    let newIdx = 0;
    for (; newIdx &lt; newChildren.length; newIdx++) {
      const newFiber = createChild(returnFiber, newChildren[newIdx]);
      if (newFiber <span class="hljs-comment">=== null) {</span>
        continue;
      }
      placeChild(newFiber, newIdx);
      if (previousNewFiber <span class="hljs-comment">=== null) {</span>
        resultingFirstChild = newFiber;
      } else {
        previousNewFiber.sibling = newFiber;
      }
      previousNewFiber = newFiber;
    }
    return resultingFirstChild;
  }
  function reconcileChildFibers(returnFiber, currentFirstChild, newChild) {
    if (typeof newChild <span class="hljs-comment">=== &quot;object&quot; &amp;&amp; newChild !== null) {</span>
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE: {
          return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild));
        }
        default:
          break;
      }
      if (isArray(newChild)) {
        return reconcileChildrenArray(returnFiber, currentFirstChild, newChild);
      }
    }
    if (typeof newChild <span class="hljs-comment">=== &quot;string&quot;) {</span>
      return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, newChild));
    }
    return null;
  }
  return reconcileChildFibers;
}
export const reconcileChildFibers = createChildReconciler(true);
export const mountChildFibers = createChildReconciler(false);

</code></pre>
<h2 id="t21427.&#x539F;&#x6765;&#x591A;&#x4E2A;&#x8282;&#x70B9;&#xFF0C;&#x73B0;&#x5728;&#x53EA;&#x6709;&#x4E00;&#x4E2A;&#x8282;&#x70B9;">27.&#x539F;&#x6765;&#x591A;&#x4E2A;&#x8282;&#x70B9;&#xFF0C;&#x73B0;&#x5728;&#x53EA;&#x6709;&#x4E00;&#x4E2A;&#x8282;&#x70B9; <a href="#t21427.&#x539F;&#x6765;&#x591A;&#x4E2A;&#x8282;&#x70B9;&#xFF0C;&#x73B0;&#x5728;&#x53EA;&#x6709;&#x4E00;&#x4E2A;&#x8282;&#x70B9;"> # </a></h2>
<ul>
<li>&#x539F;&#x6765;&#x591A;&#x4E2A;&#x8282;&#x70B9;&#xFF0C;&#x73B0;&#x5728;&#x53EA;&#x6709;&#x4E00;&#x4E2A;&#x8282;&#x70B9;,&#x5220;&#x9664;&#x591A;&#x4F59;&#x8282;&#x70B9;</li>
</ul>
<h3 id="t21527.1 src\main.jsx">27.1 src\main.jsx <a href="#t21527.1 src\main.jsx"> # </a></h3>
<p>src\main.jsx</p>
<pre><code class="lang-diff">import * as React from &quot;react&quot;;
import { createRoot } from &quot;react-dom/client&quot;;

function FunctionComponent() {
  const [number, setNumber] = React.useState(0);
<span class="hljs-addition">+ return number === 0 ? (</span>
<span class="hljs-addition">+   &lt;ul key=&quot;container&quot; onClick={() =&gt; setNumber(number + 1)}&gt;</span>
<span class="hljs-addition">+     &lt;li key=&quot;A&quot;&gt;A&lt;/li&gt;</span>
<span class="hljs-addition">+     &lt;li key=&quot;B&quot; id=&quot;B&quot;&gt;</span>
<span class="hljs-addition">+       B</span>
<span class="hljs-addition">+     &lt;/li&gt;</span>
<span class="hljs-addition">+     &lt;li key=&quot;C&quot;&gt;C&lt;/li&gt;</span>
<span class="hljs-addition">+   &lt;/ul&gt;</span>
<span class="hljs-addition">+ ) : (</span>
<span class="hljs-addition">+   &lt;ul key=&quot;container&quot; onClick={() =&gt; setNumber(number + 1)}&gt;</span>
<span class="hljs-addition">+     &lt;li key=&quot;B&quot; id=&quot;B2&quot;&gt;</span>
<span class="hljs-addition">+       B2</span>
<span class="hljs-addition">+     &lt;/li&gt;</span>
<span class="hljs-addition">+   &lt;/ul&gt;</span>
<span class="hljs-addition">+ );</span>
}
let element = &lt;FunctionComponent /&gt;;
const root = createRoot(document.getElementById(&quot;root&quot;));
root.render(element);

</code></pre>
<h2 id="t21628.&#x591A;&#x8282;&#x70B9; DIFF">28.&#x591A;&#x8282;&#x70B9; DIFF <a href="#t21628.&#x591A;&#x8282;&#x70B9; DIFF"> # </a></h2>
<ul>
<li>DOM DIFF &#x7684;&#x4E09;&#x4E2A;&#x89C4;&#x5219;<ul>
<li>&#x53EA;&#x5BF9;&#x540C;&#x7EA7;&#x5143;&#x7D20;&#x8FDB;&#x884C;&#x6BD4;&#x8F83;&#xFF0C;&#x4E0D;&#x540C;&#x5C42;&#x7EA7;&#x4E0D;&#x5BF9;&#x6BD4;</li>
<li>&#x4E0D;&#x540C;&#x7684;&#x7C7B;&#x578B;&#x5BF9;&#x5E94;&#x4E0D;&#x540C;&#x7684;&#x5143;&#x7D20;</li>
<li>&#x53EF;&#x4EE5;&#x901A;&#x8FC7; key &#x6765;&#x6807;&#x8BC6;&#x540C;&#x4E00;&#x4E2A;&#x8282;&#x70B9;</li>
</ul>
</li>
<li>&#x7B2C; 1 &#x8F6E;&#x904D;&#x5386;<ul>
<li>&#x5982;&#x679C; key &#x4E0D;&#x540C;&#x5219;&#x76F4;&#x63A5;&#x7ED3;&#x675F;&#x672C;&#x8F6E;&#x5FAA;&#x73AF;</li>
<li>newChildren &#x6216; oldFiber &#x904D;&#x5386;&#x5B8C;&#xFF0C;&#x7ED3;&#x675F;&#x672C;&#x8F6E;&#x5FAA;&#x73AF;</li>
<li>key &#x76F8;&#x540C;&#x800C; type &#x4E0D;&#x540C;&#xFF0C;&#x6807;&#x8BB0;&#x8001;&#x7684; oldFiber &#x4E3A;&#x5220;&#x9664;&#xFF0C;&#x7EE7;&#x7EED;&#x5FAA;&#x73AF;</li>
<li>key &#x76F8;&#x540C;&#x800C; type &#x4E5F;&#x76F8;&#x540C;&#xFF0C;&#x5219;&#x53EF;&#x4EE5;&#x590D;&#x7528;&#x8001;&#x8282; oldFiber &#x8282;&#x70B9;&#xFF0C;&#x7EE7;&#x7EED;&#x5FAA;&#x73AF;</li>
</ul>
</li>
<li>&#x7B2C; 2 &#x8F6E;&#x904D;&#x5386;<ul>
<li>newChildren &#x904D;&#x5386;&#x5B8C;&#x800C; oldFiber &#x8FD8;&#x6709;&#xFF0C;&#x904D;&#x5386;&#x5269;&#x4E0B;&#x6240;&#x6709;&#x7684; oldFiber &#x6807;&#x8BB0;&#x4E3A;&#x5220;&#x9664;&#xFF0C;DIFF &#x7ED3;&#x675F;</li>
<li>oldFiber &#x904D;&#x5386;&#x5B8C;&#x4E86;&#xFF0C;&#x800C; newChildren &#x8FD8;&#x6709;&#xFF0C;&#x5C06;&#x5269;&#x4E0B;&#x7684; newChildren &#x6807;&#x8BB0;&#x4E3A;&#x63D2;&#x5165;&#xFF0C;DIFF &#x7ED3;&#x675F;</li>
<li>newChildren &#x548C; oldFiber &#x90FD;&#x540C;&#x65F6;&#x904D;&#x5386;&#x5B8C;&#x6210;&#xFF0C;diff &#x7ED3;&#x675F;</li>
<li>newChildren &#x548C; oldFiber &#x90FD;&#x6CA1;&#x6709;&#x5B8C;&#x6210;&#xFF0C;&#x5219;&#x8FDB;&#x884C;<code>&#x8282;&#x70B9;&#x79FB;&#x52A8;</code>&#x7684;&#x903B;&#x8F91;</li>
</ul>
</li>
<li>&#x7B2C; 3 &#x8F6E;&#x904D;&#x5386;<ul>
<li>&#x5904;&#x7406;&#x8282;&#x70B9;&#x79FB;&#x52A8;&#x7684;&#x60C5;&#x51B5;</li>
</ul>
</li>
</ul>
<h2 id="t21729.&#x591A;&#x4E2A;&#x8282;&#x70B9;&#x7684;&#x6570;&#x91CF;&#x548C; key &#x76F8;&#x540C;&#xFF0C;&#x6709;&#x7684; type &#x4E0D;&#x540C;">29.&#x591A;&#x4E2A;&#x8282;&#x70B9;&#x7684;&#x6570;&#x91CF;&#x548C; key &#x76F8;&#x540C;&#xFF0C;&#x6709;&#x7684; type &#x4E0D;&#x540C; <a href="#t21729.&#x591A;&#x4E2A;&#x8282;&#x70B9;&#x7684;&#x6570;&#x91CF;&#x548C; key &#x76F8;&#x540C;&#xFF0C;&#x6709;&#x7684; type &#x4E0D;&#x540C;"> # </a></h2>
<ul>
<li>&#x591A;&#x4E2A;&#x8282;&#x70B9;&#x7684;&#x6570;&#x91CF;&#x548C; <code>key</code> &#x76F8;&#x540C;&#xFF0C;&#x6709;&#x7684; <code>type</code> &#x4E0D;&#x540C;&#xFF0C;&#x5219;&#x66F4;&#x65B0;&#x5C5E;&#x6027;&#xFF0C;<code>type</code> &#x4E0D;&#x540C;&#x7684;&#x5220;&#x9664;&#x8001;&#x8282;&#x70B9;&#xFF0C;&#x5220;&#x9664;&#x65B0;&#x8282;&#x70B9;</li>
</ul>
<h3 id="t21829.1 src\main.jsx">29.1 src\main.jsx <a href="#t21829.1 src\main.jsx"> # </a></h3>
<p>src\main.jsx</p>
<pre><code class="lang-diff">import * as React from &quot;react&quot;;
import { createRoot } from &quot;react-dom/client&quot;;

function FunctionComponent() {
  console.log(&quot;FunctionComponent&quot;);
  const [number, setNumber] = React.useState(0);
<span class="hljs-addition">+ return number === 0 ? (</span>
<span class="hljs-addition">+   &lt;ul key=&quot;container&quot; onClick={() =&gt; setNumber(number + 1)}&gt;</span>
<span class="hljs-addition">+     &lt;li key=&quot;A&quot;&gt;A&lt;/li&gt;</span>
<span class="hljs-addition">+     &lt;li key=&quot;B&quot; id=&quot;B&quot;&gt;</span>
<span class="hljs-addition">+       B</span>
<span class="hljs-addition">+     &lt;/li&gt;</span>
<span class="hljs-addition">+     &lt;li key=&quot;C&quot; id=&quot;C&quot;&gt;</span>
<span class="hljs-addition">+       C</span>
<span class="hljs-addition">+     &lt;/li&gt;</span>
<span class="hljs-addition">+   &lt;/ul&gt;</span>
<span class="hljs-addition">+ ) : (</span>
<span class="hljs-addition">+   &lt;ul key=&quot;container&quot; onClick={() =&gt; setNumber(number + 1)}&gt;</span>
<span class="hljs-addition">+     &lt;li key=&quot;A&quot;&gt;A2&lt;/li&gt;</span>
<span class="hljs-addition">+     &lt;p key=&quot;B&quot; id=&quot;B2&quot;&gt;</span>
<span class="hljs-addition">+       B2</span>
<span class="hljs-addition">+     &lt;/p&gt;</span>
<span class="hljs-addition">+     &lt;li key=&quot;C&quot; id=&quot;C2&quot;&gt;</span>
<span class="hljs-addition">+       C2</span>
<span class="hljs-addition">+     &lt;/li&gt;</span>
<span class="hljs-addition">+   &lt;/ul&gt;</span>
<span class="hljs-addition">+ );</span>
}
let element = &lt;FunctionComponent /&gt;;
const root = createRoot(document.getElementById(&quot;root&quot;));
root.render(element);

</code></pre>
<h3 id="t21929.2 ReactChildFiber.js">29.2 ReactChildFiber.js <a href="#t21929.2 ReactChildFiber.js"> # </a></h3>
<p>src\react-reconciler\src\ReactChildFiber.js</p>
<pre><code class="lang-diff">import { REACT_ELEMENT_TYPE } from &quot;shared/ReactSymbols&quot;;
import isArray from &quot;shared/isArray&quot;;
import { createFiberFromElement, FiberNode, createFiberFromText, createWorkInProgress } from &quot;./ReactFiber&quot;;
import { Placement, ChildDeletion } from &quot;./ReactFiberFlags&quot;;
import { HostText } from &quot;./ReactWorkTags&quot;;
function createChildReconciler(shouldTrackSideEffects) {
  function useFiber(fiber, pendingProps) {
    const clone = createWorkInProgress(fiber, pendingProps);
    clone.index = 0;
    clone.sibling = null;
    return clone;
  }
  function deleteChild(returnFiber, childToDelete) {
    if (!shouldTrackSideEffects) {
      return;
    }
    const deletions = returnFiber.deletions;
    if (deletions <span class="hljs-comment">=== null) {</span>
      returnFiber.deletions = [childToDelete];
      returnFiber.flags |= ChildDeletion;
    } else {
      deletions.push(childToDelete);
    }
  }
  function deleteRemainingChildren(returnFiber, currentFirstChild) {
    if (!shouldTrackSideEffects) {
      return null;
    }
    let childToDelete = currentFirstChild;
    while (childToDelete !== null) {
      deleteChild(returnFiber, childToDelete);
      childToDelete = childToDelete.sibling;
    }
    return null;
  }
  function reconcileSingleElement(returnFiber, currentFirstChild, element) {
    const key = element.key;
    let child = currentFirstChild;
    while (child !== null) {
      if (child.key <span class="hljs-comment">=== key) {</span>
        const elementType = element.type;
        if (child.type <span class="hljs-comment">=== elementType) {</span>
          deleteRemainingChildren(returnFiber, child.sibling);
          const existing = useFiber(child, element.props);
          existing.return = returnFiber;
          return existing;
        }
        deleteRemainingChildren(returnFiber, child);
        break;
      } else {
        deleteChild(returnFiber, child);
      }
      child = child.sibling;
    }
    const created = createFiberFromElement(element);
    created.return = returnFiber;
    return created;
  }
  function placeSingleChild(newFiber) {
    if (shouldTrackSideEffects &amp;&amp; newFiber.alternate <span class="hljs-comment">=== null) {</span>
      newFiber.flags |= Placement;
    }
    return newFiber;
  }
  function reconcileSingleTextNode(returnFiber, currentFirstChild, content) {
    const created = new FiberNode(HostText, { content }, null);
    created.return = returnFiber;
    return created;
  }
  function createChild(returnFiber, newChild) {
    if ((typeof newChild <span class="hljs-comment">=== &quot;string&quot; &amp;&amp; newChild !== &quot;&quot;) || typeof newChild === &quot;number&quot;) {</span>
      const created = createFiberFromText(`${newChild}`);
      created.return = returnFiber;
      return created;
    }

    if (typeof newChild <span class="hljs-comment">=== &quot;object&quot; &amp;&amp; newChild !== null) {</span>
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE: {
          const created = createFiberFromElement(newChild);
          created.return = returnFiber;
          return created;
        }
        default:
          break;
      }
    }
    return null;
  }
  function placeChild(newFiber, newIndex) {
<span class="hljs-addition">+   newFiber.index = newIndex;</span>
<span class="hljs-addition">+   if (!shouldTrackSideEffects) {</span>
<span class="hljs-addition">+     return;</span>
<span class="hljs-addition">+   }</span>
<span class="hljs-addition">+   const current = newFiber.alternate;</span>
<span class="hljs-addition">+   if (current !== null) {</span>
<span class="hljs-addition">+     return;</span>
<span class="hljs-addition">+   } else {</span>
<span class="hljs-addition">+     newFiber.flags |= Placement;</span>
<span class="hljs-addition">+   }</span>
  }
<span class="hljs-addition">+ function updateElement(returnFiber, current, element) {</span>
<span class="hljs-addition">+   const elementType = element.type;</span>
<span class="hljs-addition">+   if (current !== null) {</span>
<span class="hljs-addition">+     if (current.type === elementType) {</span>
<span class="hljs-addition">+       const existing = useFiber(current, element.props);</span>
<span class="hljs-addition">+       existing.return = returnFiber;</span>
<span class="hljs-addition">+       return existing;</span>
<span class="hljs-addition">+     }</span>
<span class="hljs-addition">+   }</span>
<span class="hljs-addition">+   const created = createFiberFromElement(element);</span>
<span class="hljs-addition">+   created.return = returnFiber;</span>
<span class="hljs-addition">+   return created;</span>
<span class="hljs-addition">+ }</span>
<span class="hljs-addition">+ function updateSlot(returnFiber, oldFiber, newChild) {</span>
<span class="hljs-addition">+   const key = oldFiber !== null ? oldFiber.key : null;</span>
<span class="hljs-addition">+   if (typeof newChild === &quot;object&quot; &amp;&amp; newChild !== null) {</span>
<span class="hljs-addition">+     switch (newChild.$$typeof) {</span>
<span class="hljs-addition">+       case REACT_ELEMENT_TYPE: {</span>
<span class="hljs-addition">+         if (newChild.key === key) {</span>
<span class="hljs-addition">+           return updateElement(returnFiber, oldFiber, newChild);</span>
<span class="hljs-addition">+         }</span>
<span class="hljs-addition">+       }</span>
<span class="hljs-addition">+       default:</span>
<span class="hljs-addition">+         return null;</span>
<span class="hljs-addition">+     }</span>
<span class="hljs-addition">+     return null</span>
<span class="hljs-addition">+   }</span>
<span class="hljs-addition">+ }</span>

  function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren) {
    let resultingFirstChild = null;
    let previousNewFiber = null;
    let newIdx = 0;
<span class="hljs-addition">+   let oldFiber = currentFirstChild;</span>
<span class="hljs-addition">+   let nextOldFiber = null;</span>
<span class="hljs-addition">+   for (; oldFiber !== null &amp;&amp; newIdx &lt; newChildren.length; newIdx++) {</span>
<span class="hljs-addition">+     nextOldFiber = oldFiber.sibling;</span>
<span class="hljs-addition">+     const newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx]);</span>
<span class="hljs-addition">+     if (newFiber === null) {</span>
<span class="hljs-addition">+       break;</span>
<span class="hljs-addition">+     }</span>
<span class="hljs-addition">+     if (shouldTrackSideEffects) {</span>
<span class="hljs-addition">+       if (oldFiber &amp;&amp; newFiber.alternate === null) {</span>
<span class="hljs-addition">+         deleteChild(returnFiber, oldFiber);</span>
<span class="hljs-addition">+       }</span>
<span class="hljs-addition">+     }</span>
<span class="hljs-addition">+     placeChild(newFiber, newIdx);</span>
<span class="hljs-addition">+     if (previousNewFiber === null) {</span>
<span class="hljs-addition">+       resultingFirstChild = newFiber;</span>
<span class="hljs-addition">+     } else {</span>
<span class="hljs-addition">+       previousNewFiber.sibling = newFiber;</span>
<span class="hljs-addition">+     }</span>
<span class="hljs-addition">+     previousNewFiber = newFiber;</span>
<span class="hljs-addition">+     oldFiber = nextOldFiber;</span>
<span class="hljs-addition">+   }</span>
<span class="hljs-addition">+   if (newIdx === newChildren.length) {</span>
<span class="hljs-addition">+     deleteRemainingChildren(returnFiber, oldFiber);</span>
<span class="hljs-addition">+     return resultingFirstChild;</span>
<span class="hljs-addition">+   }</span>
<span class="hljs-addition">+   if (oldFiber === null) {</span>
<span class="hljs-addition">+     for (; newIdx &lt; newChildren.length; newIdx++) {</span>
<span class="hljs-addition">+       const newFiber = createChild(returnFiber, newChildren[newIdx]);</span>
<span class="hljs-addition">+       if (newFiber === null) {</span>
<span class="hljs-addition">+         continue;</span>
<span class="hljs-addition">+       }</span>
<span class="hljs-addition">+       placeChild(newFiber, newIdx);</span>
<span class="hljs-addition">+       if (previousNewFiber === null) {</span>
<span class="hljs-addition">+         resultingFirstChild = newFiber;</span>
<span class="hljs-addition">+       } else {</span>
<span class="hljs-addition">+         previousNewFiber.sibling = newFiber;</span>
<span class="hljs-addition">+       }</span>
<span class="hljs-addition">+       previousNewFiber = newFiber;</span>
<span class="hljs-addition">+     }</span>
<span class="hljs-addition">+   }</span>
    return resultingFirstChild;
  }
  function reconcileChildFibers(returnFiber, currentFirstChild, newChild) {
    if (typeof newChild <span class="hljs-comment">=== &quot;object&quot; &amp;&amp; newChild !== null) {</span>
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE: {
          return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild));
        }
        default:
          break;
      }
      if (isArray(newChild)) {
        return reconcileChildrenArray(returnFiber, currentFirstChild, newChild);
      }
    }
    if (typeof newChild <span class="hljs-comment">=== &quot;string&quot;) {</span>
      return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, newChild));
    }
    return null;
  }
  return reconcileChildFibers;
}
export const reconcileChildFibers = createChildReconciler(true);
export const mountChildFibers = createChildReconciler(false);

</code></pre>
<h2 id="t22030.&#x591A;&#x4E2A;&#x8282;&#x70B9;&#x7684;&#x7C7B;&#x578B;&#x548C; key &#x5168;&#x90E8;&#x76F8;&#x540C;&#xFF0C;&#x6709;&#x65B0;&#x589E;&#x5143;&#x7D20;">30.&#x591A;&#x4E2A;&#x8282;&#x70B9;&#x7684;&#x7C7B;&#x578B;&#x548C; key &#x5168;&#x90E8;&#x76F8;&#x540C;&#xFF0C;&#x6709;&#x65B0;&#x589E;&#x5143;&#x7D20; <a href="#t22030.&#x591A;&#x4E2A;&#x8282;&#x70B9;&#x7684;&#x7C7B;&#x578B;&#x548C; key &#x5168;&#x90E8;&#x76F8;&#x540C;&#xFF0C;&#x6709;&#x65B0;&#x589E;&#x5143;&#x7D20;"> # </a></h2>
<h3 id="t22130.1 src\main.jsx">30.1 src\main.jsx <a href="#t22130.1 src\main.jsx"> # </a></h3>
<p>src\main.jsx</p>
<pre><code class="lang-diff">import * as React from &quot;react&quot;;
import { createRoot } from &quot;react-dom/client&quot;;

function FunctionComponent() {
  console.log(&quot;FunctionComponent&quot;);
  const [number, setNumber] = React.useState(0);
<span class="hljs-addition">+ return number === 0 ? (</span>
<span class="hljs-addition">+   &lt;ul key=&quot;container&quot; onClick={() =&gt; setNumber(number + 1)}&gt;</span>
<span class="hljs-addition">+     &lt;li key=&quot;A&quot;&gt;A&lt;/li&gt;</span>
<span class="hljs-addition">+     &lt;li key=&quot;B&quot; id=&quot;B&quot;&gt;</span>
<span class="hljs-addition">+       B</span>
<span class="hljs-addition">+     &lt;/li&gt;</span>
<span class="hljs-addition">+     &lt;li key=&quot;C&quot;&gt;C&lt;/li&gt;</span>
<span class="hljs-addition">+   &lt;/ul&gt;</span>
<span class="hljs-addition">+ ) : (</span>
<span class="hljs-addition">+   &lt;ul key=&quot;container&quot; onClick={() =&gt; setNumber(number + 1)}&gt;</span>
<span class="hljs-addition">+     &lt;li key=&quot;A&quot;&gt;A&lt;/li&gt;</span>
<span class="hljs-addition">+     &lt;li key=&quot;B&quot; id=&quot;B2&quot;&gt;</span>
<span class="hljs-addition">+       B2</span>
<span class="hljs-addition">+     &lt;/li&gt;</span>
<span class="hljs-addition">+     &lt;li key=&quot;C&quot;&gt;C2&lt;/li&gt;</span>
<span class="hljs-addition">+     &lt;li key=&quot;D&quot;&gt;D&lt;/li&gt;</span>
<span class="hljs-addition">+   &lt;/ul&gt;</span>
<span class="hljs-addition">+ );</span>
}
let element = &lt;FunctionComponent /&gt;;
const root = createRoot(document.getElementById(&quot;root&quot;));
root.render(element);

</code></pre>
<h2 id="t22231.&#x591A;&#x4E2A;&#x8282;&#x70B9;&#x7684;&#x7C7B;&#x578B;&#x548C; key &#x5168;&#x90E8;&#x76F8;&#x540C;&#xFF0C;&#x6709;&#x5220;&#x9664;&#x8001;&#x5143;&#x7D20;">31.&#x591A;&#x4E2A;&#x8282;&#x70B9;&#x7684;&#x7C7B;&#x578B;&#x548C; key &#x5168;&#x90E8;&#x76F8;&#x540C;&#xFF0C;&#x6709;&#x5220;&#x9664;&#x8001;&#x5143;&#x7D20; <a href="#t22231.&#x591A;&#x4E2A;&#x8282;&#x70B9;&#x7684;&#x7C7B;&#x578B;&#x548C; key &#x5168;&#x90E8;&#x76F8;&#x540C;&#xFF0C;&#x6709;&#x5220;&#x9664;&#x8001;&#x5143;&#x7D20;"> # </a></h2>
<h3 id="t22331.1 src\main.jsx">31.1 src\main.jsx <a href="#t22331.1 src\main.jsx"> # </a></h3>
<p>src\main.jsx</p>
<pre><code class="lang-diff">import * as React from &quot;react&quot;;
import { createRoot } from &quot;react-dom/client&quot;;

function FunctionComponent() {
  console.log(&quot;FunctionComponent&quot;);
  const [number, setNumber] = React.useState(0);
<span class="hljs-addition">+ return number === 0 ? (</span>
<span class="hljs-addition">+   &lt;ul key=&quot;container&quot; onClick={() =&gt; setNumber(number + 1)}&gt;</span>
<span class="hljs-addition">+     &lt;li key=&quot;A&quot;&gt;A&lt;/li&gt;</span>
<span class="hljs-addition">+     &lt;li key=&quot;B&quot; id=&quot;B&quot;&gt;</span>
<span class="hljs-addition">+       B</span>
<span class="hljs-addition">+     &lt;/li&gt;</span>
<span class="hljs-addition">+     &lt;li key=&quot;C&quot;&gt;C&lt;/li&gt;</span>
<span class="hljs-addition">+   &lt;/ul&gt;</span>
<span class="hljs-addition">+ ) : (</span>
<span class="hljs-addition">+   &lt;ul key=&quot;container&quot; onClick={() =&gt; setNumber(number + 1)}&gt;</span>
<span class="hljs-addition">+     &lt;li key=&quot;A&quot;&gt;A&lt;/li&gt;</span>
<span class="hljs-addition">+     &lt;li key=&quot;B&quot; id=&quot;B2&quot;&gt;</span>
<span class="hljs-addition">+       B2</span>
<span class="hljs-addition">+     &lt;/li&gt;</span>
<span class="hljs-addition">+   &lt;/ul&gt;</span>
<span class="hljs-addition">+ );</span>
}
let element = &lt;FunctionComponent /&gt;;
const root = createRoot(document.getElementById(&quot;root&quot;));
root.render(element);

</code></pre>
<h2 id="t22432.&#x591A;&#x4E2A;&#x8282;&#x70B9;&#x6570;&#x91CF;&#x4E0D;&#x540C;&#x3001;key &#x4E0D;&#x540C;">32.&#x591A;&#x4E2A;&#x8282;&#x70B9;&#x6570;&#x91CF;&#x4E0D;&#x540C;&#x3001;key &#x4E0D;&#x540C; <a href="#t22432.&#x591A;&#x4E2A;&#x8282;&#x70B9;&#x6570;&#x91CF;&#x4E0D;&#x540C;&#x3001;key &#x4E0D;&#x540C;"> # </a></h2>
<ul>
<li><a href="https://www.processon.com/diagraming/6193773ef346fb6e38a56734">&#x591A;&#x4E2A;&#x8282;&#x70B9;&#x6570;&#x91CF;&#x4E0D;&#x540C;&#x3001;key &#x4E0D;&#x540C;</a></li>
<li>&#x7B2C;&#x4E00;&#x8F6E;&#x6BD4;&#x8F83; A &#x548C; A&#xFF0C;&#x76F8;&#x540C;&#x53EF;&#x4EE5;&#x590D;&#x7528;&#xFF0C;&#x66F4;&#x65B0;&#xFF0C;&#x7136;&#x540E;&#x6BD4;&#x8F83; B &#x548C; C&#xFF0C;key &#x4E0D;&#x540C;&#x76F4;&#x63A5;&#x8DF3;&#x51FA;&#x7B2C;&#x4E00;&#x4E2A;&#x5FAA;&#x73AF;</li>
<li>&#x628A;&#x5269;&#x4E0B; oldFiber &#x7684;&#x653E;&#x5165; existingChildren &#x8FD9;&#x4E2A; map &#x4E2D;</li>
<li>&#x7136;&#x540E;&#x58F0;&#x660E;&#x4E00;&#x4E2A;<code>lastPlacedIndex</code>&#x53D8;&#x91CF;&#xFF0C;&#x8868;&#x793A;&#x4E0D;&#x9700;&#x8981;&#x79FB;&#x52A8;&#x7684;&#x8001;&#x8282;&#x70B9;&#x7684;&#x7D22;&#x5F15;</li>
<li>&#x7EE7;&#x7EED;&#x5FAA;&#x73AF;&#x5269;&#x4E0B;&#x7684;&#x865A;&#x62DF; DOM &#x8282;&#x70B9;</li>
<li>&#x5982;&#x679C;&#x80FD;&#x5728; map &#x4E2D;&#x627E;&#x5230;&#x76F8;&#x540C; key &#x76F8;&#x540C; type &#x7684;&#x8282;&#x70B9;&#x5219;&#x53EF;&#x4EE5;&#x590D;&#x7528;&#x8001; fiber,&#x5E76;&#x628A;&#x6B64;&#x8001; fiber &#x4ECE; map &#x4E2D;&#x5220;&#x9664;</li>
<li>&#x5982;&#x679C;&#x80FD;&#x5728; map &#x4E2D;&#x627E;&#x4E0D;&#x5230;&#x76F8;&#x540C; key &#x76F8;&#x540C; type &#x7684;&#x8282;&#x70B9;&#x5219;&#x521B;&#x5EFA;&#x65B0;&#x7684; fiber</li>
<li>&#x5982;&#x679C;&#x662F;&#x590D;&#x7528;&#x8001;&#x7684; fiber,&#x5219;&#x5224;&#x65AD;&#x8001; fiber &#x7684;&#x7D22;&#x5F15;&#x662F;&#x5426;&#x5C0F;&#x4E8E; lastPlacedIndex&#xFF0C;&#x5982;&#x679C;&#x662F;&#x8981;&#x79FB;&#x52A8;&#x8001; fiber&#xFF0C;&#x4E0D;&#x53D8;</li>
<li>&#x5982;&#x679C;&#x662F;&#x590D;&#x7528;&#x8001;&#x7684; fiber,&#x5219;&#x5224;&#x65AD;&#x8001; fiber &#x7684;&#x7D22;&#x5F15;&#x662F;&#x5426;&#x5C0F;&#x4E8E; lastPlacedIndex&#xFF0C;&#x5982;&#x679C;&#x5426;&#x5219;&#x66F4;&#x65B0; lastPlacedIndex &#x4E3A;&#x8001; fiber &#x7684; index</li>
<li>&#x628A;&#x6240;&#x6709;&#x7684; map &#x4E2D;&#x5269;&#x4E0B;&#x7684; fiber &#x5168;&#x90E8;&#x6807;&#x8BB0;&#x4E3A;&#x5220;&#x9664;</li>
<li>(&#x5220;&#x9664;#li#F)=&gt;(&#x6DFB;&#x52A0;#li#B)=&gt;(&#x6DFB;&#x52A0;#li#G)=&gt;(&#x6DFB;&#x52A0;#li#D)=&gt;null</li>
</ul>
<p><img src="./assets/img/ed0d3ea12be79471150992a831f1aa7a.jpg" alt></p>
<p><img src="./assets/img/ae312defbb14290beae9e5b95adc068b.png" alt></p>
<h3 id="t22532.1 src\main.jsx">32.1 src\main.jsx <a href="#t22532.1 src\main.jsx"> # </a></h3>
<p>src\main.jsx</p>
<pre><code class="lang-diff">import * as React from &quot;react&quot;;
import { createRoot } from &quot;react-dom/client&quot;;

function FunctionComponent() {
  console.log(&quot;FunctionComponent&quot;);
  const [number, setNumber] = React.useState(0);
  return number <span class="hljs-comment">=== 0 ? (</span>
    &lt;ul key=&quot;container&quot; onClick={() =&gt; setNumber(number + 1)}&gt;
<span class="hljs-addition">+     &lt;li key=&quot;A&quot;&gt;A&lt;/li&gt;</span>
<span class="hljs-addition">+     &lt;li key=&quot;B&quot; id=&quot;b&quot;&gt;</span>
<span class="hljs-addition">+       B</span>
<span class="hljs-addition">+     &lt;/li&gt;</span>
<span class="hljs-addition">+     &lt;li key=&quot;C&quot;&gt;C&lt;/li&gt;</span>
<span class="hljs-addition">+     &lt;li key=&quot;D&quot;&gt;D&lt;/li&gt;</span>
<span class="hljs-addition">+     &lt;li key=&quot;E&quot;&gt;E&lt;/li&gt;</span>
<span class="hljs-addition">+     &lt;li key=&quot;F&quot;&gt;F&lt;/li&gt;</span>
    &lt;/ul&gt;
  ) : (
    &lt;ul key=&quot;container&quot; onClick={() =&gt; setNumber(number + 1)}&gt;
<span class="hljs-addition">+     &lt;li key=&quot;A&quot;&gt;A2&lt;/li&gt;</span>
<span class="hljs-addition">+     &lt;li key=&quot;C&quot;&gt;C2&lt;/li&gt;</span>
<span class="hljs-addition">+     &lt;li key=&quot;E&quot;&gt;E2&lt;/li&gt;</span>
<span class="hljs-addition">+     &lt;li key=&quot;B&quot; id=&quot;b2&quot;&gt;</span>
<span class="hljs-addition">+       B2</span>
<span class="hljs-addition">+     &lt;/li&gt;</span>
<span class="hljs-addition">+     &lt;li key=&quot;G&quot;&gt;G&lt;/li&gt;</span>
<span class="hljs-addition">+     &lt;li key=&quot;D&quot;&gt;D2&lt;/li&gt;</span>
    &lt;/ul&gt;
  );
}
let element = &lt;FunctionComponent /&gt;;
const root = createRoot(document.getElementById(&quot;root&quot;));
root.render(element);

</code></pre>
<h3 id="t22632.2 ReactFiber.js">32.2 ReactFiber.js <a href="#t22632.2 ReactFiber.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiber.js</p>
<pre><code class="lang-diff">export function FiberNode(tag, pendingProps, key) {
  this.tag = tag;
  this.key = key;
  this.type = null;
  this.stateNode = null;

  this.return = null;
  this.child = null;
  this.sibling = null;

  this.pendingProps = pendingProps;
  this.memoizedProps = null;
  this.updateQueue = null;
  this.memoizedState = null;

  this.flags = NoFlags;
  this.subtreeFlags = NoFlags;
  this.deletions = null;
  this.alternate = null;

<span class="hljs-addition">+ this.index = 0;</span>
}
</code></pre>
<h3 id="t22732.3 ReactFiberWorkLoop.js">32.3 ReactFiberWorkLoop.js <a href="#t22732.3 ReactFiberWorkLoop.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberWorkLoop.js</p>
<pre><code class="lang-diff">import { scheduleCallback } from &quot;scheduler&quot;;
import { createWorkInProgress } from &quot;./ReactFiber&quot;;
import { beginWork } from &quot;./ReactFiberBeginWork&quot;;
import { completeWork } from &quot;./ReactFiberCompleteWork&quot;;
import { MutationMask, NoFlags, Placement, Update,ChildDeletion } from &quot;./ReactFiberFlags&quot;;
import { commitMutationEffectsOnFiber } from &quot;./ReactFiberCommitWork&quot;;
import { finishQueueingConcurrentUpdates } from &quot;./ReactFiberConcurrentUpdates&quot;;
import { FunctionComponent, IndeterminateComponent, HostRoot, HostComponent, HostText } from &quot;./ReactWorkTags&quot;;

let workInProgress = null;
export function scheduleUpdateOnFiber(root) {
  ensureRootIsScheduled(root);
}
function ensureRootIsScheduled(root) {
  scheduleCallback(performConcurrentWorkOnRoot.bind(null, root));
}
function performConcurrentWorkOnRoot(root) {
  renderRootSync(root);
  const finishedWork = root.current.alternate;
<span class="hljs-addition">+ printFiber(finishedWork);</span>
<span class="hljs-addition">+ console.log(`~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`);</span>
  root.finishedWork = finishedWork;
  commitRoot(root);
}
function commitRoot(root) {
  const { finishedWork } = root;
  const subtreeHasEffects = (finishedWork.subtreeFlags &amp; MutationMask) !== NoFlags;
  const rootHasEffect = (finishedWork.flags &amp; MutationMask) !== NoFlags;
  if (subtreeHasEffects || rootHasEffect) {
    commitMutationEffectsOnFiber(finishedWork, root);
  }
  root.current = finishedWork;
}
function prepareFreshStack(root) {
  workInProgress = createWorkInProgress(root.current, null);
  finishQueueingConcurrentUpdates();
}
function renderRootSync(root) {
  prepareFreshStack(root);
  workLoopSync();
}

function workLoopSync() {
  while (workInProgress !== null) {
    performUnitOfWork(workInProgress);
  }
}
function performUnitOfWork(unitOfWork) {
  const current = unitOfWork.alternate;
  const next = beginWork(current, unitOfWork);
  unitOfWork.memoizedProps = unitOfWork.pendingProps;
  if (next <span class="hljs-comment">=== null) {</span>
    completeUnitOfWork(unitOfWork);
  } else {
    workInProgress = next;
  }
}

function completeUnitOfWork(unitOfWork) {
  let completedWork = unitOfWork;
  do {
    const current = completedWork.alternate;
    const returnFiber = completedWork.return;
    completeWork(current, completedWork);
    const siblingFiber = completedWork.sibling;
    if (siblingFiber !== null) {
      workInProgress = siblingFiber;
      return;
    }
    completedWork = returnFiber;
    workInProgress = completedWork;
  } while (completedWork !== null);
}

<span class="hljs-addition">+function printFiber(fiber) {</span>
<span class="hljs-addition">+  /*</span>
<span class="hljs-addition">+  fiber.flags &amp;= ~Forked;</span>
<span class="hljs-addition">+  fiber.flags &amp;= ~PlacementDEV;</span>
<span class="hljs-addition">+  fiber.flags &amp;= ~Snapshot;</span>
<span class="hljs-addition">+  fiber.flags &amp;= ~PerformedWork;</span>
<span class="hljs-addition">+  */</span>
<span class="hljs-addition">+  if (fiber.flags !== 0) {</span>
<span class="hljs-addition">+    console.log(</span>
<span class="hljs-addition">+      getFlags(fiber.flags),</span>
<span class="hljs-addition">+      getTag(fiber.tag),</span>
<span class="hljs-addition">+      typeof fiber.type === &quot;function&quot; ? fiber.type.name : fiber.type,</span>
<span class="hljs-addition">+      fiber.memoizedProps</span>
<span class="hljs-addition">+    );</span>
<span class="hljs-addition">+    if (fiber.deletions) {</span>
<span class="hljs-addition">+      for (let i = 0; i &lt; fiber.deletions.length; i++) {</span>
<span class="hljs-addition">+        const childToDelete = fiber.deletions[i];</span>
<span class="hljs-addition">+        console.log(getTag(childToDelete.tag), childToDelete.type, childToDelete.+memoizedProps);</span>
<span class="hljs-addition">+      }</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+  let child = fiber.child;</span>
<span class="hljs-addition">+  while (child) {</span>
<span class="hljs-addition">+    printFiber(child);</span>
<span class="hljs-addition">+    child = child.sibling;</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+function getTag(tag) {</span>
<span class="hljs-addition">+  switch (tag) {</span>
<span class="hljs-addition">+    case FunctionComponent:</span>
<span class="hljs-addition">+      return `FunctionComponent`;</span>
<span class="hljs-addition">+    case HostRoot:</span>
<span class="hljs-addition">+      return `HostRoot`;</span>
<span class="hljs-addition">+    case HostComponent:</span>
<span class="hljs-addition">+      return `HostComponent`;</span>
<span class="hljs-addition">+    case HostText:</span>
<span class="hljs-addition">+      return HostText;</span>
<span class="hljs-addition">+    default:</span>
<span class="hljs-addition">+      return tag;</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+function getFlags(flags) {</span>
<span class="hljs-addition">+  if (flags === (Update | Placement | ChildDeletion)) {</span>
<span class="hljs-addition">+    return `&#x81EA;&#x5DF1;&#x79FB;&#x52A8;&#x548C;&#x5B50;&#x5143;&#x7D20;&#x6709;&#x5220;&#x9664;`;</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+  if (flags === (ChildDeletion | Update)) {</span>
<span class="hljs-addition">+    return `&#x81EA;&#x5DF1;&#x6709;&#x66F4;&#x65B0;&#x548C;&#x5B50;&#x5143;&#x7D20;&#x6709;&#x5220;&#x9664;`;</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+  if (flags === ChildDeletion) {</span>
<span class="hljs-addition">+    return `&#x5B50;&#x5143;&#x7D20;&#x6709;&#x5220;&#x9664;`;</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+  if (flags === (Placement | Update)) {</span>
<span class="hljs-addition">+    return `&#x79FB;&#x52A8;&#x5E76;&#x66F4;&#x65B0;`;</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+  if (flags === Placement) {</span>
<span class="hljs-addition">+    return `&#x63D2;&#x5165;`;</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+  if (flags === Update) {</span>
<span class="hljs-addition">+    return `&#x66F4;&#x65B0;`;</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+  return flags;</span>
<span class="hljs-addition">+}</span>

</code></pre>
<h3 id="t22832.4 ReactChildFiber.js">32.4 ReactChildFiber.js <a href="#t22832.4 ReactChildFiber.js"> # </a></h3>
<p>src\react-reconciler\src\ReactChildFiber.js</p>
<pre><code class="lang-diff">import { REACT_ELEMENT_TYPE } from &quot;shared/ReactSymbols&quot;;
import isArray from &quot;shared/isArray&quot;;
import { createFiberFromElement, FiberNode, createFiberFromText, createWorkInProgress } from &quot;./ReactFiber&quot;;
import { Placement, ChildDeletion } from &quot;./ReactFiberFlags&quot;;
import { HostText } from &quot;./ReactWorkTags&quot;;
function createChildReconciler(shouldTrackSideEffects) {
  function useFiber(fiber, pendingProps) {
    const clone = createWorkInProgress(fiber, pendingProps);
    clone.index = 0;
    clone.sibling = null;
    return clone;
  }
  function deleteChild(returnFiber, childToDelete) {
    if (!shouldTrackSideEffects) {
      return;
    }
    const deletions = returnFiber.deletions;
    if (deletions <span class="hljs-comment">=== null) {</span>
      returnFiber.deletions = [childToDelete];
      returnFiber.flags |= ChildDeletion;
    } else {
      deletions.push(childToDelete);
    }
  }
  function deleteRemainingChildren(returnFiber, currentFirstChild) {
    if (!shouldTrackSideEffects) {
      return null;
    }
    let childToDelete = currentFirstChild;
    while (childToDelete !== null) {
      deleteChild(returnFiber, childToDelete);
      childToDelete = childToDelete.sibling;
    }
    return null;
  }
  function reconcileSingleElement(returnFiber, currentFirstChild, element) {
    const key = element.key;
    let child = currentFirstChild;
    while (child !== null) {
      if (child.key <span class="hljs-comment">=== key) {</span>
        const elementType = element.type;
        if (child.type <span class="hljs-comment">=== elementType) {</span>
          deleteRemainingChildren(returnFiber, child.sibling);
          const existing = useFiber(child, element.props);
          existing.return = returnFiber;
          return existing;
        }
        deleteRemainingChildren(returnFiber, child);
        break;
      } else {
        deleteChild(returnFiber, child);
      }
      child = child.sibling;
    }
    const created = createFiberFromElement(element);
    created.return = returnFiber;
    return created;
  }
  function placeSingleChild(newFiber) {
    if (shouldTrackSideEffects &amp;&amp; newFiber.alternate <span class="hljs-comment">=== null) {</span>
      newFiber.flags |= Placement;
    }
    return newFiber;
  }
  function reconcileSingleTextNode(returnFiber, currentFirstChild, content) {
    const created = new FiberNode(HostText, { content }, null);
    created.return = returnFiber;
    return created;
  }
  function createChild(returnFiber, newChild) {
    if ((typeof newChild <span class="hljs-comment">=== &quot;string&quot; &amp;&amp; newChild !== &quot;&quot;) || typeof newChild === &quot;number&quot;) {</span>
      const created = createFiberFromText(`${newChild}`);
      created.return = returnFiber;
      return created;
    }

    if (typeof newChild <span class="hljs-comment">=== &quot;object&quot; &amp;&amp; newChild !== null) {</span>
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE: {
          const created = createFiberFromElement(newChild);
          created.return = returnFiber;
          return created;
        }
        default:
          break;
      }
    }
    return null;
  }
<span class="hljs-addition">+ function placeChild(newFiber, lastPlacedIndex, newIndex) {</span>
<span class="hljs-addition">+   newFiber.index = newIndex;</span>
<span class="hljs-addition">+   if (!shouldTrackSideEffects) {</span>
<span class="hljs-addition">+     return lastPlacedIndex;</span>
<span class="hljs-addition">+   }</span>
<span class="hljs-addition">+   const current = newFiber.alternate;</span>
<span class="hljs-addition">+   if (current !== null) {</span>
<span class="hljs-addition">+     const oldIndex = current.index;</span>
<span class="hljs-addition">+     if (oldIndex &lt; lastPlacedIndex) {</span>
<span class="hljs-addition">+       newFiber.flags |= Placement;</span>
<span class="hljs-addition">+       return lastPlacedIndex;</span>
<span class="hljs-addition">+     } else {</span>
<span class="hljs-addition">+       return oldIndex;</span>
<span class="hljs-addition">+     }</span>
<span class="hljs-addition">+   } else {</span>
<span class="hljs-addition">+     newFiber.flags |= Placement;</span>
<span class="hljs-addition">+     return lastPlacedIndex;</span>
<span class="hljs-addition">+   }</span>
<span class="hljs-addition">+ }</span>
  function updateElement(returnFiber, current, element) {
    const elementType = element.type;
    if (current !== null) {
      if (current.type <span class="hljs-comment">=== elementType) {</span>
        const existing = useFiber(current, element.props);
        existing.return = returnFiber;
        return existing;
      }
    }
    const created = createFiberFromElement(element);
    created.return = returnFiber;
    return created;
  }
  function updateSlot(returnFiber, oldFiber, newChild) {
    const key = oldFiber !== null ? oldFiber.key : null;
    if (typeof newChild <span class="hljs-comment">=== &quot;object&quot; &amp;&amp; newChild !== null) {</span>
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE: {
          if (newChild.key <span class="hljs-comment">=== key) {</span>
            return updateElement(returnFiber, oldFiber, newChild);
          } else {
            return null;
          }
        }
        default:
          return null;
      }
    }
  }
<span class="hljs-addition">+ function mapRemainingChildren(returnFiber, currentFirstChild) {</span>
<span class="hljs-addition">+   const existingChildren = new Map();</span>
<span class="hljs-addition">+   let existingChild = currentFirstChild;</span>
<span class="hljs-addition">+   while (existingChild !== null) {</span>
<span class="hljs-addition">+     if (existingChild.key !== null) {</span>
<span class="hljs-addition">+       existingChildren.set(existingChild.key, existingChild);</span>
<span class="hljs-addition">+     } else {</span>
<span class="hljs-addition">+       existingChildren.set(existingChild.index, existingChild);</span>
<span class="hljs-addition">+     }</span>
<span class="hljs-addition">+     existingChild = existingChild.sibling;</span>
<span class="hljs-addition">+   }</span>
<span class="hljs-addition">+   return existingChildren;</span>
<span class="hljs-addition">+ }</span>
<span class="hljs-addition">+ function updateTextNode(returnFiber, current, textContent) {</span>
<span class="hljs-addition">+   if (current === null || current.tag !== HostText) {</span>
<span class="hljs-addition">+     const created = createFiberFromText(textContent);</span>
<span class="hljs-addition">+     created.return = returnFiber;</span>
<span class="hljs-addition">+     return created;</span>
<span class="hljs-addition">+   } else {</span>
<span class="hljs-addition">+     const existing = useFiber(current, textContent);</span>
<span class="hljs-addition">+     existing.return = returnFiber;</span>
<span class="hljs-addition">+     return existing;</span>
<span class="hljs-addition">+   }</span>
<span class="hljs-addition">+ }</span>
<span class="hljs-addition">+ function updateFromMap(existingChildren, returnFiber, newIdx, newChild) {</span>
<span class="hljs-addition">+   if ((typeof newChild === &quot;string&quot; &amp;&amp; newChild !== &quot;&quot;) || typeof newChild === &quot;number&quot;) {</span>
<span class="hljs-addition">+     const matchedFiber = existingChildren.get(newIdx) || null;</span>
<span class="hljs-addition">+     return updateTextNode(returnFiber, matchedFiber, &quot;&quot; + newChild);</span>
<span class="hljs-addition">+   }</span>
<span class="hljs-addition">+   if (typeof newChild === &quot;object&quot; &amp;&amp; newChild !== null) {</span>
<span class="hljs-addition">+     switch (newChild.$$typeof) {</span>
<span class="hljs-addition">+       case REACT_ELEMENT_TYPE: {</span>
<span class="hljs-addition">+         const matchedFiber = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;</span>
<span class="hljs-addition">+         return updateElement(returnFiber, matchedFiber, newChild);</span>
<span class="hljs-addition">+       }</span>
<span class="hljs-addition">+     }</span>
<span class="hljs-addition">+   }</span>
<span class="hljs-addition">+   return null;</span>
<span class="hljs-addition">+ }</span>
  function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren) {
    let resultingFirstChild = null;
    let previousNewFiber = null;
    let newIdx = 0;
    let oldFiber = currentFirstChild;
    let nextOldFiber = null;
<span class="hljs-addition">+   let lastPlacedIndex = 0;</span>
    for (; oldFiber !== null &amp;&amp; newIdx &lt; newChildren.length; newIdx++) {
      nextOldFiber = oldFiber.sibling;
      const newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx]);
      if (newFiber <span class="hljs-comment">=== null) {</span>
        break;
      }
      if (shouldTrackSideEffects) {
        if (oldFiber &amp;&amp; newFiber.alternate <span class="hljs-comment">=== null) {</span>
          deleteChild(returnFiber, oldFiber);
        }
      }
<span class="hljs-addition">+     lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);</span>
      if (previousNewFiber <span class="hljs-comment">=== null) {</span>
        resultingFirstChild = newFiber;
      } else {
        previousNewFiber.sibling = newFiber;
      }
      previousNewFiber = newFiber;
      oldFiber = nextOldFiber;
    }
    if (newIdx <span class="hljs-comment">=== newChildren.length) {</span>
      deleteRemainingChildren(returnFiber, oldFiber);
      return resultingFirstChild;
    }
    if (oldFiber <span class="hljs-comment">=== null) {</span>
      for (; newIdx &lt; newChildren.length; newIdx++) {
        const newFiber = createChild(returnFiber, newChildren[newIdx]);
        if (newFiber <span class="hljs-comment">=== null) {</span>
          continue;
        }
<span class="hljs-addition">+       lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);</span>
        if (previousNewFiber <span class="hljs-comment">=== null) {</span>
          resultingFirstChild = newFiber;
        } else {
          previousNewFiber.sibling = newFiber;
        }
        previousNewFiber = newFiber;
      }
    }
<span class="hljs-addition">+   const existingChildren = mapRemainingChildren(returnFiber, oldFiber);</span>
<span class="hljs-addition">+   for (; newIdx &lt; newChildren.length; newIdx++) {</span>
<span class="hljs-addition">+     const newFiber = updateFromMap(existingChildren, returnFiber, newIdx, newChildren[newIdx]);</span>
<span class="hljs-addition">+     if (newFiber !== null) {</span>
<span class="hljs-addition">+       if (shouldTrackSideEffects) {</span>
<span class="hljs-addition">+         if (newFiber.alternate !== null) {</span>
<span class="hljs-addition">+           existingChildren.delete(newFiber.key === null ? newIdx : newFiber.key);</span>
<span class="hljs-addition">+         }</span>
<span class="hljs-addition">+       }</span>
<span class="hljs-addition">+       lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);</span>
<span class="hljs-addition">+       if (previousNewFiber === null) {</span>
<span class="hljs-addition">+         resultingFirstChild = newFiber;</span>
<span class="hljs-addition">+       } else {</span>
<span class="hljs-addition">+         previousNewFiber.sibling = newFiber;</span>
<span class="hljs-addition">+       }</span>
<span class="hljs-addition">+       previousNewFiber = newFiber;</span>
<span class="hljs-addition">+     }</span>
<span class="hljs-addition">+   }</span>
<span class="hljs-addition">+   if (shouldTrackSideEffects) {</span>
<span class="hljs-addition">+     existingChildren.forEach((child) =&gt; deleteChild(returnFiber, child));</span>
<span class="hljs-addition">+   }</span>
    return resultingFirstChild;
  }
  function reconcileChildFibers(returnFiber, currentFirstChild, newChild) {
    if (typeof newChild <span class="hljs-comment">=== &quot;object&quot; &amp;&amp; newChild !== null) {</span>
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE: {
          return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild));
        }
        default:
          break;
      }
      if (isArray(newChild)) {
        return reconcileChildrenArray(returnFiber, currentFirstChild, newChild);
      }
    }
    if (typeof newChild <span class="hljs-comment">=== &quot;string&quot;) {</span>
      return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, newChild));
    }
    return null;
  }
  return reconcileChildFibers;
}
export const reconcileChildFibers = createChildReconciler(true);
export const mountChildFibers = createChildReconciler(false);
</code></pre>
<h2 id="t22933.useEffect">33.useEffect <a href="#t22933.useEffect"> # </a></h2>
<ul>
<li>&#x5728;&#x51FD;&#x6570;&#x7EC4;&#x4EF6;&#x4E3B;&#x4F53;&#x5185;&#xFF08;&#x8FD9;&#x91CC;&#x6307;&#x5728; React &#x6E32;&#x67D3;&#x9636;&#x6BB5;&#xFF09;&#x6539;&#x53D8; DOM&#x3001;&#x6DFB;&#x52A0;&#x8BA2;&#x9605;&#x3001;&#x8BBE;&#x7F6E;&#x5B9A;&#x65F6;&#x5668;&#x3001;&#x8BB0;&#x5F55;&#x65E5;&#x5FD7;&#x4EE5;&#x53CA;&#x6267;&#x884C;&#x5176;&#x4ED6;&#x5305;&#x542B;&#x526F;&#x4F5C;&#x7528;&#x7684;&#x64CD;&#x4F5C;&#x90FD;&#x662F;&#x4E0D;&#x88AB;&#x5141;&#x8BB8;&#x7684;&#xFF0C;&#x56E0;&#x4E3A;&#x8FD9;&#x53EF;&#x80FD;&#x4F1A;&#x4EA7;&#x751F;&#x83AB;&#x540D;&#x5176;&#x5999;&#x7684; bug &#x5E76;&#x7834;&#x574F; UI &#x7684;&#x4E00;&#x81F4;&#x6027;</li>
<li>&#x4F7F;&#x7528; useEffect &#x5B8C;&#x6210;&#x526F;&#x4F5C;&#x7528;&#x64CD;&#x4F5C;&#x3002;&#x8D4B;&#x503C;&#x7ED9; useEffect &#x7684;&#x51FD;&#x6570;&#x4F1A;&#x5728;&#x7EC4;&#x4EF6;&#x6E32;&#x67D3;&#x5230;&#x5C4F;&#x5E55;&#x4E4B;&#x540E;&#x6267;&#x884C;&#x3002;&#x4F60;&#x53EF;&#x4EE5;&#x628A; effect &#x770B;&#x4F5C;&#x4ECE; React &#x7684;&#x7EAF;&#x51FD;&#x6570;&#x5F0F;&#x4E16;&#x754C;&#x901A;&#x5F80;&#x547D;&#x4EE4;&#x5F0F;&#x4E16;&#x754C;&#x7684;&#x9003;&#x751F;&#x901A;&#x9053;</li>
<li>useEffect &#x5C31;&#x662F;&#x4E00;&#x4E2A; Effect Hook&#xFF0C;&#x7ED9;&#x51FD;&#x6570;&#x7EC4;&#x4EF6;&#x589E;&#x52A0;&#x4E86;&#x64CD;&#x4F5C;&#x526F;&#x4F5C;&#x7528;&#x7684;&#x80FD;&#x529B;&#x3002;&#x5B83;&#x8DDF; class &#x7EC4;&#x4EF6;&#x4E2D;&#x7684; componentDidMount&#x3001;componentDidUpdate &#x548C; componentWillUnmount &#x5177;&#x6709;&#x76F8;&#x540C;&#x7684;&#x7528;&#x9014;&#xFF0C;&#x53EA;&#x4E0D;&#x8FC7;&#x88AB;&#x5408;&#x5E76;&#x6210;&#x4E86;&#x4E00;&#x4E2A; API</li>
<li>&#x8BE5; Hook &#x63A5;&#x6536;&#x4E00;&#x4E2A;&#x5305;&#x542B;&#x547D;&#x4EE4;&#x5F0F;&#x3001;&#x4E14;&#x53EF;&#x80FD;&#x6709;&#x526F;&#x4F5C;&#x7528;&#x4EE3;&#x7801;&#x7684;&#x51FD;&#x6570;</li>
</ul>
<p><img src="./assets/img/fb87c53592b8423c401348c111a9b05b.jpg" alt></p>
<p><img src="./assets/img/093f054eb00b344a1c043b7b1e954a42.jpg" alt></p>
<h3 id="t23033.1 src\main.jsx">33.1 src\main.jsx <a href="#t23033.1 src\main.jsx"> # </a></h3>
<p>src\main.jsx</p>
<pre><code class="lang-diff">import * as React from &quot;react&quot;;
import { createRoot } from &quot;react-dom/client&quot;;

function Counter() {
<span class="hljs-addition">+ const [number, setNumber] = React.useState(0);</span>
<span class="hljs-addition">+ React.useEffect(() =&gt; {</span>
<span class="hljs-addition">+   console.log(&quot;useEffect1&quot;);</span>
<span class="hljs-addition">+   return () =&gt; {</span>
<span class="hljs-addition">+     console.log(&quot;destroy useEffect1&quot;);</span>
<span class="hljs-addition">+   };</span>
<span class="hljs-addition">+ });</span>
<span class="hljs-addition">+ React.useEffect(() =&gt; {</span>
<span class="hljs-addition">+   console.log(&quot;useEffect2&quot;);</span>
<span class="hljs-addition">+   return () =&gt; {</span>
<span class="hljs-addition">+     console.log(&quot;destroy useEffect2&quot;);</span>
<span class="hljs-addition">+   };</span>
<span class="hljs-addition">+ });</span>
<span class="hljs-addition">+ React.useEffect(() =&gt; {</span>
<span class="hljs-addition">+   console.log(&quot;useEffect3&quot;);</span>
<span class="hljs-addition">+   return () =&gt; {</span>
<span class="hljs-addition">+     console.log(&quot;destroy useEffect3&quot;);</span>
<span class="hljs-addition">+   };</span>
<span class="hljs-addition">+ });</span>
<span class="hljs-addition">+ return (</span>
<span class="hljs-addition">+   &lt;div</span>
<span class="hljs-addition">+     onClick={() =&gt; {</span>
<span class="hljs-addition">+       setNumber(number + 1);</span>
<span class="hljs-addition">+     }}</span>
<span class="hljs-addition">+   &gt;</span>
<span class="hljs-addition">+     {number}</span>
<span class="hljs-addition">+   &lt;/div&gt;</span>
<span class="hljs-addition">+ );</span>
}
let element = &lt;Counter /&gt;;
const root = createRoot(document.getElementById(&quot;root&quot;));
root.render(element);
</code></pre>
<h3 id="t23133.2 react\index.js">33.2 react\index.js <a href="#t23133.2 react\index.js"> # </a></h3>
<p>src\react\index.js</p>
<pre><code class="lang-diff"><span class="hljs-addition">+export { __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, useReducer, useState, useEffect } from &quot;./src/React&quot;;</span>
</code></pre>
<h3 id="t23233.3 React.js">33.3 React.js <a href="#t23233.3 React.js"> # </a></h3>
<p>src\react\src\React.js</p>
<pre><code class="lang-diff"><span class="hljs-addition">+import { useReducer, useState, useEffect } from &quot;./ReactHooks&quot;;</span>
import ReactSharedInternals from &quot;./ReactSharedInternals&quot;;

<span class="hljs-addition">+export { useReducer, useState, useEffect, ReactSharedInternals as __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED };</span>
</code></pre>
<h3 id="t23333.4 ReactHooks.js">33.4 ReactHooks.js <a href="#t23333.4 ReactHooks.js"> # </a></h3>
<p>src\react\src\ReactHooks.js</p>
<pre><code class="lang-diff">import ReactCurrentDispatcher from &quot;./ReactCurrentDispatcher&quot;;

function resolveDispatcher() {
  const dispatcher = ReactCurrentDispatcher.current;
  return dispatcher;
}

export function useReducer(reducer, initialArg, init) {
  const dispatcher = resolveDispatcher();
  return dispatcher.useReducer(reducer, initialArg, init);
}

export function useState(initialState) {
  const dispatcher = resolveDispatcher();
  return dispatcher.useState(initialState);
}

<span class="hljs-addition">+export function useEffect(create,deps) {</span>
<span class="hljs-addition">+  const dispatcher = resolveDispatcher();</span>
<span class="hljs-addition">+  return dispatcher.useEffect(create,deps);</span>
<span class="hljs-addition">+}</span>
</code></pre>
<h3 id="t23433.5 ReactHookEffectTags.js">33.5 ReactHookEffectTags.js <a href="#t23433.5 ReactHookEffectTags.js"> # </a></h3>
<p>src\react-reconciler\src\ReactHookEffectTags.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> HasEffect = <span class="hljs-number">0b0001</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> Passive = <span class="hljs-number">0b1000</span>;
</code></pre>
<h3 id="t23533.6 ReactFiberFlags.js">33.6 ReactFiberFlags.js <a href="#t23533.6 ReactFiberFlags.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberFlags.js</p>
<pre><code class="lang-diff">export const NoFlags = 0b00000000000000000000000000;
export const Placement = 0b00000000000000000000000010;
export const Update = 0b00000000000000000000000100;
export const ChildDeletion = 0b00000000000000000000001000;
export const MutationMask = Placement | Update;
<span class="hljs-addition">+export const Passive = 0b00000000000000010000000000;</span>
</code></pre>
<h3 id="t23633.7 ReactFiberHooks.js">33.7 ReactFiberHooks.js <a href="#t23633.7 ReactFiberHooks.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberHooks.js</p>
<pre><code class="lang-diff">import ReactSharedInternals from &quot;shared/ReactSharedInternals&quot;;
import { enqueueConcurrentHookUpdate } from &quot;./ReactFiberConcurrentUpdates&quot;;
import { scheduleUpdateOnFiber } from &quot;./ReactFiberWorkLoop&quot;;
import is from &quot;shared/objectIs&quot;;
<span class="hljs-addition">+import { Passive as PassiveEffect } from &quot;./ReactFiberFlags&quot;;</span>
<span class="hljs-addition">+import { HasEffect as HookHasEffect, Passive as HookPassive } from &quot;./ReactHookEffectTags&quot;;</span>

const { ReactCurrentDispatcher } = ReactSharedInternals;
let currentlyRenderingFiber = null;
let workInProgressHook = null;
let currentHook = null;

const HooksDispatcherOnMountInDEV = {
  useReducer: mountReducer,
  useState: mountState,
<span class="hljs-addition">+ useEffect: mountEffect,</span>
};
const HooksDispatcherOnUpdateInDEV = {
  useReducer: updateReducer,
  useState: updateState,
<span class="hljs-addition">+ useEffect: updateEffect,</span>
};
<span class="hljs-addition">+function updateEffect(create, deps) {</span>
<span class="hljs-addition">+  return updateEffectImpl(PassiveEffect, HookPassive, create, deps);</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+function updateEffectImpl(fiberFlags, hookFlags, create, deps) {</span>
<span class="hljs-addition">+  const hook = updateWorkInProgressHook();</span>
<span class="hljs-addition">+  const nextDeps = deps === undefined ? null : deps;</span>
<span class="hljs-addition">+  let destroy;</span>
<span class="hljs-addition">+  if (currentHook !== null) {</span>
<span class="hljs-addition">+    const prevEffect = currentHook.memoizedState;</span>
<span class="hljs-addition">+    destroy = prevEffect.destroy;</span>
<span class="hljs-addition">+    if (nextDeps !== null) {</span>
<span class="hljs-addition">+      const prevDeps = prevEffect.deps;</span>
<span class="hljs-addition">+      if (areHookInputsEqual(nextDeps, prevDeps)) {</span>
<span class="hljs-addition">+        hook.memoizedState = pushEffect(hookFlags, create, destroy, nextDeps);</span>
<span class="hljs-addition">+        return;</span>
<span class="hljs-addition">+      }</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+  currentlyRenderingFiber.flags |= fiberFlags;</span>
<span class="hljs-addition">+  hook.memoizedState = pushEffect(HookHasEffect | hookFlags, create, destroy, nextDeps);</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+function areHookInputsEqual(nextDeps, prevDeps) {</span>
<span class="hljs-addition">+  if (prevDeps === null) {</span>
<span class="hljs-addition">+    return false;</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+  for (let i = 0; i &lt; prevDeps.length &amp;&amp; i &lt; nextDeps.length; i++) {</span>
<span class="hljs-addition">+    if (is(nextDeps[i], prevDeps[i])) {</span>
<span class="hljs-addition">+      continue;</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+    return false;</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+</span>
<span class="hljs-addition">+  return true;</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+function mountEffect(create, deps) {</span>
<span class="hljs-addition">+  return mountEffectImpl(PassiveEffect, HookPassive, create, deps);</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+function mountEffectImpl(fiberFlags, hookFlags, create, deps) {</span>
<span class="hljs-addition">+  const hook = mountWorkInProgressHook();</span>
<span class="hljs-addition">+  const nextDeps = deps === undefined ? null : deps;</span>
<span class="hljs-addition">+  currentlyRenderingFiber.flags |= fiberFlags;</span>
<span class="hljs-addition">+  hook.memoizedState = pushEffect(HookHasEffect | hookFlags, create, undefined, nextDeps);</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+function pushEffect(tag, create, destroy, deps) {</span>
<span class="hljs-addition">+  const effect = {</span>
<span class="hljs-addition">+    tag,</span>
<span class="hljs-addition">+    create,</span>
<span class="hljs-addition">+    destroy,</span>
<span class="hljs-addition">+    deps,</span>
<span class="hljs-addition">+    next: null,</span>
<span class="hljs-addition">+  };</span>
<span class="hljs-addition">+  let componentUpdateQueue = currentlyRenderingFiber.updateQueue;</span>
<span class="hljs-addition">+  if (componentUpdateQueue === null) {</span>
<span class="hljs-addition">+    componentUpdateQueue = createFunctionComponentUpdateQueue();</span>
<span class="hljs-addition">+    currentlyRenderingFiber.updateQueue = componentUpdateQueue;</span>
<span class="hljs-addition">+    componentUpdateQueue.lastEffect = effect.next = effect;</span>
<span class="hljs-addition">+  } else {</span>
<span class="hljs-addition">+    const lastEffect = componentUpdateQueue.lastEffect;</span>
<span class="hljs-addition">+    if (lastEffect === null) {</span>
<span class="hljs-addition">+      componentUpdateQueue.lastEffect = effect.next = effect;</span>
<span class="hljs-addition">+    } else {</span>
<span class="hljs-addition">+      const firstEffect = lastEffect.next;</span>
<span class="hljs-addition">+      lastEffect.next = effect;</span>
<span class="hljs-addition">+      effect.next = firstEffect;</span>
<span class="hljs-addition">+      componentUpdateQueue.lastEffect = effect;</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+  return effect;</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+function createFunctionComponentUpdateQueue() {</span>
<span class="hljs-addition">+  return {</span>
<span class="hljs-addition">+    lastEffect: null,</span>
<span class="hljs-addition">+  };</span>
<span class="hljs-addition">+}</span>
function basicStateReducer(state, action) {
  return typeof action <span class="hljs-comment">=== &quot;function&quot; ? action(state) : action;</span>
}
function mountReducer(reducer, initialArg) {
  const hook = mountWorkInProgressHook();
  hook.memoizedState = initialArg;
  const queue = {
    pending: null,
    dispatch: null,
  };
  hook.queue = queue;
  const dispatch = (queue.dispatch = dispatchReducerAction.bind(null, currentlyRenderingFiber, queue));
  return [hook.memoizedState, dispatch];
}
function updateReducer(reducer) {
  const hook = updateWorkInProgressHook();
  const queue = hook.queue;
  queue.lastRenderedReducer = reducer;
  const current = currentHook;
  const pendingQueue = queue.pending;
  let baseQueue = null;
  let newState = current.memoizedState;
  if (pendingQueue !== null) {
    baseQueue = pendingQueue;
    queue.pending = null;
  }
  if (baseQueue !== null) {
    const first = baseQueue.next;
    let update = first;
    do {
      if (update.hasEagerState) {
        newState = update.eagerState;
      } else {
        const action = update.action;
        newState = reducer(newState, action);
      }
      update = update.next;
    } while (update !== null &amp;&amp; update !== first);
  }
  hook.memoizedState = newState;
  queue.lastRenderedState = newState;
  const dispatch = queue.dispatch;
  return [hook.memoizedState, dispatch];
}
function mountState(initialState) {
  const hook = mountWorkInProgressHook();
  hook.memoizedState = initialState;
  const queue = {
    pending: null,
    dispatch: null,
    lastRenderedReducer: basicStateReducer,
    lastRenderedState: initialState,
  };
  hook.queue = queue;
  const dispatch = (queue.dispatch = dispatchSetState.bind(null, currentlyRenderingFiber, queue));
  return [hook.memoizedState, dispatch];
}
function dispatchSetState(fiber, queue, action) {
  const update = {
    action,
    hasEagerState: false,
    eagerState: null,
    next: null,
  };
  const lastRenderedReducer = queue.lastRenderedReducer;
  const currentState = queue.lastRenderedState;
  const eagerState = lastRenderedReducer(currentState, action);
  update.hasEagerState = true;
  update.eagerState = eagerState;
  if (is(eagerState, currentState)) {
    return;
  }
  const root = enqueueConcurrentHookUpdate(fiber, queue, update);
  scheduleUpdateOnFiber(root, fiber);
}
function updateState(initialState) {
  return updateReducer(basicStateReducer, initialState);
}
function mountWorkInProgressHook() {
  const hook = {
    memoizedState: null,
    queue: null,
    next: null,
  };
  if (workInProgressHook <span class="hljs-comment">=== null) {</span>
    currentlyRenderingFiber.memoizedState = workInProgressHook = hook;
  } else {
    workInProgressHook = workInProgressHook.next = hook;
  }
  return workInProgressHook;
}
function dispatchReducerAction(fiber, queue, action) {
  const update = {
    action,
    next: null,
  };
  const root = enqueueConcurrentHookUpdate(fiber, queue, update);
  scheduleUpdateOnFiber(root, fiber);
}

function updateWorkInProgressHook() {
  let nextCurrentHook;
  if (currentHook <span class="hljs-comment">=== null) {</span>
    const current = currentlyRenderingFiber.alternate;
    if (current !== null) {
      nextCurrentHook = current.memoizedState;
    } else {
      nextCurrentHook = null;
    }
  } else {
    nextCurrentHook = currentHook.next;
  }

  let nextWorkInProgressHook;
  if (workInProgressHook <span class="hljs-comment">=== null) {</span>
    nextWorkInProgressHook = currentlyRenderingFiber.memoizedState;
  } else {
    nextWorkInProgressHook = workInProgressHook.next;
  }

  if (nextWorkInProgressHook !== null) {
    workInProgressHook = nextWorkInProgressHook;
    nextWorkInProgressHook = workInProgressHook.next;
    currentHook = nextCurrentHook;
  } else {
    currentHook = nextCurrentHook;
    const newHook = {
      memoizedState: currentHook.memoizedState,
      queue: currentHook.queue,
      next: null,
    };
    if (workInProgressHook <span class="hljs-comment">=== null) {</span>
      currentlyRenderingFiber.memoizedState = workInProgressHook = newHook;
    } else {
      workInProgressHook = workInProgressHook.next = newHook;
    }
  }
  return workInProgressHook;
}

export function renderWithHooks(current, workInProgress, Component, props) {
  currentlyRenderingFiber = workInProgress;
<span class="hljs-addition">+ workInProgress.updateQueue = null;</span>
<span class="hljs-addition">+ workInProgress.memoizedState = null;</span>
  if (current !== null &amp;&amp; current.memoizedState !== null) {
    ReactCurrentDispatcher.current = HooksDispatcherOnUpdateInDEV;
  } else {
    ReactCurrentDispatcher.current = HooksDispatcherOnMountInDEV;
  }
  const children = Component(props);
  currentlyRenderingFiber = null;
  workInProgressHook = null;
  currentHook = null;
  return children;
}

</code></pre>
<h3 id="t23733.8 ReactFiberWorkLoop.js">33.8 ReactFiberWorkLoop.js <a href="#t23733.8 ReactFiberWorkLoop.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberWorkLoop.js</p>
<pre><code class="lang-diff">import { scheduleCallback } from &quot;scheduler&quot;;
import { createWorkInProgress } from &quot;./ReactFiber&quot;;
import { beginWork } from &quot;./ReactFiberBeginWork&quot;;
import { completeWork } from &quot;./ReactFiberCompleteWork&quot;;
<span class="hljs-addition">+import { MutationMask, NoFlags, Placement, Update, ChildDeletion, Passive } from &quot;./ReactFiberFlags&quot;;</span>
<span class="hljs-addition">+import { commitMutationEffects, commitPassiveUnmountEffects, commitPassiveMountEffects } from &quot;./ReactFiberCommitWork&quot;;</span>
import { finishQueueingConcurrentUpdates } from &quot;./ReactFiberConcurrentUpdates&quot;;
import { FunctionComponent, IndeterminateComponent, HostRoot, HostComponent, HostText } from &quot;./ReactWorkTags&quot;;

let workInProgress = null;
<span class="hljs-addition">+let rootDoesHavePassiveEffects = false;</span>
<span class="hljs-addition">+let rootWithPendingPassiveEffects = null;</span>
export function scheduleUpdateOnFiber(root) {
  ensureRootIsScheduled(root);
}
function ensureRootIsScheduled(root) {
  scheduleCallback(performConcurrentWorkOnRoot.bind(null, root));
}
function performConcurrentWorkOnRoot(root) {
  renderRootSync(root);
  const finishedWork = root.current.alternate;
  printFiber(finishedWork);
  console.log(`~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`);
  root.finishedWork = finishedWork;
  commitRoot(root);
}
<span class="hljs-addition">+export function flushPassiveEffects() {</span>
<span class="hljs-addition">+  if (rootWithPendingPassiveEffects !== null) {</span>
<span class="hljs-addition">+    const root = rootWithPendingPassiveEffects;</span>
<span class="hljs-addition">+    commitPassiveUnmountEffects(root.current);</span>
<span class="hljs-addition">+    commitPassiveMountEffects(root, root.current);</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+}</span>
function commitRoot(root) {
  const { finishedWork } = root;
<span class="hljs-addition">+  if ((finishedWork.subtreeFlags &amp; Passive) !== NoFlags || (finishedWork.flags &amp; Passive) !== NoFlags) {</span>
<span class="hljs-addition">+   if (!rootDoesHavePassiveEffects) {</span>
<span class="hljs-addition">+     rootDoesHavePassiveEffects = true;</span>
<span class="hljs-addition">+     scheduleCallback(flushPassiveEffects);</span>
<span class="hljs-addition">+   }</span>
<span class="hljs-addition">+ }</span>
  const subtreeHasEffects = (finishedWork.subtreeFlags &amp; MutationMask) !== NoFlags;
  const rootHasEffect = (finishedWork.flags &amp; MutationMask) !== NoFlags;
  if (subtreeHasEffects || rootHasEffect) {
<span class="hljs-addition">+   commitMutationEffects(finishedWork, root);</span>
<span class="hljs-addition">+   root.current = finishedWork;</span>
<span class="hljs-addition">+   if (rootDoesHavePassiveEffects) {</span>
<span class="hljs-addition">+     rootDoesHavePassiveEffects = false;</span>
<span class="hljs-addition">+     rootWithPendingPassiveEffects = root;</span>
<span class="hljs-addition">+   }</span>
  }
  root.current = finishedWork;
}
function prepareFreshStack(root) {
  workInProgress = createWorkInProgress(root.current, null);
  finishQueueingConcurrentUpdates();
}
function renderRootSync(root) {
  prepareFreshStack(root);
  workLoopSync();
}

function workLoopSync() {
  while (workInProgress !== null) {
    performUnitOfWork(workInProgress);
  }
}
function performUnitOfWork(unitOfWork) {
  const current = unitOfWork.alternate;
  const next = beginWork(current, unitOfWork);
  unitOfWork.memoizedProps = unitOfWork.pendingProps;
  if (next <span class="hljs-comment">=== null) {</span>
    completeUnitOfWork(unitOfWork);
  } else {
    workInProgress = next;
  }
}

function completeUnitOfWork(unitOfWork) {
  let completedWork = unitOfWork;
  do {
    const current = completedWork.alternate;
    const returnFiber = completedWork.return;
    completeWork(current, completedWork);
    const siblingFiber = completedWork.sibling;
    if (siblingFiber !== null) {
      workInProgress = siblingFiber;
      return;
    }
    completedWork = returnFiber;
    workInProgress = completedWork;
  } while (completedWork !== null);
}

function printFiber(fiber) {
  /*
  fiber.flags &amp;= ~Forked;
  fiber.flags &amp;= ~PlacementDEV;
  fiber.flags &amp;= ~Snapshot;
  fiber.flags &amp;= ~PerformedWork;
  */
  if (fiber.flags !== 0) {
    console.log(
      getFlags(fiber.flags),
      getTag(fiber.tag),
      typeof fiber.type <span class="hljs-comment">=== &quot;function&quot; ? fiber.type.name : fiber.type,</span>
      fiber.memoizedProps
    );
    if (fiber.deletions) {
      for (let i = 0; i &lt; fiber.deletions.length; i++) {
        const childToDelete = fiber.deletions[i];
        console.log(getTag(childToDelete.tag), childToDelete.type, childToDelete.memoizedProps);
      }
    }
  }
  let child = fiber.child;
  while (child) {
    printFiber(child);
    child = child.sibling;
  }
}
function getTag(tag) {
  switch (tag) {
    case FunctionComponent:
      return `FunctionComponent`;
    case HostRoot:
      return `HostRoot`;
    case HostComponent:
      return `HostComponent`;
    case HostText:
      return HostText;
    default:
      return tag;
  }
}
function getFlags(flags) {
  if (flags <span class="hljs-comment">=== (Update | Placement | ChildDeletion)) {</span>
    return `&#x81EA;&#x5DF1;&#x79FB;&#x52A8;&#x548C;&#x5B50;&#x5143;&#x7D20;&#x6709;&#x5220;&#x9664;`;
  }
  if (flags <span class="hljs-comment">=== (ChildDeletion | Update)) {</span>
    return `&#x81EA;&#x5DF1;&#x6709;&#x66F4;&#x65B0;&#x548C;&#x5B50;&#x5143;&#x7D20;&#x6709;&#x5220;&#x9664;`;
  }
  if (flags <span class="hljs-comment">=== ChildDeletion) {</span>
    return `&#x5B50;&#x5143;&#x7D20;&#x6709;&#x5220;&#x9664;`;
  }
  if (flags <span class="hljs-comment">=== (Placement | Update)) {</span>
    return `&#x79FB;&#x52A8;&#x5E76;&#x66F4;&#x65B0;`;
  }
  if (flags <span class="hljs-comment">=== Placement) {</span>
    return `&#x63D2;&#x5165;`;
  }
  if (flags <span class="hljs-comment">=== Update) {</span>
    return `&#x66F4;&#x65B0;`;
  }
  return flags;
}
</code></pre>
<h3 id="t23833.9 ReactFiberCommitWork.js">33.9 ReactFiberCommitWork.js <a href="#t23833.9 ReactFiberCommitWork.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberCommitWork.js</p>
<pre><code class="lang-diff">import { HostRoot, HostComponent, HostText, FunctionComponent } from &quot;./ReactWorkTags&quot;;
<span class="hljs-addition">+import { MutationMask, Placement, Update, Passive } from &quot;./ReactFiberFlags&quot;;</span>
import { insertBefore, appendChild, commitUpdate, removeChild } from &quot;react-dom-bindings/src/client/ReactDOMHostConfig&quot;;
<span class="hljs-addition">+import { HasEffect as HookHasEffect, Passive as HookPassive } from &quot;./ReactHookEffectTags&quot;;</span>

<span class="hljs-addition">+export function commitMutationEffects(finishedWork, root) {</span>
<span class="hljs-addition">+  commitMutationEffectsOnFiber(finishedWork, root);</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+export function commitPassiveUnmountEffects(finishedWork) {</span>
<span class="hljs-addition">+  commitPassiveUnmountOnFiber(finishedWork);</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+function commitPassiveUnmountOnFiber(finishedWork) {</span>
<span class="hljs-addition">+  switch (finishedWork.tag) {</span>
<span class="hljs-addition">+    case FunctionComponent: {</span>
<span class="hljs-addition">+      recursivelyTraversePassiveUnmountEffects(finishedWork);</span>
<span class="hljs-addition">+      if (finishedWork.flags &amp; Passive) {</span>
<span class="hljs-addition">+        commitHookPassiveUnmountEffects(finishedWork, finishedWork.return, HookPassive | HookHasEffect);</span>
<span class="hljs-addition">+      }</span>
<span class="hljs-addition">+      break;</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+    default: {</span>
<span class="hljs-addition">+      recursivelyTraversePassiveUnmountEffects(finishedWork);</span>
<span class="hljs-addition">+      break;</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+function recursivelyTraversePassiveUnmountEffects(parentFiber) {</span>
<span class="hljs-addition">+  if (parentFiber.subtreeFlags &amp; Passive) {</span>
<span class="hljs-addition">+    let child = parentFiber.child;</span>
<span class="hljs-addition">+    while (child !== null) {</span>
<span class="hljs-addition">+      commitPassiveUnmountOnFiber(child);</span>
<span class="hljs-addition">+      child = child.sibling;</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+function commitHookPassiveUnmountEffects(finishedWork, nearestMountedAncestor, +hookFlags) {</span>
<span class="hljs-addition">+  commitHookEffectListUnmount(hookFlags, finishedWork, nearestMountedAncestor);</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+</span>
<span class="hljs-addition">+function commitHookEffectListUnmount(flags, finishedWork) {</span>
<span class="hljs-addition">+  const updateQueue = finishedWork.updateQueue;</span>
<span class="hljs-addition">+  const lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;</span>
<span class="hljs-addition">+  if (lastEffect !== null) {</span>
<span class="hljs-addition">+    const firstEffect = lastEffect.next;</span>
<span class="hljs-addition">+    let effect = firstEffect;</span>
<span class="hljs-addition">+    do {</span>
<span class="hljs-addition">+      if ((effect.tag &amp; flags) === flags) {</span>
<span class="hljs-addition">+        const destroy = effect.destroy;</span>
<span class="hljs-addition">+        effect.destroy = undefined;</span>
<span class="hljs-addition">+        if (destroy !== undefined) {</span>
<span class="hljs-addition">+          destroy();</span>
<span class="hljs-addition">+        }</span>
<span class="hljs-addition">+      }</span>
<span class="hljs-addition">+      effect = effect.next;</span>
<span class="hljs-addition">+    } while (effect !== firstEffect);</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+}</span>

<span class="hljs-addition">+export function commitPassiveMountEffects(root, finishedWork) {</span>
<span class="hljs-addition">+  commitPassiveMountOnFiber(root, finishedWork);</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+function commitPassiveMountOnFiber(finishedRoot, finishedWork) {</span>
<span class="hljs-addition">+  const flags = finishedWork.flags;</span>
<span class="hljs-addition">+  switch (finishedWork.tag) {</span>
<span class="hljs-addition">+    case FunctionComponent: {</span>
<span class="hljs-addition">+      recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork);</span>
<span class="hljs-addition">+      if (flags &amp; Passive) {</span>
<span class="hljs-addition">+        commitHookPassiveMountEffects(finishedWork, HookPassive | HookHasEffect);</span>
<span class="hljs-addition">+      }</span>
<span class="hljs-addition">+      break;</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+    case HostRoot: {</span>
<span class="hljs-addition">+      recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork);</span>
<span class="hljs-addition">+      break;</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+    default:</span>
<span class="hljs-addition">+      break;</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+function commitHookPassiveMountEffects(finishedWork, hookFlags) {</span>
<span class="hljs-addition">+  commitHookEffectListMount(hookFlags, finishedWork);</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+function commitHookEffectListMount(flags, finishedWork) {</span>
<span class="hljs-addition">+  const updateQueue = finishedWork.updateQueue;</span>
<span class="hljs-addition">+  const lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;</span>
<span class="hljs-addition">+  if (lastEffect !== null) {</span>
<span class="hljs-addition">+    const firstEffect = lastEffect.next;</span>
<span class="hljs-addition">+    let effect = firstEffect;</span>
<span class="hljs-addition">+    do {</span>
<span class="hljs-addition">+      if ((effect.tag &amp; flags) === flags) {</span>
<span class="hljs-addition">+        const create = effect.create;</span>
<span class="hljs-addition">+        effect.destroy = create();</span>
<span class="hljs-addition">+      }</span>
<span class="hljs-addition">+      effect = effect.next;</span>
<span class="hljs-addition">+    } while (effect !== firstEffect);</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+function recursivelyTraversePassiveMountEffects(root, parentFiber) {</span>
<span class="hljs-addition">+  if (parentFiber.subtreeFlags &amp; Passive) {</span>
<span class="hljs-addition">+    let child = parentFiber.child;</span>
<span class="hljs-addition">+    while (child !== null) {</span>
<span class="hljs-addition">+      commitPassiveMountOnFiber(root, child);</span>
<span class="hljs-addition">+      child = child.sibling;</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+}</span>
let hostParent = null;
function commitDeletionEffects(root, returnFiber, deletedFiber) {
  let parent = returnFiber;
  findParent: while (parent !== null) {
    switch (parent.tag) {
      case HostComponent: {
        hostParent = parent.stateNode;
        break findParent;
      }
      case HostRoot: {
        hostParent = parent.stateNode.containerInfo;
        break findParent;
      }
      default:
        break;
    }
    parent = parent.return;
  }
  commitDeletionEffectsOnFiber(root, returnFiber, deletedFiber);
  hostParent = null;
}
function commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, deletedFiber) {
  switch (deletedFiber.tag) {
    case HostComponent:
    case HostText: {
      recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
      if (hostParent !== null) {
        removeChild(hostParent, deletedFiber.stateNode);
      }
      break;
    }
    default:
      break;
  }
}
function recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, parent) {
  let child = parent.child;
  while (child !== null) {
    commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, child);
    child = child.sibling;
  }
}
function recursivelyTraverseMutationEffects(root, parentFiber) {
  const deletions = parentFiber.deletions;
  if (deletions !== null) {
    for (let i = 0; i &lt; deletions.length; i++) {
      const childToDelete = deletions[i];
      commitDeletionEffects(root, parentFiber, childToDelete);
    }
  }
  if (parentFiber.subtreeFlags &amp; MutationMask) {
    let { child } = parentFiber;
    while (child !== null) {
      commitMutationEffectsOnFiber(child, root);
      child = child.sibling;
    }
  }
}
function isHostParent(fiber) {
  return fiber.tag <span class="hljs-comment">=== HostComponent || fiber.tag === HostRoot;</span>
}
function getHostParentFiber(fiber) {
  let parent = fiber.return;
  while (parent !== null) {
    if (isHostParent(parent)) {
      return parent;
    }
    parent = parent.return;
  }
  return parent;
}
function insertOrAppendPlacementNode(node, before, parent) {
  const { tag } = node;
  const isHost = tag <span class="hljs-comment">=== HostComponent || tag === HostText;</span>
  if (isHost) {
    const { stateNode } = node;
    if (before) {
      insertBefore(parent, stateNode, before);
    } else {
      appendChild(parent, stateNode);
    }
  } else {
    const { child } = node;
    if (child !== null) {
      insertOrAppendPlacementNode(child, before, parent);
      let { sibling } = child;
      while (sibling !== null) {
        insertOrAppendPlacementNode(sibling, before, parent);
        sibling = sibling.sibling;
      }
    }
  }
}
function getHostSibling(fiber) {
  let node = fiber;
  siblings: while (true) {
    // &#x5982;&#x679C;&#x6211;&#x4EEC;&#x6CA1;&#x6709;&#x627E;&#x5230;&#x4EFB;&#x4F55;&#x4E1C;&#x897F;&#xFF0C;&#x8BA9;&#x6211;&#x4EEC;&#x8BD5;&#x8BD5;&#x4E0B;&#x4E00;&#x4E2A;&#x5F1F;&#x5F1F;
    while (node.sibling <span class="hljs-comment">=== null) {</span>
      if (node.return <span class="hljs-comment">=== null || isHostParent(node.return)) {</span>
        // &#x5982;&#x679C;&#x6211;&#x4EEC;&#x662F;&#x6839;Fiber&#x6216;&#x8005;&#x7236;&#x4EB2;&#x662F;&#x539F;&#x751F;&#x8282;&#x70B9;&#xFF0C;&#x6211;&#x4EEC;&#x5C31;&#x662F;&#x6700;&#x540E;&#x7684;&#x5F1F;&#x5F1F;
        return null;
      }
      node = node.return;
    }
    // node.sibling.return = node.return
    node = node.sibling;
    while (node.tag !== HostComponent &amp;&amp; node.tag !== HostText) {
      // &#x5982;&#x679C;&#x5B83;&#x4E0D;&#x662F;&#x539F;&#x751F;&#x8282;&#x70B9;&#xFF0C;&#x5E76;&#x4E14;&#xFF0C;&#x6211;&#x4EEC;&#x53EF;&#x80FD;&#x5728;&#x5176;&#x4E2D;&#x6709;&#x4E00;&#x4E2A;&#x539F;&#x751F;&#x8282;&#x70B9;
      // &#x8BD5;&#x7740;&#x5411;&#x4E0B;&#x641C;&#x7D22;&#xFF0C;&#x76F4;&#x5230;&#x627E;&#x5230;&#x4E3A;&#x6B62;
      if (node.flags &amp; Placement) {
        // &#x5982;&#x679C;&#x6211;&#x4EEC;&#x6CA1;&#x6709;&#x5B69;&#x5B50;&#xFF0C;&#x53EF;&#x4EE5;&#x8BD5;&#x8BD5;&#x5F1F;&#x5F1F;
        continue siblings;
      } else {
        // node.child.return = node
        node = node.child;
      }
    } // Check if this host node is stable or about to be placed.
    // &#x68C0;&#x67E5;&#x6B64;&#x539F;&#x751F;&#x8282;&#x70B9;&#x662F;&#x5426;&#x7A33;&#x5B9A;&#x53EF;&#x4EE5;&#x653E;&#x7F6E;
    if (!(node.flags &amp; Placement)) {
      // &#x627E;&#x5230;&#x5B83;&#x4E86;!
      return node.stateNode;
    }
  }
}
function commitPlacement(finishedWork) {
  const parentFiber = getHostParentFiber(finishedWork);
  switch (parentFiber.tag) {
    case HostComponent: {
      const parent = parentFiber.stateNode;
      const before = getHostSibling(finishedWork);
      insertOrAppendPlacementNode(finishedWork, before, parent);
      break;
    }
    case HostRoot: {
      const parent = parentFiber.stateNode.containerInfo;
      const before = getHostSibling(finishedWork);
      insertOrAppendPlacementNode(finishedWork, before, parent);
      break;
    }
    default:
      break;
  }
}
function commitReconciliationEffects(finishedWork) {
  const { flags } = finishedWork;
  if (flags &amp; Placement) {
    commitPlacement(finishedWork);
    finishedWork.flags &amp;= ~Placement;
  }
}
export function commitMutationEffectsOnFiber(finishedWork, root) {
  const current = finishedWork.alternate;
  const flags = finishedWork.flags;
  switch (finishedWork.tag) {
    case HostRoot: {
      recursivelyTraverseMutationEffects(root, finishedWork);
      commitReconciliationEffects(finishedWork);
      break;
    }
    case FunctionComponent: {
      recursivelyTraverseMutationEffects(root, finishedWork);
      commitReconciliationEffects(finishedWork);
      break;
    }
    case HostComponent: {
      recursivelyTraverseMutationEffects(root, finishedWork);
      commitReconciliationEffects(finishedWork);
      if (flags &amp; Update) {
        const instance = finishedWork.stateNode;
        if (instance != null) {
          const newProps = finishedWork.memoizedProps;
          const oldProps = current !== null ? current.memoizedProps : newProps;
          const type = finishedWork.type;
          const updatePayload = finishedWork.updateQueue;
          finishedWork.updateQueue = null;
          if (updatePayload !== null) {
            commitUpdate(instance, updatePayload, type, oldProps, newProps, finishedWork);
          }
        }
      }
      break;
    }
    case HostText: {
      recursivelyTraverseMutationEffects(root, finishedWork);
      commitReconciliationEffects(finishedWork);
      break;
    }
    default: {
      break;
    }
  }
}
</code></pre>
<h2 id="t23934.useLayoutEffect">34.useLayoutEffect <a href="#t23934.useLayoutEffect"> # </a></h2>
<ul>
<li>&#x5176;&#x51FD;&#x6570;&#x7B7E;&#x540D;&#x4E0E; useEffect &#x76F8;&#x540C;&#xFF0C;&#x4F46;&#x5B83;&#x4F1A;&#x5728;&#x6240;&#x6709;&#x7684; DOM &#x53D8;&#x66F4;&#x4E4B;&#x540E;&#x540C;&#x6B65;&#x8C03;&#x7528; effect</li>
<li>useEffect&#x4E0D;&#x4F1A;&#x963B;&#x585E;&#x6D4F;&#x89C8;&#x5668;&#x6E32;&#x67D3;&#xFF0C;&#x800C; useLayoutEffect &#x4F1A;&#x6D4F;&#x89C8;&#x5668;&#x6E32;&#x67D3;</li>
<li>useEffect&#x4F1A;&#x5728;&#x6D4F;&#x89C8;&#x5668;&#x6E32;&#x67D3;&#x7ED3;&#x675F;&#x540E;&#x6267;&#x884C;,useLayoutEffect &#x5219;&#x662F;&#x5728; DOM &#x66F4;&#x65B0;&#x5B8C;&#x6210;&#x540E;,&#x6D4F;&#x89C8;&#x5668;&#x7ED8;&#x5236;&#x4E4B;&#x524D;&#x6267;&#x884C;</li>
</ul>
<p><img src="./assets/img/6c26c5ef0454eb19585d561129766641.jpg" alt></p>
<p><img src="./assets/img/21dd3741123339ecb48a5386cec4b96f.jpg" alt></p>
<p><img src="./assets/img/1ce0599e551e5276d2facbbb8e2e0bd8.png" alt="useLayoutEffect"></p>
<h3 id="t24034.1 src\main.jsx">34.1 src\main.jsx <a href="#t24034.1 src\main.jsx"> # </a></h3>
<p>src\main.jsx</p>
<pre><code class="lang-diff">import * as React from &quot;react&quot;;
import { createRoot } from &quot;react-dom/client&quot;;

function Counter() {
  const [number, setNumber] = React.useState(0);
  React.useEffect(() =&gt; {
    console.log(&quot;useEffect1&quot;);
    return () =&gt; {
      console.log(&quot;destroy useEffect1&quot;);
    };
  });
<span class="hljs-addition">+ React.useLayoutEffect(() =&gt; {</span>
<span class="hljs-addition">+   console.log(&quot;useLayoutEffect2&quot;);</span>
<span class="hljs-addition">+   return () =&gt; {</span>
<span class="hljs-addition">+     console.log(&quot;destroy useLayoutEffect2&quot;);</span>
<span class="hljs-addition">+   };</span>
<span class="hljs-addition">+ });</span>
  React.useEffect(() =&gt; {
    console.log(&quot;useEffect3&quot;);
    return () =&gt; {
      console.log(&quot;destroy useEffect3&quot;);
    };
  });
  return (
    &lt;div
      onClick={() =&gt; {
        setNumber(number + 1);
      }}
    &gt;
      {number}
    &lt;/div&gt;
  );
}
let element = &lt;Counter /&gt;;
const root = createRoot(document.getElementById(&quot;root&quot;));
root.render(element);

</code></pre>
<h3 id="t24133.2 react\index.js">33.2 react\index.js <a href="#t24133.2 react\index.js"> # </a></h3>
<p>src\react\index.js</p>
<pre><code class="lang-diff">export {
  __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
  useReducer,
  useState,
  useEffect,
<span class="hljs-addition">+ useLayoutEffect,</span>
} from &quot;./src/React&quot;;
</code></pre>
<h3 id="t24234.3 React.js">34.3 React.js <a href="#t24234.3 React.js"> # </a></h3>
<p>src\react\src\React.js</p>
<pre><code class="lang-diff">import { useReducer, useState, useEffect, useLayoutEffect } from &quot;./ReactHooks&quot;;
import ReactSharedInternals from &quot;./ReactSharedInternals&quot;;

export {
  useReducer,
  useState,
  useEffect,
<span class="hljs-addition">+ useLayoutEffect,</span>
  ReactSharedInternals as __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
};
</code></pre>
<h3 id="t24334.4 ReactHooks.js">34.4 ReactHooks.js <a href="#t24334.4 ReactHooks.js"> # </a></h3>
<p>src\react\src\ReactHooks.js</p>
<pre><code class="lang-diff">import ReactCurrentDispatcher from &quot;./ReactCurrentDispatcher&quot;;

function resolveDispatcher() {
  const dispatcher = ReactCurrentDispatcher.current;
  return dispatcher;
}

export function useReducer(reducer, initialArg, init) {
  const dispatcher = resolveDispatcher();
  return dispatcher.useReducer(reducer, initialArg, init);
}

export function useState(initialState) {
  const dispatcher = resolveDispatcher();
  return dispatcher.useState(initialState);
}

export function useEffect(create,deps) {
  const dispatcher = resolveDispatcher();
  return dispatcher.useEffect(create,deps);
}
<span class="hljs-addition">+export function useLayoutEffect(create,deps) {</span>
<span class="hljs-addition">+  const dispatcher = resolveDispatcher();</span>
<span class="hljs-addition">+  return dispatcher.useLayoutEffect(create,deps);</span>
<span class="hljs-addition">+}</span>
</code></pre>
<h3 id="t24434.5 ReactHookEffectTags.js">34.5 ReactHookEffectTags.js <a href="#t24434.5 ReactHookEffectTags.js"> # </a></h3>
<p>src\react-reconciler\src\ReactHookEffectTags.js</p>
<pre><code class="lang-diff">export const HasEffect = 0b0001;
export const Passive = 0b1000;
<span class="hljs-addition">+export const Layout = 0b0100;</span>
</code></pre>
<h3 id="t24534.6 ReactFiberFlags.js">34.6 ReactFiberFlags.js <a href="#t24534.6 ReactFiberFlags.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberFlags.js</p>
<pre><code class="lang-diff">export const NoFlags = 0b00000000000000000000000000;
export const Placement = 0b00000000000000000000000010;
export const Update = 0b00000000000000000000000100;
export const ChildDeletion = 0b00000000000000000000001000;
export const MutationMask = Placement | Update;
export const Passive = 0b00000000000000010000000000;
<span class="hljs-addition">+export const LayoutMask = Update;</span>
</code></pre>
<h3 id="t24634.7 ReactFiberHooks.js">34.7 ReactFiberHooks.js <a href="#t24634.7 ReactFiberHooks.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberHooks.js</p>
<pre><code class="lang-diff">import ReactSharedInternals from &quot;shared/ReactSharedInternals&quot;;
import { enqueueConcurrentHookUpdate } from &quot;./ReactFiberConcurrentUpdates&quot;;
import { scheduleUpdateOnFiber } from &quot;./ReactFiberWorkLoop&quot;;
import is from &quot;shared/objectIs&quot;;
<span class="hljs-addition">+import { Passive as PassiveEffect, Update as UpdateEffect } from &quot;./ReactFiberFlags&quot;;</span>
<span class="hljs-addition">+import { HasEffect as HookHasEffect, Passive as HookPassive, Layout as HookLayout } from &quot;./ReactHookEffectTags&quot;;</span>

const { ReactCurrentDispatcher } = ReactSharedInternals;
let currentlyRenderingFiber = null;
let workInProgressHook = null;
let currentHook = null;

const HooksDispatcherOnMountInDEV = {
  useReducer: mountReducer,
  useState: mountState,
  useEffect: mountEffect,
<span class="hljs-addition">+ useLayoutEffect: mountLayoutEffect,</span>
};
const HooksDispatcherOnUpdateInDEV = {
  useReducer: updateReducer,
  useState: updateState,
  useEffect: updateEffect,
<span class="hljs-addition">+ useLayoutEffect: updateLayoutEffect,</span>
};
export function useLayoutEffect(reducer, initialArg) {
  return ReactCurrentDispatcher.current.useLayoutEffect(reducer, initialArg);
}
<span class="hljs-addition">+function updateLayoutEffect(create, deps) {</span>
<span class="hljs-addition">+  return updateEffectImpl(UpdateEffect, HookLayout, create, deps);</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+function mountLayoutEffect(create, deps) {</span>
<span class="hljs-addition">+  const fiberFlags = UpdateEffect;</span>
<span class="hljs-addition">+  return mountEffectImpl(fiberFlags, HookLayout, create, deps);</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+function updateEffect(create, deps) {</span>
<span class="hljs-addition">+  return updateEffectImpl(PassiveEffect, HookPassive, create, deps);</span>
<span class="hljs-addition">+}</span>
function updateEffectImpl(fiberFlags, hookFlags, create, deps) {
  const hook = updateWorkInProgressHook();
  const nextDeps = deps <span class="hljs-comment">=== undefined ? null : deps;</span>
  let destroy;
  if (currentHook !== null) {
    const prevEffect = currentHook.memoizedState;
    destroy = prevEffect.destroy;
    if (nextDeps !== null) {
      const prevDeps = prevEffect.deps;
      if (areHookInputsEqual(nextDeps, prevDeps)) {
        hook.memoizedState = pushEffect(hookFlags, create, destroy, nextDeps);
        return;
      }
    }
  }
  currentlyRenderingFiber.flags |= fiberFlags;
  hook.memoizedState = pushEffect(HookHasEffect | hookFlags, create, destroy, nextDeps);
}
function areHookInputsEqual(nextDeps, prevDeps) {
  if (prevDeps <span class="hljs-comment">=== null) {</span>
    return false;
  }
  for (let i = 0; i &lt; prevDeps.length &amp;&amp; i &lt; nextDeps.length; i++) {
    if (is(nextDeps[i], prevDeps[i])) {
      continue;
    }
    return false;
  }

  return true;
}
function mountEffect(create, deps) {
  return mountEffectImpl(PassiveEffect, HookPassive, create, deps);
}
function mountEffectImpl(fiberFlags, hookFlags, create, deps) {
  const hook = mountWorkInProgressHook();
  const nextDeps = deps <span class="hljs-comment">=== undefined ? null : deps;</span>
  currentlyRenderingFiber.flags |= fiberFlags;
  hook.memoizedState = pushEffect(HookHasEffect | hookFlags, create, undefined, nextDeps);
}
function pushEffect(tag, create, destroy, deps) {
  const effect = {
    tag,
    create,
    destroy,
    deps,
    next: null,
  };
  let componentUpdateQueue = currentlyRenderingFiber.updateQueue;
  if (componentUpdateQueue <span class="hljs-comment">=== null) {</span>
    componentUpdateQueue = createFunctionComponentUpdateQueue();
    currentlyRenderingFiber.updateQueue = componentUpdateQueue;
    componentUpdateQueue.lastEffect = effect.next = effect;
  } else {
    const lastEffect = componentUpdateQueue.lastEffect;
    if (lastEffect <span class="hljs-comment">=== null) {</span>
      componentUpdateQueue.lastEffect = effect.next = effect;
    } else {
      const firstEffect = lastEffect.next;
      lastEffect.next = effect;
      effect.next = firstEffect;
      componentUpdateQueue.lastEffect = effect;
    }
  }
  return effect;
}
function createFunctionComponentUpdateQueue() {
  return {
    lastEffect: null,
  };
}
function basicStateReducer(state, action) {
  return typeof action <span class="hljs-comment">=== &quot;function&quot; ? action(state) : action;</span>
}
function mountReducer(reducer, initialArg) {
  const hook = mountWorkInProgressHook();
  hook.memoizedState = initialArg;
  const queue = {
    pending: null,
    dispatch: null,
  };
  hook.queue = queue;
  const dispatch = (queue.dispatch = dispatchReducerAction.bind(null, currentlyRenderingFiber, queue));
  return [hook.memoizedState, dispatch];
}
function updateReducer(reducer) {
  const hook = updateWorkInProgressHook();
  const queue = hook.queue;
  queue.lastRenderedReducer = reducer;
  const current = currentHook;
  const pendingQueue = queue.pending;
  let baseQueue = null;
  let newState = current.memoizedState;
  if (pendingQueue !== null) {
    baseQueue = pendingQueue;
    queue.pending = null;
  }
  if (baseQueue !== null) {
    const first = baseQueue.next;
    let update = first;
    do {
      if (update.hasEagerState) {
        newState = update.eagerState;
      } else {
        const action = update.action;
        newState = reducer(newState, action);
      }
      update = update.next;
    } while (update !== null &amp;&amp; update !== first);
  }
  hook.memoizedState = newState;
  queue.lastRenderedState = newState;
  const dispatch = queue.dispatch;
  return [hook.memoizedState, dispatch];
}
function mountState(initialState) {
  const hook = mountWorkInProgressHook();
  hook.memoizedState = initialState;
  const queue = {
    pending: null,
    dispatch: null,
    lastRenderedReducer: basicStateReducer,
    lastRenderedState: initialState,
  };
  hook.queue = queue;
  const dispatch = (queue.dispatch = dispatchSetState.bind(null, currentlyRenderingFiber, queue));
  return [hook.memoizedState, dispatch];
}
function dispatchSetState(fiber, queue, action) {
  const update = {
    action,
    hasEagerState: false,
    eagerState: null,
    next: null,
  };
  const lastRenderedReducer = queue.lastRenderedReducer;
  const currentState = queue.lastRenderedState;
  const eagerState = lastRenderedReducer(currentState, action);
  update.hasEagerState = true;
  update.eagerState = eagerState;
  if (is(eagerState, currentState)) {
    return;
  }
  const root = enqueueConcurrentHookUpdate(fiber, queue, update);
  scheduleUpdateOnFiber(root, fiber);
}
function updateState(initialState) {
  return updateReducer(basicStateReducer, initialState);
}
function mountWorkInProgressHook() {
  const hook = {
    memoizedState: null,
    queue: null,
    next: null,
  };
  if (workInProgressHook <span class="hljs-comment">=== null) {</span>
    currentlyRenderingFiber.memoizedState = workInProgressHook = hook;
  } else {
    workInProgressHook = workInProgressHook.next = hook;
  }
  return workInProgressHook;
}
function dispatchReducerAction(fiber, queue, action) {
  const update = {
    action,
    next: null,
  };
  const root = enqueueConcurrentHookUpdate(fiber, queue, update);
  scheduleUpdateOnFiber(root, fiber);
}

function updateWorkInProgressHook() {
  let nextCurrentHook;
  if (currentHook <span class="hljs-comment">=== null) {</span>
    const current = currentlyRenderingFiber.alternate;
    if (current !== null) {
      nextCurrentHook = current.memoizedState;
    } else {
      nextCurrentHook = null;
    }
  } else {
    nextCurrentHook = currentHook.next;
  }

  let nextWorkInProgressHook;
  if (workInProgressHook <span class="hljs-comment">=== null) {</span>
    nextWorkInProgressHook = currentlyRenderingFiber.memoizedState;
  } else {
    nextWorkInProgressHook = workInProgressHook.next;
  }

  if (nextWorkInProgressHook !== null) {
    workInProgressHook = nextWorkInProgressHook;
    nextWorkInProgressHook = workInProgressHook.next;
    currentHook = nextCurrentHook;
  } else {
    currentHook = nextCurrentHook;
    const newHook = {
      memoizedState: currentHook.memoizedState,
      queue: currentHook.queue,
      next: null,
    };
    if (workInProgressHook <span class="hljs-comment">=== null) {</span>
      currentlyRenderingFiber.memoizedState = workInProgressHook = newHook;
    } else {
      workInProgressHook = workInProgressHook.next = newHook;
    }
  }
  return workInProgressHook;
}

export function renderWithHooks(current, workInProgress, Component, props) {
  currentlyRenderingFiber = workInProgress;
  workInProgress.updateQueue = null;
  workInProgress.memoizedState = null;
  if (current !== null &amp;&amp; current.memoizedState !== null) {
    ReactCurrentDispatcher.current = HooksDispatcherOnUpdateInDEV;
  } else {
    ReactCurrentDispatcher.current = HooksDispatcherOnMountInDEV;
  }
  const children = Component(props);
  currentlyRenderingFiber = null;
  workInProgressHook = null;
  currentHook = null;
  return children;
}

</code></pre>
<h3 id="t24734.8 ReactFiberWorkLoop.js">34.8 ReactFiberWorkLoop.js <a href="#t24734.8 ReactFiberWorkLoop.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberWorkLoop.js</p>
<pre><code class="lang-diff">import { scheduleCallback } from &quot;scheduler&quot;;
import { createWorkInProgress } from &quot;./ReactFiber&quot;;
import { beginWork } from &quot;./ReactFiberBeginWork&quot;;
import { completeWork } from &quot;./ReactFiberCompleteWork&quot;;
import { MutationMask, NoFlags, Placement, Update, ChildDeletion, Passive } from &quot;./ReactFiberFlags&quot;;
import {
  commitMutationEffects,
  commitPassiveUnmountEffects,
  commitPassiveMountEffects,
<span class="hljs-addition">+  commitLayoutEffects,</span>
} from &quot;./ReactFiberCommitWork&quot;;
import { finishQueueingConcurrentUpdates } from &quot;./ReactFiberConcurrentUpdates&quot;;
import { FunctionComponent, IndeterminateComponent, HostRoot, HostComponent, HostText } from &quot;./ReactWorkTags&quot;;

let workInProgress = null;
let rootDoesHavePassiveEffects = false;
let rootWithPendingPassiveEffects = null;
export function scheduleUpdateOnFiber(root) {
  ensureRootIsScheduled(root);
}
function ensureRootIsScheduled(root) {
  scheduleCallback(performConcurrentWorkOnRoot.bind(null, root));
}
function performConcurrentWorkOnRoot(root) {
  renderRootSync(root);
  const finishedWork = root.current.alternate;
  printFiber(finishedWork);
  console.log(`~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`);
  root.finishedWork = finishedWork;
  commitRoot(root);
}
export function flushPassiveEffects() {
  if (rootWithPendingPassiveEffects !== null) {
    const root = rootWithPendingPassiveEffects;
    commitPassiveUnmountEffects(root.current);
    commitPassiveMountEffects(root, root.current);
  }
}
function commitRoot(root) {
  const { finishedWork } = root;
  if ((finishedWork.subtreeFlags &amp; Passive) !== NoFlags || (finishedWork.flags &amp; Passive) !== NoFlags) {
    if (!rootDoesHavePassiveEffects) {
      rootDoesHavePassiveEffects = true;
      scheduleCallback(flushPassiveEffects);
    }
  }
  const subtreeHasEffects = (finishedWork.subtreeFlags &amp; MutationMask) !== NoFlags;
  const rootHasEffect = (finishedWork.flags &amp; MutationMask) !== NoFlags;
  if (subtreeHasEffects || rootHasEffect) {
    commitMutationEffects(finishedWork, root);
<span class="hljs-addition">+   commitLayoutEffects(finishedWork, root);</span>
    root.current = finishedWork;
    if (rootDoesHavePassiveEffects) {
      rootDoesHavePassiveEffects = false;
      rootWithPendingPassiveEffects = root;
    }
  }
  root.current = finishedWork;
}
function prepareFreshStack(root) {
  workInProgress = createWorkInProgress(root.current, null);
  finishQueueingConcurrentUpdates();
}
function renderRootSync(root) {
  prepareFreshStack(root);
  workLoopSync();
}

function workLoopSync() {
  while (workInProgress !== null) {
    performUnitOfWork(workInProgress);
  }
}
function performUnitOfWork(unitOfWork) {
  const current = unitOfWork.alternate;
  const next = beginWork(current, unitOfWork);
  unitOfWork.memoizedProps = unitOfWork.pendingProps;
  if (next <span class="hljs-comment">=== null) {</span>
    completeUnitOfWork(unitOfWork);
  } else {
    workInProgress = next;
  }
}

function completeUnitOfWork(unitOfWork) {
  let completedWork = unitOfWork;
  do {
    const current = completedWork.alternate;
    const returnFiber = completedWork.return;
    completeWork(current, completedWork);
    const siblingFiber = completedWork.sibling;
    if (siblingFiber !== null) {
      workInProgress = siblingFiber;
      return;
    }
    completedWork = returnFiber;
    workInProgress = completedWork;
  } while (completedWork !== null);
}

function printFiber(fiber) {
  /*
  fiber.flags &amp;= ~Forked;
  fiber.flags &amp;= ~PlacementDEV;
  fiber.flags &amp;= ~Snapshot;
  fiber.flags &amp;= ~PerformedWork;
  */
  if (fiber.flags !== 0) {
    console.log(
      getFlags(fiber.flags),
      getTag(fiber.tag),
      typeof fiber.type <span class="hljs-comment">=== &quot;function&quot; ? fiber.type.name : fiber.type,</span>
      fiber.memoizedProps
    );
    if (fiber.deletions) {
      for (let i = 0; i &lt; fiber.deletions.length; i++) {
        const childToDelete = fiber.deletions[i];
        console.log(getTag(childToDelete.tag), childToDelete.type, childToDelete.memoizedProps);
      }
    }
  }
  let child = fiber.child;
  while (child) {
    printFiber(child);
    child = child.sibling;
  }
}
function getTag(tag) {
  switch (tag) {
    case FunctionComponent:
      return `FunctionComponent`;
    case HostRoot:
      return `HostRoot`;
    case HostComponent:
      return `HostComponent`;
    case HostText:
      return HostText;
    default:
      return tag;
  }
}
function getFlags(flags) {
  if (flags <span class="hljs-comment">=== (Update | Placement | ChildDeletion)) {</span>
    return `&#x81EA;&#x5DF1;&#x79FB;&#x52A8;&#x548C;&#x5B50;&#x5143;&#x7D20;&#x6709;&#x5220;&#x9664;`;
  }
  if (flags <span class="hljs-comment">=== (ChildDeletion | Update)) {</span>
    return `&#x81EA;&#x5DF1;&#x6709;&#x66F4;&#x65B0;&#x548C;&#x5B50;&#x5143;&#x7D20;&#x6709;&#x5220;&#x9664;`;
  }
  if (flags <span class="hljs-comment">=== ChildDeletion) {</span>
    return `&#x5B50;&#x5143;&#x7D20;&#x6709;&#x5220;&#x9664;`;
  }
  if (flags <span class="hljs-comment">=== (Placement | Update)) {</span>
    return `&#x79FB;&#x52A8;&#x5E76;&#x66F4;&#x65B0;`;
  }
  if (flags <span class="hljs-comment">=== Placement) {</span>
    return `&#x63D2;&#x5165;`;
  }
  if (flags <span class="hljs-comment">=== Update) {</span>
    return `&#x66F4;&#x65B0;`;
  }
  return flags;
}

</code></pre>
<h3 id="t24834.9 ReactFiberCommitWork.js">34.9 ReactFiberCommitWork.js <a href="#t24834.9 ReactFiberCommitWork.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberCommitWork.js</p>
<pre><code class="lang-diff">import { HostRoot, HostComponent, HostText, FunctionComponent } from &quot;./ReactWorkTags&quot;;
<span class="hljs-addition">+import { Passive, MutationMask, Placement, Update, LayoutMask } from &quot;./ReactFiberFlags&quot;;</span>
import { insertBefore, appendChild, commitUpdate, removeChild } from &quot;react-dom-bindings/src/client/ReactDOMHostConfig&quot;;
<span class="hljs-addition">+import { HasEffect as HookHasEffect, Passive as HookPassive, Layout as HookLayout } from &quot;./ReactHookEffectTags&quot;;</span>

export function commitMutationEffects(finishedWork, root) {
  commitMutationEffectsOnFiber(finishedWork, root);
}
export function commitPassiveUnmountEffects(finishedWork) {
  commitPassiveUnmountOnFiber(finishedWork);
}
function commitPassiveUnmountOnFiber(finishedWork) {
  switch (finishedWork.tag) {
    case FunctionComponent: {
      recursivelyTraversePassiveUnmountEffects(finishedWork);
      if (finishedWork.flags &amp; Passive) {
        commitHookPassiveUnmountEffects(finishedWork, finishedWork.return, HookPassive | HookHasEffect);
      }
      break;
    }
    default: {
      recursivelyTraversePassiveUnmountEffects(finishedWork);
      break;
    }
  }
}
function recursivelyTraversePassiveUnmountEffects(parentFiber) {
  if (parentFiber.subtreeFlags &amp; Passive) {
    let child = parentFiber.child;
    while (child !== null) {
      commitPassiveUnmountOnFiber(child);
      child = child.sibling;
    }
  }
}
function commitHookPassiveUnmountEffects(finishedWork, nearestMountedAncestor, hookFlags) {
  commitHookEffectListUnmount(hookFlags, finishedWork, nearestMountedAncestor);
}

function commitHookEffectListUnmount(flags, finishedWork) {
  const updateQueue = finishedWork.updateQueue;
  const lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;
  if (lastEffect !== null) {
    const firstEffect = lastEffect.next;
    let effect = firstEffect;
    do {
      if ((effect.tag &amp; flags) <span class="hljs-comment">=== flags) {</span>
        const destroy = effect.destroy;
        effect.destroy = undefined;
        if (destroy !== undefined) {
          destroy();
        }
      }
      effect = effect.next;
    } while (effect !== firstEffect);
  }
}

export function commitPassiveMountEffects(root, finishedWork) {
  commitPassiveMountOnFiber(root, finishedWork);
}
function commitPassiveMountOnFiber(finishedRoot, finishedWork) {
  const flags = finishedWork.flags;
  switch (finishedWork.tag) {
    case FunctionComponent: {
      recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork);
      if (flags &amp; Passive) {
        commitHookPassiveMountEffects(finishedWork, HookPassive | HookHasEffect);
      }
      break;
    }
    case HostRoot: {
      recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork);
      break;
    }
    default:
      break;
  }
}
function commitHookPassiveMountEffects(finishedWork, hookFlags) {
  commitHookEffectListMount(hookFlags, finishedWork);
}
function commitHookEffectListMount(flags, finishedWork) {
  const updateQueue = finishedWork.updateQueue;
  const lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;
  if (lastEffect !== null) {
    const firstEffect = lastEffect.next;
    let effect = firstEffect;
    do {
      if ((effect.tag &amp; flags) <span class="hljs-comment">=== flags) {</span>
        const create = effect.create;
        effect.destroy = create();
      }
      effect = effect.next;
    } while (effect !== firstEffect);
  }
}
function recursivelyTraversePassiveMountEffects(root, parentFiber) {
  if (parentFiber.subtreeFlags &amp; Passive) {
    let child = parentFiber.child;
    while (child !== null) {
      commitPassiveMountOnFiber(root, child);
      child = child.sibling;
    }
  }
}
let hostParent = null;
function commitDeletionEffects(root, returnFiber, deletedFiber) {
  let parent = returnFiber;
  findParent: while (parent !== null) {
    switch (parent.tag) {
      case HostComponent: {
        hostParent = parent.stateNode;
        break findParent;
      }
      case HostRoot: {
        hostParent = parent.stateNode.containerInfo;
        break findParent;
      }
      default:
        break;
    }
    parent = parent.return;
  }
  commitDeletionEffectsOnFiber(root, returnFiber, deletedFiber);
  hostParent = null;
}
function commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, deletedFiber) {
  switch (deletedFiber.tag) {
    case HostComponent:
    case HostText: {
      recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
      if (hostParent !== null) {
        removeChild(hostParent, deletedFiber.stateNode);
      }
      break;
    }
    default:
      break;
  }
}
function recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, parent) {
  let child = parent.child;
  while (child !== null) {
    commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, child);
    child = child.sibling;
  }
}
function recursivelyTraverseMutationEffects(root, parentFiber) {
  const deletions = parentFiber.deletions;
  if (deletions !== null) {
    for (let i = 0; i &lt; deletions.length; i++) {
      const childToDelete = deletions[i];
      commitDeletionEffects(root, parentFiber, childToDelete);
    }
  }
  if (parentFiber.subtreeFlags &amp; MutationMask) {
    let { child } = parentFiber;
    while (child !== null) {
      commitMutationEffectsOnFiber(child, root);
      child = child.sibling;
    }
  }
}
function isHostParent(fiber) {
  return fiber.tag <span class="hljs-comment">=== HostComponent || fiber.tag === HostRoot;</span>
}
function getHostParentFiber(fiber) {
  let parent = fiber.return;
  while (parent !== null) {
    if (isHostParent(parent)) {
      return parent;
    }
    parent = parent.return;
  }
  return parent;
}
function insertOrAppendPlacementNode(node, before, parent) {
  const { tag } = node;
  const isHost = tag <span class="hljs-comment">=== HostComponent || tag === HostText;</span>
  if (isHost) {
    const { stateNode } = node;
    if (before) {
      insertBefore(parent, stateNode, before);
    } else {
      appendChild(parent, stateNode);
    }
  } else {
    const { child } = node;
    if (child !== null) {
      insertOrAppendPlacementNode(child, before, parent);
      let { sibling } = child;
      while (sibling !== null) {
        insertOrAppendPlacementNode(sibling, before, parent);
        sibling = sibling.sibling;
      }
    }
  }
}
function getHostSibling(fiber) {
  let node = fiber;
  siblings: while (true) {
    // &#x5982;&#x679C;&#x6211;&#x4EEC;&#x6CA1;&#x6709;&#x627E;&#x5230;&#x4EFB;&#x4F55;&#x4E1C;&#x897F;&#xFF0C;&#x8BA9;&#x6211;&#x4EEC;&#x8BD5;&#x8BD5;&#x4E0B;&#x4E00;&#x4E2A;&#x5F1F;&#x5F1F;
    while (node.sibling <span class="hljs-comment">=== null) {</span>
      if (node.return <span class="hljs-comment">=== null || isHostParent(node.return)) {</span>
        // &#x5982;&#x679C;&#x6211;&#x4EEC;&#x662F;&#x6839;Fiber&#x6216;&#x8005;&#x7236;&#x4EB2;&#x662F;&#x539F;&#x751F;&#x8282;&#x70B9;&#xFF0C;&#x6211;&#x4EEC;&#x5C31;&#x662F;&#x6700;&#x540E;&#x7684;&#x5F1F;&#x5F1F;
        return null;
      }
      node = node.return;
    }
    // node.sibling.return = node.return
    node = node.sibling;
    while (node.tag !== HostComponent &amp;&amp; node.tag !== HostText) {
      // &#x5982;&#x679C;&#x5B83;&#x4E0D;&#x662F;&#x539F;&#x751F;&#x8282;&#x70B9;&#xFF0C;&#x5E76;&#x4E14;&#xFF0C;&#x6211;&#x4EEC;&#x53EF;&#x80FD;&#x5728;&#x5176;&#x4E2D;&#x6709;&#x4E00;&#x4E2A;&#x539F;&#x751F;&#x8282;&#x70B9;
      // &#x8BD5;&#x7740;&#x5411;&#x4E0B;&#x641C;&#x7D22;&#xFF0C;&#x76F4;&#x5230;&#x627E;&#x5230;&#x4E3A;&#x6B62;
      if (node.flags &amp; Placement) {
        // &#x5982;&#x679C;&#x6211;&#x4EEC;&#x6CA1;&#x6709;&#x5B69;&#x5B50;&#xFF0C;&#x53EF;&#x4EE5;&#x8BD5;&#x8BD5;&#x5F1F;&#x5F1F;
        continue siblings;
      } else {
        // node.child.return = node
        node = node.child;
      }
    } // Check if this host node is stable or about to be placed.
    // &#x68C0;&#x67E5;&#x6B64;&#x539F;&#x751F;&#x8282;&#x70B9;&#x662F;&#x5426;&#x7A33;&#x5B9A;&#x53EF;&#x4EE5;&#x653E;&#x7F6E;
    if (!(node.flags &amp; Placement)) {
      // &#x627E;&#x5230;&#x5B83;&#x4E86;!
      return node.stateNode;
    }
  }
}
function commitPlacement(finishedWork) {
  const parentFiber = getHostParentFiber(finishedWork);
  switch (parentFiber.tag) {
    case HostComponent: {
      const parent = parentFiber.stateNode;
      const before = getHostSibling(finishedWork);
      insertOrAppendPlacementNode(finishedWork, before, parent);
      break;
    }
    case HostRoot: {
      const parent = parentFiber.stateNode.containerInfo;
      const before = getHostSibling(finishedWork);
      insertOrAppendPlacementNode(finishedWork, before, parent);
      break;
    }
    default:
      break;
  }
}
function commitReconciliationEffects(finishedWork) {
  const { flags } = finishedWork;
  if (flags &amp; Placement) {
    commitPlacement(finishedWork);
    finishedWork.flags &amp;= ~Placement;
  }
}
export function commitMutationEffectsOnFiber(finishedWork, root) {
  const current = finishedWork.alternate;
  const flags = finishedWork.flags;
  switch (finishedWork.tag) {
    case HostRoot: {
      recursivelyTraverseMutationEffects(root, finishedWork);
      commitReconciliationEffects(finishedWork);
      break;
    }
    case FunctionComponent: {
      recursivelyTraverseMutationEffects(root, finishedWork);
      commitReconciliationEffects(finishedWork);
<span class="hljs-addition">+     if (flags &amp; Update) {</span>
<span class="hljs-addition">+       commitHookEffectListUnmount(HookLayout | HookHasEffect, finishedWork, finishedWork.return);</span>
<span class="hljs-addition">+     }</span>
      break;
    }
    case HostComponent: {
      recursivelyTraverseMutationEffects(root, finishedWork);
      commitReconciliationEffects(finishedWork);
      if (flags &amp; Update) {
        const instance = finishedWork.stateNode;
        if (instance != null) {
          const newProps = finishedWork.memoizedProps;
          const oldProps = current !== null ? current.memoizedProps : newProps;
          const type = finishedWork.type;
          const updatePayload = finishedWork.updateQueue;
          finishedWork.updateQueue = null;
          if (updatePayload !== null) {
            commitUpdate(instance, updatePayload, type, oldProps, newProps, finishedWork);
          }
        }
      }
      break;
    }
    case HostText: {
      recursivelyTraverseMutationEffects(root, finishedWork);
      commitReconciliationEffects(finishedWork);
      break;
    }
    default: {
      break;
    }
  }
}

<span class="hljs-addition">+export function commitLayoutEffects(finishedWork, root) {</span>
<span class="hljs-addition">+  const current = finishedWork.alternate;</span>
<span class="hljs-addition">+  commitLayoutEffectOnFiber(root, current, finishedWork);</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+function commitLayoutEffectOnFiber(finishedRoot, current, finishedWork) {</span>
<span class="hljs-addition">+  const flags = finishedWork.flags;</span>
<span class="hljs-addition">+  switch (finishedWork.tag) {</span>
<span class="hljs-addition">+    case FunctionComponent: {</span>
<span class="hljs-addition">+      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);</span>
<span class="hljs-addition">+      if (flags &amp; Update) {</span>
<span class="hljs-addition">+        commitHookLayoutEffects(finishedWork, HookLayout | HookHasEffect);</span>
<span class="hljs-addition">+      }</span>
<span class="hljs-addition">+      break;</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+    case HostRoot: {</span>
<span class="hljs-addition">+      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);</span>
<span class="hljs-addition">+      break;</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+    default:</span>
<span class="hljs-addition">+      break;</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+function recursivelyTraverseLayoutEffects(root, parentFiber) {</span>
<span class="hljs-addition">+  if (parentFiber.subtreeFlags &amp; LayoutMask) {</span>
<span class="hljs-addition">+    let child = parentFiber.child;</span>
<span class="hljs-addition">+    while (child !== null) {</span>
<span class="hljs-addition">+      const current = child.alternate;</span>
<span class="hljs-addition">+      commitLayoutEffectOnFiber(root, current, child);</span>
<span class="hljs-addition">+      child = child.sibling;</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+function commitHookLayoutEffects(finishedWork, hookFlags) {</span>
<span class="hljs-addition">+  commitHookEffectListMount(hookFlags, finishedWork);</span>
<span class="hljs-addition">+}</span>

</code></pre>
<h2 id="t24935.Scheduler_scheduleCallback">35.Scheduler_scheduleCallback <a href="#t24935.Scheduler_scheduleCallback"> # </a></h2>
<p><img src="./assets/img/34f7eaa3b83b104bba0eb3cc8b23346f.jpg" alt></p>
<p><img src="./assets/img/c1b3cb344bdc3d70d3babc975901a604.jpg" alt></p>
<h3 id="t25035.1 ReactFiberWorkLoop.js">35.1 ReactFiberWorkLoop.js <a href="#t25035.1 ReactFiberWorkLoop.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberWorkLoop.js</p>
<pre><code class="lang-diff"><span class="hljs-addition">+import { NormalPriority as NormalSchedulerPriority, scheduleCallback as Scheduler_scheduleCallback } from &quot;./Scheduler&quot;;</span>
import { createWorkInProgress } from &quot;./ReactFiber&quot;;
import { beginWork } from &quot;./ReactFiberBeginWork&quot;;
import { completeWork } from &quot;./ReactFiberCompleteWork&quot;;
import { MutationMask, NoFlags, Placement, Update, ChildDeletion, Passive } from &quot;./ReactFiberFlags&quot;;
import {
  commitMutationEffects,
  commitPassiveUnmountEffects,
  commitPassiveMountEffects,
  commitLayoutEffects,
} from &quot;./ReactFiberCommitWork&quot;;
import { finishQueueingConcurrentUpdates } from &quot;./ReactFiberConcurrentUpdates&quot;;
import { FunctionComponent, IndeterminateComponent, HostRoot, HostComponent, HostText } from &quot;./ReactWorkTags&quot;;

let workInProgress = null;
let rootDoesHavePassiveEffects = false;
let rootWithPendingPassiveEffects = null;
export function scheduleUpdateOnFiber(root) {
  ensureRootIsScheduled(root);
}
function ensureRootIsScheduled(root) {
<span class="hljs-addition">+ Scheduler_scheduleCallback(NormalSchedulerPriority, performConcurrentWorkOnRoot.bind(null, root));</span>
}
function performConcurrentWorkOnRoot(root) {
  renderRootSync(root);
  const finishedWork = root.current.alternate;
  printFiber(finishedWork);
  console.log(`~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`);
  root.finishedWork = finishedWork;
  commitRoot(root);
}
export function flushPassiveEffects() {
  if (rootWithPendingPassiveEffects !== null) {
    const root = rootWithPendingPassiveEffects;
    commitPassiveUnmountEffects(root.current);
    commitPassiveMountEffects(root, root.current);
  }
}
function commitRoot(root) {
  const { finishedWork } = root;
  if ((finishedWork.subtreeFlags &amp; Passive) !== NoFlags || (finishedWork.flags &amp; Passive) !== NoFlags) {
    if (!rootDoesHavePassiveEffects) {
      rootDoesHavePassiveEffects = true;
<span class="hljs-addition">+     Scheduler_scheduleCallback(NormalSchedulerPriority, flushPassiveEffects);</span>
    }
  }
  const subtreeHasEffects = (finishedWork.subtreeFlags &amp; MutationMask) !== NoFlags;
  const rootHasEffect = (finishedWork.flags &amp; MutationMask) !== NoFlags;
  if (subtreeHasEffects || rootHasEffect) {
    commitMutationEffects(finishedWork, root);
    commitLayoutEffects(finishedWork, root);
    root.current = finishedWork;
    if (rootDoesHavePassiveEffects) {
      rootDoesHavePassiveEffects = false;
      rootWithPendingPassiveEffects = root;
    }
  }
  root.current = finishedWork;
}
function prepareFreshStack(root) {
  workInProgress = createWorkInProgress(root.current, null);
  finishQueueingConcurrentUpdates();
}
function renderRootSync(root) {
  prepareFreshStack(root);
  workLoopSync();
}

function workLoopSync() {
  while (workInProgress !== null) {
    performUnitOfWork(workInProgress);
  }
}
function performUnitOfWork(unitOfWork) {
  const current = unitOfWork.alternate;
  const next = beginWork(current, unitOfWork);
  unitOfWork.memoizedProps = unitOfWork.pendingProps;
  if (next <span class="hljs-comment">=== null) {</span>
    completeUnitOfWork(unitOfWork);
  } else {
    workInProgress = next;
  }
}

function completeUnitOfWork(unitOfWork) {
  let completedWork = unitOfWork;
  do {
    const current = completedWork.alternate;
    const returnFiber = completedWork.return;
    completeWork(current, completedWork);
    const siblingFiber = completedWork.sibling;
    if (siblingFiber !== null) {
      workInProgress = siblingFiber;
      return;
    }
    completedWork = returnFiber;
    workInProgress = completedWork;
  } while (completedWork !== null);
}

function printFiber(fiber) {
  /*
  fiber.flags &amp;= ~Forked;
  fiber.flags &amp;= ~PlacementDEV;
  fiber.flags &amp;= ~Snapshot;
  fiber.flags &amp;= ~PerformedWork;
  */
  if (fiber.flags !== 0) {
    console.log(
      getFlags(fiber.flags),
      getTag(fiber.tag),
      typeof fiber.type <span class="hljs-comment">=== &quot;function&quot; ? fiber.type.name : fiber.type,</span>
      fiber.memoizedProps
    );
    if (fiber.deletions) {
      for (let i = 0; i &lt; fiber.deletions.length; i++) {
        const childToDelete = fiber.deletions[i];
        console.log(getTag(childToDelete.tag), childToDelete.type, childToDelete.memoizedProps);
      }
    }
  }
  let child = fiber.child;
  while (child) {
    printFiber(child);
    child = child.sibling;
  }
}
function getTag(tag) {
  switch (tag) {
    case FunctionComponent:
      return `FunctionComponent`;
    case HostRoot:
      return `HostRoot`;
    case HostComponent:
      return `HostComponent`;
    case HostText:
      return HostText;
    default:
      return tag;
  }
}
function getFlags(flags) {
  if (flags <span class="hljs-comment">=== (Update | Placement | ChildDeletion)) {</span>
    return `&#x81EA;&#x5DF1;&#x79FB;&#x52A8;&#x548C;&#x5B50;&#x5143;&#x7D20;&#x6709;&#x5220;&#x9664;`;
  }
  if (flags <span class="hljs-comment">=== (ChildDeletion | Update)) {</span>
    return `&#x81EA;&#x5DF1;&#x6709;&#x66F4;&#x65B0;&#x548C;&#x5B50;&#x5143;&#x7D20;&#x6709;&#x5220;&#x9664;`;
  }
  if (flags <span class="hljs-comment">=== ChildDeletion) {</span>
    return `&#x5B50;&#x5143;&#x7D20;&#x6709;&#x5220;&#x9664;`;
  }
  if (flags <span class="hljs-comment">=== (Placement | Update)) {</span>
    return `&#x79FB;&#x52A8;&#x5E76;&#x66F4;&#x65B0;`;
  }
  if (flags <span class="hljs-comment">=== Placement) {</span>
    return `&#x63D2;&#x5165;`;
  }
  if (flags <span class="hljs-comment">=== Update) {</span>
    return `&#x66F4;&#x65B0;`;
  }
  return flags;
}

</code></pre>
<h3 id="t25135.2 Scheduler.js">35.2 Scheduler.js <a href="#t25135.2 Scheduler.js"> # </a></h3>
<p>src\react-reconciler\src\Scheduler.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> Scheduler <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;scheduler&quot;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> scheduleCallback = Scheduler.unstable_scheduleCallback;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> NormalPriority = Scheduler.unstable_NormalPriority;
</code></pre>
<h3 id="t25235.3 Scheduler.js">35.3 Scheduler.js <a href="#t25235.3 Scheduler.js"> # </a></h3>
<p>src\scheduler\src\forks\Scheduler.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">import</span> {
  ImmediatePriority,
  UserBlockingPriority,
  NormalPriority,
  LowPriority,
  IdlePriority,
} <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../SchedulerPriorities&quot;</span>;
<span class="hljs-keyword">import</span> { push, pop, peek } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../SchedulerMinHeap&quot;</span>;
<span class="hljs-keyword">import</span> { frameYieldMs } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../SchedulerFeatureFlags&quot;</span>;

<span class="hljs-keyword">const</span> maxSigned31BitInt = <span class="hljs-number">1073741823</span>;
<span class="hljs-keyword">const</span> IMMEDIATE_PRIORITY_TIMEOUT = <span class="hljs-number">-1</span>;
<span class="hljs-keyword">const</span> USER_BLOCKING_PRIORITY_TIMEOUT = <span class="hljs-number">250</span>;
<span class="hljs-keyword">const</span> NORMAL_PRIORITY_TIMEOUT = <span class="hljs-number">5000</span>;
<span class="hljs-keyword">const</span> LOW_PRIORITY_TIMEOUT = <span class="hljs-number">10000</span>;
<span class="hljs-keyword">const</span> IDLE_PRIORITY_TIMEOUT = maxSigned31BitInt;

<span class="hljs-keyword">const</span> taskQueue = [];
<span class="hljs-keyword">let</span> taskIdCounter = <span class="hljs-number">1</span>;
<span class="hljs-keyword">let</span> scheduledHostCallback = <span class="hljs-literal">null</span>;
<span class="hljs-keyword">let</span> startTime = <span class="hljs-number">-1</span>;
<span class="hljs-keyword">let</span> currentTask = <span class="hljs-literal">null</span>;
<span class="hljs-keyword">const</span> frameInterval = frameYieldMs;
<span class="hljs-keyword">const</span> channel = <span class="hljs-keyword">new</span> MessageChannel();
<span class="hljs-keyword">const</span> port = channel.port2;

<span class="hljs-keyword">const</span> getCurrentTime = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> performance.now();
channel.port1.onmessage = performWorkUntilDeadline;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">schedulePerformWorkUntilDeadline</span>(<span class="hljs-params"></span>) </span>{
  port.postMessage(<span class="hljs-literal">null</span>);
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">performWorkUntilDeadline</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">if</span> (scheduledHostCallback !== <span class="hljs-literal">null</span>) {
    startTime = getCurrentTime();
    <span class="hljs-keyword">let</span> hasMoreWork = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">try</span> {
      hasMoreWork = scheduledHostCallback(startTime);
    } <span class="hljs-keyword">finally</span> {
      <span class="hljs-keyword">if</span> (hasMoreWork) {
        schedulePerformWorkUntilDeadline();
      } <span class="hljs-keyword">else</span> {
        scheduledHostCallback = <span class="hljs-literal">null</span>;
      }
    }
  }
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">requestHostCallback</span>(<span class="hljs-params">callback</span>) </span>{
  scheduledHostCallback = callback;
  schedulePerformWorkUntilDeadline();
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unstable_scheduleCallback</span>(<span class="hljs-params">priorityLevel, callback</span>) </span>{
  <span class="hljs-keyword">const</span> currentTime = getCurrentTime();
  <span class="hljs-keyword">const</span> startTime = currentTime;
  <span class="hljs-keyword">let</span> timeout;
  <span class="hljs-keyword">switch</span> (priorityLevel) {
    <span class="hljs-keyword">case</span> ImmediatePriority:
      timeout = IMMEDIATE_PRIORITY_TIMEOUT;
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> UserBlockingPriority:
      timeout = USER_BLOCKING_PRIORITY_TIMEOUT;
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> IdlePriority:
      timeout = IDLE_PRIORITY_TIMEOUT;
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> LowPriority:
      timeout = LOW_PRIORITY_TIMEOUT;
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> NormalPriority:
    <span class="hljs-keyword">default</span>:
      timeout = NORMAL_PRIORITY_TIMEOUT;
      <span class="hljs-keyword">break</span>;
  }
  <span class="hljs-keyword">const</span> expirationTime = startTime + timeout;
  <span class="hljs-keyword">const</span> newTask = {
    <span class="hljs-attr">id</span>: taskIdCounter++,
    callback,
    priorityLevel,
    startTime,
    expirationTime,
    <span class="hljs-attr">sortIndex</span>: <span class="hljs-number">-1</span>,
  };
  newTask.sortIndex = expirationTime;
  push(taskQueue, newTask);
  requestHostCallback(flushWork);
  <span class="hljs-keyword">return</span> newTask;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flushWork</span>(<span class="hljs-params">initialTime</span>) </span>{
  <span class="hljs-keyword">return</span> workLoop(initialTime);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">shouldYieldToHost</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> timeElapsed = getCurrentTime() - startTime;
  <span class="hljs-keyword">if</span> (timeElapsed &lt; frameInterval) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  }
  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">workLoop</span>(<span class="hljs-params">initialTime</span>) </span>{
  <span class="hljs-keyword">let</span> currentTime = initialTime;
  currentTask = peek(taskQueue);
  <span class="hljs-keyword">while</span> (currentTask !== <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">if</span> (currentTask.expirationTime &gt; currentTime &amp;&amp; shouldYieldToHost()) {
      <span class="hljs-keyword">break</span>;
    }
    <span class="hljs-keyword">const</span> callback = currentTask.callback;
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> callback === <span class="hljs-string">&quot;function&quot;</span>) {
      currentTask.callback = <span class="hljs-literal">null</span>;
      <span class="hljs-keyword">const</span> didUserCallbackTimeout = currentTask.expirationTime &lt;= currentTime;
      <span class="hljs-keyword">const</span> continuationCallback = callback(didUserCallbackTimeout);
      currentTime = getCurrentTime();
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> continuationCallback === <span class="hljs-string">&quot;function&quot;</span>) {
        currentTask.callback = continuationCallback;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      }
      <span class="hljs-keyword">if</span> (currentTask === peek(taskQueue)) {
        pop(taskQueue);
      }
    } <span class="hljs-keyword">else</span> {
      pop(taskQueue);
    }
    currentTask = peek(taskQueue);
  }
  <span class="hljs-keyword">if</span> (currentTask !== <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }
  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
}

<span class="hljs-keyword">export</span> { NormalPriority <span class="hljs-keyword">as</span> unstable_NormalPriority, unstable_scheduleCallback };
</code></pre>
<h3 id="t25335.4 SchedulerFeatureFlags.js">35.4 SchedulerFeatureFlags.js <a href="#t25335.4 SchedulerFeatureFlags.js"> # </a></h3>
<p>src\scheduler\src\SchedulerFeatureFlags.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> frameYieldMs = <span class="hljs-number">5</span>;
</code></pre>
<h3 id="t25435.5 SchedulerMinHeap.js">35.5 SchedulerMinHeap.js <a href="#t25435.5 SchedulerMinHeap.js"> # </a></h3>
<p>src\scheduler\src\SchedulerMinHeap.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">push</span>(<span class="hljs-params">heap, node</span>) </span>{
  <span class="hljs-keyword">const</span> index = heap.length;
  heap.push(node);
  siftUp(heap, node, index);
}
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">peek</span>(<span class="hljs-params">heap</span>) </span>{
  <span class="hljs-keyword">return</span> heap.length === <span class="hljs-number">0</span> ? <span class="hljs-literal">null</span> : heap[<span class="hljs-number">0</span>];
}
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pop</span>(<span class="hljs-params">heap</span>) </span>{
  <span class="hljs-keyword">if</span> (heap.length === <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }
  <span class="hljs-keyword">const</span> first = heap[<span class="hljs-number">0</span>];
  <span class="hljs-keyword">const</span> last = heap.pop();
  <span class="hljs-keyword">if</span> (last !== first) {
    heap[<span class="hljs-number">0</span>] = last;
    siftDown(heap, last, <span class="hljs-number">0</span>);
  }
  <span class="hljs-keyword">return</span> first;
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">siftUp</span>(<span class="hljs-params">heap, node, i</span>) </span>{
  <span class="hljs-keyword">let</span> index = i;
  <span class="hljs-keyword">while</span> (index &gt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">const</span> parentIndex = (index - <span class="hljs-number">1</span>) &gt;&gt;&gt; <span class="hljs-number">1</span>;
    <span class="hljs-keyword">const</span> parent = heap[parentIndex];
    <span class="hljs-keyword">if</span> (compare(parent, node) &gt; <span class="hljs-number">0</span>) {
      heap[parentIndex] = node;
      heap[index] = parent;
      index = parentIndex;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span>;
    }
  }
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">siftDown</span>(<span class="hljs-params">heap, node, i</span>) </span>{
  <span class="hljs-keyword">let</span> index = i;
  <span class="hljs-keyword">const</span> length = heap.length;
  <span class="hljs-keyword">const</span> halfLength = length &gt;&gt;&gt; <span class="hljs-number">1</span>;
  <span class="hljs-keyword">while</span> (index &lt; halfLength) {
    <span class="hljs-keyword">const</span> leftIndex = (index + <span class="hljs-number">1</span>) * <span class="hljs-number">2</span> - <span class="hljs-number">1</span>;
    <span class="hljs-keyword">const</span> left = heap[leftIndex];
    <span class="hljs-keyword">const</span> rightIndex = leftIndex + <span class="hljs-number">1</span>;
    <span class="hljs-keyword">const</span> right = heap[rightIndex];
    <span class="hljs-keyword">if</span> (compare(left, node) &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">if</span> (rightIndex &lt; length &amp;&amp; compare(right, left) &lt; <span class="hljs-number">0</span>) {
        heap[index] = right;
        heap[rightIndex] = node;
        index = rightIndex;
      } <span class="hljs-keyword">else</span> {
        heap[index] = left;
        heap[leftIndex] = node;
        index = leftIndex;
      }
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rightIndex &lt; length &amp;&amp; compare(right, node) &lt; <span class="hljs-number">0</span>) {
      heap[index] = right;
      heap[rightIndex] = node;
      index = rightIndex;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span>;
    }
  }
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">compare</span>(<span class="hljs-params">a, b</span>) </span>{
  <span class="hljs-keyword">const</span> diff = a.sortIndex - b.sortIndex;
  <span class="hljs-keyword">return</span> diff !== <span class="hljs-number">0</span> ? diff : a.id - b.id;
}
</code></pre>
<h3 id="t25535.6 SchedulerPriorities.js">35.6 SchedulerPriorities.js <a href="#t25535.6 SchedulerPriorities.js"> # </a></h3>
<p>src\scheduler\src\SchedulerPriorities.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> NoPriority = <span class="hljs-number">0</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> ImmediatePriority = <span class="hljs-number">1</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> UserBlockingPriority = <span class="hljs-number">2</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> NormalPriority = <span class="hljs-number">3</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> LowPriority = <span class="hljs-number">4</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> IdlePriority = <span class="hljs-number">5</span>;
</code></pre>
<h2 id="t25636.&#x521D;&#x6B21;&#x6E32;&#x67D3;">36.&#x521D;&#x6B21;&#x6E32;&#x67D3; <a href="#t25636.&#x521D;&#x6B21;&#x6E32;&#x67D3;"> # </a></h2>
<p><img src="./assets/img/78de3f347c60f2e7aaf79ed1b5150ae7.jpg" alt></p>
<h3 id="t25736.1 src\main.jsx">36.1 src\main.jsx <a href="#t25736.1 src\main.jsx"> # </a></h3>
<p>src\main.jsx</p>
<pre><code class="lang-diff">import * as React from &quot;react&quot;;
import { createRoot } from &quot;react-dom/client&quot;;
<span class="hljs-addition">+let element = &lt;h1&gt;hello&lt;/h1&gt;;</span>
const root = createRoot(document.getElementById(&quot;root&quot;));
root.render(element);
</code></pre>
<h3 id="t25836.2  ReactFiberReconciler.js">36.2  ReactFiberReconciler.js <a href="#t25836.2  ReactFiberReconciler.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberReconciler.js</p>
<pre><code class="lang-diff">import { createFiberRoot } from &quot;./ReactFiberRoot&quot;;
import { createUpdate, enqueueUpdate } from &quot;./ReactFiberClassUpdateQueue&quot;;
<span class="hljs-addition">+import { scheduleUpdateOnFiber, requestUpdateLane } from &quot;./ReactFiberWorkLoop&quot;;</span>
export function createContainer(containerInfo) {
  return createFiberRoot(containerInfo);
}
export function updateContainer(element, container) {
  const current = container.current;
<span class="hljs-addition">+ const lane = requestUpdateLane(current);</span>
<span class="hljs-addition">+ const update = createUpdate(lane);</span>
  update.payload = { element };
<span class="hljs-addition">+ const root = enqueueUpdate(current, update, lane);</span>
<span class="hljs-addition">+ scheduleUpdateOnFiber(root, current, lane);</span>
}
</code></pre>
<h3 id="t25936.3  ReactFiberClassUpdateQueue.js">36.3  ReactFiberClassUpdateQueue.js <a href="#t25936.3  ReactFiberClassUpdateQueue.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberClassUpdateQueue.js</p>
<pre><code class="lang-diff">import assign from &quot;shared/assign&quot;;
<span class="hljs-addition">+import { enqueueConcurrentClassUpdate } from &apos;./ReactFiberConcurrentUpdates&apos;</span>
<span class="hljs-addition">+import { mergeLanes, NoLanes, NoLane, isSubsetOfLanes } from &apos;./ReactFiberLane&apos;;</span>

export const UpdateState = 0;
export function initializeUpdateQueue(fiber) {
  const queue = {
<span class="hljs-addition">+   baseState: fiber.memoizedState,</span>
<span class="hljs-addition">+   firstBaseUpdate: null,</span>
<span class="hljs-addition">+   lastBaseUpdate: null,</span>
    shared: {
      pending: null,
    },
  };
  fiber.updateQueue = queue;
}
<span class="hljs-addition">+export function createUpdate(lane) {</span>
<span class="hljs-addition">+ const update = { tag: UpdateState, lane, next: null };</span>
  return update;
}
<span class="hljs-addition">+export function enqueueUpdate(fiber, update, lane) {</span>
<span class="hljs-addition">+  const updateQueue = fiber.updateQueue</span>
<span class="hljs-addition">+  const sharedQueue = updateQueue.shared</span>
<span class="hljs-addition">+  return enqueueConcurrentClassUpdate(fiber, sharedQueue, update, lane);</span>
<span class="hljs-addition">+}</span>

function getStateFromUpdate(update, prevState, nextProps) {
  switch (update.tag) {
    case UpdateState: {
      const { payload } = update;
<span class="hljs-addition">+     let partialState;</span>
<span class="hljs-addition">+     if (typeof payload === &apos;function&apos;) {</span>
<span class="hljs-addition">+       partialState = payload.call(null, prevState, nextProps);</span>
<span class="hljs-addition">+     } else {</span>
<span class="hljs-addition">+       partialState = payload;</span>
<span class="hljs-addition">+     }</span>
<span class="hljs-addition">+     return assign({}, prevState, partialState);</span>
    }
    default:
      return prevState;
  }
}
<span class="hljs-addition">+export const processUpdateQueue = (workInProgress, props, workInProgressRootRenderLanes) =&gt; {</span>
<span class="hljs-addition">+  // &#x83B7;&#x53D6;&#x65B0;&#x7684;&#x66F4;&#x65B0;&#x961F;&#x5217;</span>
<span class="hljs-addition">+  const queue = workInProgress.updateQueue</span>
<span class="hljs-addition">+  // &#x7B2C;&#x4E00;&#x4E2A;&#x8DF3;&#x8FC7;&#x7684;&#x66F4;&#x65B0;</span>
<span class="hljs-addition">+  let firstBaseUpdate = queue.firstBaseUpdate;</span>
<span class="hljs-addition">+  // &#x6700;&#x540E;&#x4E00;&#x4E2A;&#x8DF3;&#x8FC7;&#x7684;&#x66F4;&#x65B0;</span>
<span class="hljs-addition">+  let lastBaseUpdate = queue.lastBaseUpdate;</span>
<span class="hljs-addition">+  // &#x83B7;&#x53D6;&#x5F85;&#x751F;&#x6548;&#x7684;&#x961F;&#x5217;</span>
<span class="hljs-addition">+  const pendingQueue = queue.shared.pending</span>
<span class="hljs-addition">+  /**   &#x5982;&#x679C;&#x6709;&#x65B0;&#x94FE;&#x8868;&#x5408;&#x5E76;&#x65B0;&#x65E7;&#x94FE;&#x8868;&#x5F00;&#x59CB;  */</span>
<span class="hljs-addition">+  // &#x5982;&#x679C;&#x6709;&#x65B0;&#x7684;&#x5F85;&#x751F;&#x6548;&#x7684;&#x961F;&#x5217;</span>
<span class="hljs-addition">+  if (pendingQueue !== null) {</span>
<span class="hljs-addition">+    // &#x5148;&#x6E05;&#x7A7A;&#x5F85;&#x751F;&#x6548;&#x7684;&#x961F;&#x5217;</span>
<span class="hljs-addition">+    queue.shared.pending = null</span>
<span class="hljs-addition">+    // &#x6700;&#x540E;&#x4E00;&#x4E2A;&#x5F85;&#x751F;&#x6548;&#x7684;&#x66F4;&#x65B0;</span>
<span class="hljs-addition">+    const lastPendingUpdate = pendingQueue</span>
<span class="hljs-addition">+    // &#x7B2C;&#x4E00;&#x4E2A;&#x5F85;&#x751F;&#x6548;&#x7684;&#x66F4;&#x65B0;</span>
<span class="hljs-addition">+    const firstPendingUpdate = lastPendingUpdate.next</span>
<span class="hljs-addition">+    // &#x628A;&#x73AF;&#x72B6;&#x94FE;&#x8868;&#x526A;&#x5F00;</span>
<span class="hljs-addition">+    lastPendingUpdate.next = null</span>
<span class="hljs-addition">+    // &#x5982;&#x679C;&#x6CA1;&#x6709;&#x8001;&#x7684;&#x66F4;&#x65B0;&#x961F;&#x5217;</span>
<span class="hljs-addition">+    if (lastBaseUpdate === null) {</span>
<span class="hljs-addition">+      // &#x7B2C;&#x4E00;&#x4E2A;&#x57FA;&#x672C;&#x66F4;&#x65B0;&#x5C31;&#x662F;&#x5F85;&#x751F;&#x6548;&#x961F;&#x5217;&#x7684;&#x7B2C;&#x4E00;&#x4E2A;&#x66F4;&#x65B0;</span>
<span class="hljs-addition">+      firstBaseUpdate = firstPendingUpdate;</span>
<span class="hljs-addition">+    } else {</span>
<span class="hljs-addition">+      // &#x5426;&#x5219;&#x628A;&#x5F85;&#x751F;&#x6548;&#x66F4;&#x65B0;&#x961F;&#x5217;&#x6DFB;&#x52A0;&#x5230;&#x57FA;&#x672C;&#x66F4;&#x65B0;&#x7684;&#x5C3E;&#x90E8;</span>
<span class="hljs-addition">+      lastBaseUpdate.next = firstPendingUpdate;</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+    // &#x6700;&#x540E;&#x4E00;&#x4E2A;&#x57FA;&#x672C;&#x66F4;&#x65B0;&#x80AF;&#x5B9A;&#x5C31;&#x662F;&#x6700;&#x540E;&#x4E00;&#x4E2A;&#x5F85;&#x751F;&#x6548;&#x7684;&#x66F4;&#x65B0;</span>
<span class="hljs-addition">+    lastBaseUpdate = lastPendingUpdate;</span>
<span class="hljs-addition">+    /**  &#x5408;&#x5E76;&#x65B0;&#x65E7;&#x94FE;&#x8868;&#x7ED3;&#x675F;  */</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+</span>
<span class="hljs-addition">+  // &#x5982;&#x679C;&#x6709;&#x66F4;&#x65B0;</span>
<span class="hljs-addition">+  if (firstBaseUpdate !== null) {</span>
<span class="hljs-addition">+    // &#x57FA;&#x672C;&#x72B6;&#x6001;</span>
<span class="hljs-addition">+    let newState = queue.baseState;</span>
<span class="hljs-addition">+    // &#x65B0;&#x7684;&#x8F66;&#x9053;</span>
<span class="hljs-addition">+    let newLanes = NoLanes;</span>
<span class="hljs-addition">+    // &#x65B0;&#x7684;&#x57FA;&#x672C;&#x72B6;&#x6001;</span>
<span class="hljs-addition">+    let newBaseState = null;</span>
<span class="hljs-addition">+    // &#x65B0;&#x7684;&#x7B2C;&#x4E00;&#x4E2A;&#x57FA;&#x672C;&#x66F4;&#x65B0;</span>
<span class="hljs-addition">+    let newFirstBaseUpdate = null;</span>
<span class="hljs-addition">+    // &#x65B0;&#x7684;&#x6700;&#x540E;&#x4E00;&#x4E2A;&#x57FA;&#x672C;&#x66F4;&#x65B0; </span>
<span class="hljs-addition">+    let newLastBaseUpdate = null;</span>
<span class="hljs-addition">+    // &#x7B2C;&#x4E00;&#x4E2A;&#x66F4;&#x65B0;</span>
<span class="hljs-addition">+    let update = firstBaseUpdate;</span>
<span class="hljs-addition">+    do {</span>
<span class="hljs-addition">+      const updateLane = update.lane;</span>
<span class="hljs-addition">+      const shouldSkipUpdate = !isSubsetOfLanes(workInProgressRootRenderLanes, updateLane);</span>
<span class="hljs-addition">+      // &#x5224;&#x65AD;&#x4F18;&#x5148;&#x7EA7;&#x662F;&#x5426;&#x8DB3;&#x591F;,&#x5982;&#x679C;&#x4E0D;&#x591F;&#x5C31;&#x8DF3;&#x8FC7;&#x6B64;&#x66F4;&#x65B0; </span>
<span class="hljs-addition">+      if (shouldSkipUpdate) {</span>
<span class="hljs-addition">+        // &#x590D;&#x5236;&#x4E00;&#x4E2A;&#x65B0;&#x7684;&#x66F4;&#x65B0;&#x5E76;&#x6DFB;&#x52A0;&#x65B0;&#x7684;&#x57FA;&#x672C;&#x94FE;&#x8868;&#x4E2D;</span>
<span class="hljs-addition">+        const clone = {</span>
<span class="hljs-addition">+          lane: updateLane,</span>
<span class="hljs-addition">+          tag: update.tag,</span>
<span class="hljs-addition">+          payload: update.payload,</span>
<span class="hljs-addition">+          next: null</span>
<span class="hljs-addition">+        };</span>
<span class="hljs-addition">+        if (newLastBaseUpdate === null) {</span>
<span class="hljs-addition">+          newFirstBaseUpdate = newLastBaseUpdate = clone;</span>
<span class="hljs-addition">+          newBaseState = newState;</span>
<span class="hljs-addition">+        } else {</span>
<span class="hljs-addition">+          newLastBaseUpdate = newLastBaseUpdate.next = clone;</span>
<span class="hljs-addition">+        }</span>
<span class="hljs-addition">+        // &#x4FDD;&#x5B58;&#x6B64;fiber&#x4E0A;&#x8FD8;&#x5269;&#x4E0B;&#x7684;&#x66F4;&#x65B0;&#x8F66;&#x9053;</span>
<span class="hljs-addition">+        newLanes = mergeLanes(newLanes, updateLane);</span>
<span class="hljs-addition">+      } else {</span>
<span class="hljs-addition">+        // &#x5982;&#x679C;&#x5DF2;&#x7ECF;&#x6709;&#x8DF3;&#x8FC7;&#x7684;&#x66F4;&#x65B0;&#x4E86;&#xFF0C;&#x5373;&#x4F7F;&#x4F18;&#x5148;&#x7EA7;&#x8DB3;&#x591F;&#x4E5F;&#x9700;&#x8981;&#x6DFB;&#x5230;&#x65B0;&#x7684;&#x57FA;&#x672C;&#x94FE;&#x8868;&#x4E2D;</span>
<span class="hljs-addition">+        if (newLastBaseUpdate !== null) {</span>
<span class="hljs-addition">+          const clone = {</span>
<span class="hljs-addition">+            lane: NoLane,</span>
<span class="hljs-addition">+            tag: update.tag,</span>
<span class="hljs-addition">+            payload: update.payload,</span>
<span class="hljs-addition">+            next: null</span>
<span class="hljs-addition">+          };</span>
<span class="hljs-addition">+          newLastBaseUpdate = newLastBaseUpdate.next = clone;</span>
<span class="hljs-addition">+        }</span>
<span class="hljs-addition">+        // &#x6839;&#x636E;&#x66F4;&#x65B0;&#x8BA1;&#x7B97;&#x65B0;&#x72B6;&#x6001;</span>
<span class="hljs-addition">+        newState = getStateFromUpdate(update, newState, props);</span>
<span class="hljs-addition">+        update = update.next;</span>
<span class="hljs-addition">+      }</span>
<span class="hljs-addition">+    } while (update);</span>
<span class="hljs-addition">+    // &#x5982;&#x679C;&#x6CA1;&#x6709;&#x8DF3;&#x8FC7;&#x7684;&#x66F4;&#x65B0;</span>
<span class="hljs-addition">+    if (newLastBaseUpdate === null) {</span>
<span class="hljs-addition">+      newBaseState = newState;</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+    queue.baseState = newBaseState;</span>
<span class="hljs-addition">+    queue.firstBaseUpdate = newFirstBaseUpdate;</span>
<span class="hljs-addition">+    queue.lastBaseUpdate = newLastBaseUpdate;</span>
<span class="hljs-addition">+    workInProgress.lanes = newLanes;</span>
<span class="hljs-addition">+    workInProgress.memoizedState = newState;</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+}</span>

<span class="hljs-addition">+export function cloneUpdateQueue(current, workInProgress) {</span>
<span class="hljs-addition">+  const queue = workInProgress.updateQueue;</span>
<span class="hljs-addition">+  const currentQueue = current.updateQueue;</span>
<span class="hljs-addition">+  if (queue === currentQueue) {</span>
<span class="hljs-addition">+    const clone = {</span>
<span class="hljs-addition">+      baseState: currentQueue.baseState,</span>
<span class="hljs-addition">+      firstBaseUpdate: currentQueue.firstBaseUpdate,</span>
<span class="hljs-addition">+      lastBaseUpdate: currentQueue.lastBaseUpdate,</span>
<span class="hljs-addition">+      shared: currentQueue.shared,</span>
<span class="hljs-addition">+    };</span>
<span class="hljs-addition">+    workInProgress.updateQueue = clone;</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+}</span>
</code></pre>
<h3 id="t26036.4 ReactFiberConcurrentUpdates.js">36.4 ReactFiberConcurrentUpdates.js <a href="#t26036.4 ReactFiberConcurrentUpdates.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberConcurrentUpdates.js</p>
<pre><code class="lang-diff">import { HostRoot } from &quot;./ReactWorkTags&quot;;

const concurrentQueues = [];
let concurrentQueuesIndex = 0;

export function markUpdateLaneFromFiberToRoot(sourceFiber) {
  let node = sourceFiber;
  let parent = sourceFiber.return;
  while (parent !== null) {
    node = parent;
    parent = parent.return;
  }
  if (node.tag <span class="hljs-comment">=== HostRoot) {</span>
    const root = node.stateNode;
    return root;
  }
  return null;
}
export function enqueueConcurrentHookUpdate(fiber, queue, update) {
  enqueueUpdate(fiber, queue, update);
  return getRootForUpdatedFiber(fiber);
}
<span class="hljs-addition">+export function enqueueConcurrentClassUpdate(fiber, queue, update, lane) {</span>
<span class="hljs-addition">+  enqueueUpdate(fiber, queue, update, lane);</span>
<span class="hljs-addition">+  return getRootForUpdatedFiber(fiber);</span>
<span class="hljs-addition">+}</span>

<span class="hljs-addition">+function enqueueUpdate(fiber, queue, update, lane) {</span>
  concurrentQueues[concurrentQueuesIndex++] = fiber;
  concurrentQueues[concurrentQueuesIndex++] = queue;
  concurrentQueues[concurrentQueuesIndex++] = update;
<span class="hljs-addition">+ concurrentQueues[concurrentQueuesIndex++] = lane;</span>
}
function getRootForUpdatedFiber(sourceFiber) {
  let node = sourceFiber;
  let parent = node.return;
  while (parent !== null) {
    node = parent;
    parent = node.return;
  }
  return node.tag <span class="hljs-comment">=== HostRoot ? node.stateNode : null;</span>
}

export function finishQueueingConcurrentUpdates() {
  const endIndex = concurrentQueuesIndex;
  concurrentQueuesIndex = 0;
  let i = 0;
  while (i &lt; endIndex) {
    const fiber = concurrentQueues[i++];
    const queue = concurrentQueues[i++];
    const update = concurrentQueues[i++];
<span class="hljs-addition">+   const lane = concurrentQueues[i++]</span>
    if (queue !== null &amp;&amp; update !== null) {
      const pending = queue.pending;
      if (pending <span class="hljs-comment">=== null) {</span>
        update.next = update;
      } else {
        update.next = pending.next;
        pending.next = update;
      }
      queue.pending = update;
    }
  }
}
</code></pre>
<h3 id="t26136.5 ReactFiberWorkLoop.js">36.5 ReactFiberWorkLoop.js <a href="#t26136.5 ReactFiberWorkLoop.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberWorkLoop.js</p>
<pre><code class="lang-diff"><span class="hljs-addition">+import {</span>
<span class="hljs-addition">+  scheduleCallback as Scheduler_scheduleCallback,</span>
<span class="hljs-addition">+  ImmediatePriority as ImmediateSchedulerPriority,</span>
<span class="hljs-addition">+  UserBlockingPriority as UserBlockingSchedulerPriority,</span>
<span class="hljs-addition">+  NormalPriority as NormalSchedulerPriority,</span>
<span class="hljs-addition">+  IdlePriority as IdleSchedulerPriority,</span>
<span class="hljs-addition">+} from &quot;./Scheduler&quot;;</span>
import { createWorkInProgress } from &quot;./ReactFiber&quot;;
import { beginWork } from &quot;./ReactFiberBeginWork&quot;;
import { completeWork } from &quot;./ReactFiberCompleteWork&quot;;
<span class="hljs-addition">+import { MutationMask, NoFlags, Passive } from &quot;./ReactFiberFlags&quot;;</span>
import {
  commitMutationEffects,
  commitPassiveUnmountEffects,
  commitPassiveMountEffects,
  commitLayoutEffects,
} from &quot;./ReactFiberCommitWork&quot;;
import { finishQueueingConcurrentUpdates } from &quot;./ReactFiberConcurrentUpdates&quot;;
<span class="hljs-addition">+import {</span>
<span class="hljs-addition">+  NoLane, markRootUpdated, NoLanes,</span>
<span class="hljs-addition">+  getNextLanes, getHighestPriorityLane, SyncLane,</span>
<span class="hljs-addition">+  includesBlockingLane</span>
<span class="hljs-addition">+} from &apos;./ReactFiberLane&apos;;</span>
<span class="hljs-addition">+import {</span>
<span class="hljs-addition">+  getCurrentUpdatePriority, lanesToEventPriority, DiscreteEventPriority, ContinuousEventPriority,</span>
<span class="hljs-addition">+  DefaultEventPriority, IdleEventPriority,</span>
<span class="hljs-addition">+} from &apos;./ReactEventPriorities&apos;;</span>
<span class="hljs-addition">+import { getCurrentEventPriority } from &apos;react-dom-bindings/src/client/ReactDOMHostConfig&apos;;</span>


let workInProgress = null;
let rootDoesHavePassiveEffects = false;
let rootWithPendingPassiveEffects = null;
<span class="hljs-addition">+let workInProgressRootRenderLanes = NoLanes;</span>

<span class="hljs-addition">+export function scheduleUpdateOnFiber(root, fiber, lane) {</span>
<span class="hljs-addition">+ markRootUpdated(root, lane);</span>
  ensureRootIsScheduled(root);
}
function ensureRootIsScheduled(root) {
<span class="hljs-addition">+ const nextLanes = getNextLanes(root, NoLanes);</span>
<span class="hljs-addition">+ const newCallbackPriority = getHighestPriorityLane(nextLanes);</span>
<span class="hljs-addition">+ if (newCallbackPriority === SyncLane) {</span>
<span class="hljs-addition">+   // TODO</span>
<span class="hljs-addition">+ } else {</span>
<span class="hljs-addition">+   let schedulerPriorityLevel;</span>
<span class="hljs-addition">+   switch (lanesToEventPriority(nextLanes)) {</span>
<span class="hljs-addition">+     case DiscreteEventPriority:</span>
<span class="hljs-addition">+       schedulerPriorityLevel = ImmediateSchedulerPriority;</span>
<span class="hljs-addition">+       break;</span>
<span class="hljs-addition">+     case ContinuousEventPriority:</span>
<span class="hljs-addition">+       schedulerPriorityLevel = UserBlockingSchedulerPriority;</span>
<span class="hljs-addition">+       break;</span>
<span class="hljs-addition">+     case DefaultEventPriority:</span>
<span class="hljs-addition">+       schedulerPriorityLevel = NormalSchedulerPriority;</span>
<span class="hljs-addition">+       break;</span>
<span class="hljs-addition">+     case IdleEventPriority:</span>
<span class="hljs-addition">+       schedulerPriorityLevel = IdleSchedulerPriority;</span>
<span class="hljs-addition">+       break;</span>
<span class="hljs-addition">+     default:</span>
<span class="hljs-addition">+       schedulerPriorityLevel = NormalSchedulerPriority;</span>
<span class="hljs-addition">+       break;</span>
<span class="hljs-addition">+   }</span>
<span class="hljs-addition">+   Scheduler_scheduleCallback(schedulerPriorityLevel, performConcurrentWorkOnRoot.bind(null, root))</span>
  }
}
<span class="hljs-addition">+function performConcurrentWorkOnRoot(root,didTimeout) {</span>
<span class="hljs-addition">+ const lanes = getNextLanes(root, NoLanes);</span>
<span class="hljs-addition">+ if (lanes === NoLanes) {</span>
<span class="hljs-addition">+   return null;</span>
<span class="hljs-addition">+ }</span>
<span class="hljs-addition">+ const shouldTimeSlice = !includesBlockingLane(root, lanes) &amp;&amp; (!didTimeout);</span>
<span class="hljs-addition">+ if (shouldTimeSlice) {</span>
<span class="hljs-addition">+   renderRootConcurrent(root, lanes)</span>
<span class="hljs-addition">+ } else {</span>
<span class="hljs-addition">+   renderRootSync(root, lanes);</span>
<span class="hljs-addition">+ }</span>
  const finishedWork = root.current.alternate;
  root.finishedWork = finishedWork;
  commitRoot(root);
}
<span class="hljs-addition">+function renderRootConcurrent(root, lanes) {</span>
<span class="hljs-addition">+  console.log(root, lanes);</span>
<span class="hljs-addition">+}</span>
export function flushPassiveEffects() {
  if (rootWithPendingPassiveEffects !== null) {
    const root = rootWithPendingPassiveEffects;
    commitPassiveUnmountEffects(root.current);
    commitPassiveMountEffects(root, root.current);
  }
}
function commitRoot(root) {
  const { finishedWork } = root;
  if ((finishedWork.subtreeFlags &amp; Passive) !== NoFlags || (finishedWork.flags &amp; Passive) !== NoFlags) {
    if (!rootDoesHavePassiveEffects) {
      rootDoesHavePassiveEffects = true;
      Scheduler_scheduleCallback(NormalSchedulerPriority, flushPassiveEffects);
    }
  }
  const subtreeHasEffects = (finishedWork.subtreeFlags &amp; MutationMask) !== NoFlags;
  const rootHasEffect = (finishedWork.flags &amp; MutationMask) !== NoFlags;
  if (subtreeHasEffects || rootHasEffect) {
    commitMutationEffects(finishedWork, root);
    commitLayoutEffects(finishedWork, root);
    root.current = finishedWork;
    if (rootDoesHavePassiveEffects) {
      rootDoesHavePassiveEffects = false;
      rootWithPendingPassiveEffects = root;
    }
  }
  root.current = finishedWork;
}
<span class="hljs-addition">+function prepareFreshStack(root, lanes) {</span>
  workInProgress = createWorkInProgress(root.current, null);
<span class="hljs-addition">+ workInProgressRootRenderLanes = lanes;</span>
  finishQueueingConcurrentUpdates();
}
<span class="hljs-addition">+function renderRootSync(root, lanes) {</span>
<span class="hljs-addition">+ prepareFreshStack(root, lanes);</span>
  workLoopSync();
}

function workLoopSync() {
  while (workInProgress !== null) {
    performUnitOfWork(workInProgress);
  }
}
function performUnitOfWork(unitOfWork) {
  const current = unitOfWork.alternate;
<span class="hljs-addition">+ const next = beginWork(current, unitOfWork, workInProgressRootRenderLanes);</span>
  unitOfWork.memoizedProps = unitOfWork.pendingProps;
  if (next <span class="hljs-comment">=== null) {</span>
    completeUnitOfWork(unitOfWork);
  } else {
    workInProgress = next;
  }
}

function completeUnitOfWork(unitOfWork) {
  let completedWork = unitOfWork;
  do {
    const current = completedWork.alternate;
    const returnFiber = completedWork.return;
    completeWork(current, completedWork);
    const siblingFiber = completedWork.sibling;
    if (siblingFiber !== null) {
      workInProgress = siblingFiber;
      return;
    }
    completedWork = returnFiber;
    workInProgress = completedWork;
  } while (completedWork !== null);
}

<span class="hljs-addition">+export function requestUpdateLane() {</span>
<span class="hljs-addition">+  const updateLane = getCurrentUpdatePriority();</span>
<span class="hljs-addition">+  if (updateLane !== NoLane) {</span>
<span class="hljs-addition">+    return updateLane;</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+  const eventLane = getCurrentEventPriority();</span>
<span class="hljs-addition">+  return eventLane;</span>
<span class="hljs-addition">+}</span>
</code></pre>
<h3 id="t26236.6 ReactFiberBeginWork.js">36.6 ReactFiberBeginWork.js <a href="#t26236.6 ReactFiberBeginWork.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberBeginWork.js</p>
<pre><code class="lang-diff">import { HostRoot, HostComponent, HostText, IndeterminateComponent, FunctionComponent } from &quot;./ReactWorkTags&quot;;
<span class="hljs-addition">+import { processUpdateQueue, cloneUpdateQueue } from &quot;./ReactFiberClassUpdateQueue&quot;;</span>
import { mountChildFibers, reconcileChildFibers } from &quot;./ReactChildFiber&quot;;
import { shouldSetTextContent } from &quot;react-dom-bindings/src/client/ReactDOMHostConfig&quot;;
import { renderWithHooks } from &quot;react-reconciler/src/ReactFiberHooks&quot;;

function reconcileChildren(current, workInProgress, nextChildren) {
  if (current <span class="hljs-comment">=== null) {</span>
    workInProgress.child = mountChildFibers(workInProgress, null, nextChildren);
  } else {
    workInProgress.child = reconcileChildFibers(workInProgress, current.child, nextChildren);
  }
}
<span class="hljs-addition">+function updateHostRoot(current, workInProgress, renderLanes) {</span>
<span class="hljs-addition">+ const nextProps = workInProgress.pendingProps;</span>
<span class="hljs-addition">+ cloneUpdateQueue(current, workInProgress);</span>
<span class="hljs-addition">+ processUpdateQueue(workInProgress, nextProps, renderLanes)</span>
  const nextState = workInProgress.memoizedState;
  const nextChildren = nextState.element;
  reconcileChildren(current, workInProgress, nextChildren);
  return workInProgress.child;
}
function updateHostComponent(current, workInProgress) {
  const { type } = workInProgress;
  const nextProps = workInProgress.pendingProps;
  let nextChildren = nextProps.children;
  const isDirectTextChild = shouldSetTextContent(type, nextProps);
  if (isDirectTextChild) {
    nextChildren = null;
  }
  reconcileChildren(current, workInProgress, nextChildren);
  return workInProgress.child;
}
function mountIndeterminateComponent(_current, workInProgress, Component) {
  const props = workInProgress.pendingProps;
  const value = renderWithHooks(null, workInProgress, Component, props);
  workInProgress.tag = FunctionComponent;
  reconcileChildren(null, workInProgress, value);
  return workInProgress.child;
}
function updateFunctionComponent(current, workInProgress, Component, nextProps,workInProgressRootRenderLanes) {
  const nextChildren = renderWithHooks(current, workInProgress, Component, nextProps,workInProgressRootRenderLanes);
  reconcileChildren(current, workInProgress, nextChildren);
  return workInProgress.child;
}
<span class="hljs-addition">+export function beginWork(current, workInProgress, renderLanes) {</span>
  switch (workInProgress.tag) {
    case IndeterminateComponent: {
<span class="hljs-addition">+     return mountIndeterminateComponent(current, workInProgress, workInProgress.type, renderLanes);</span>
    }
    case FunctionComponent: {
      const Component = workInProgress.type;
      const resolvedProps = workInProgress.pendingProps;
<span class="hljs-addition">+     return updateFunctionComponent(current, workInProgress, Component, resolvedProps, renderLanes);</span>
    }
    case HostRoot:
<span class="hljs-addition">+     return updateHostRoot(current, workInProgress, renderLanes);</span>
    case HostComponent:
<span class="hljs-addition">+     return updateHostComponent(current, workInProgress, renderLanes);</span>
    case HostText:
    default:
      return null;
  }
}
</code></pre>
<h3 id="t26336.7 ReactFiberLane.js">36.7 ReactFiberLane.js <a href="#t26336.7 ReactFiberLane.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberLane.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> TotalLanes = <span class="hljs-number">31</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> NoLanes = <span class="hljs-number">0b0000000000000000000000000000000</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> NoLane = <span class="hljs-number">0b0000000000000000000000000000000</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> SyncLane = <span class="hljs-number">0b0000000000000000000000000000001</span>;<span class="hljs-comment">// 1</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> InputContinuousLane = <span class="hljs-number">0b0000000000000000000000000000100</span>;<span class="hljs-comment">// 4</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> DefaultLane = <span class="hljs-number">0b0000000000000000000000000010000</span>;<span class="hljs-comment">// 16</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> NonIdleLanes = <span class="hljs-number">0b0001111111111111111111111111111</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> IdleLane = <span class="hljs-number">0b0100000000000000000000000000000</span>;

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mergeLanes</span>(<span class="hljs-params">a, b</span>) </span>{
  <span class="hljs-keyword">return</span> a | b;
}
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">markRootUpdated</span>(<span class="hljs-params">root, updateLane</span>) </span>{
  root.pendingLanes |= updateLane;
}

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getNextLanes</span>(<span class="hljs-params">root</span>) </span>{
  <span class="hljs-keyword">const</span> pendingLanes = root.pendingLanes;
  <span class="hljs-keyword">if</span> (pendingLanes === NoLanes) {
    <span class="hljs-keyword">return</span> NoLanes;
  }
  <span class="hljs-keyword">const</span> nextLanes = getHighestPriorityLanes(pendingLanes);
  <span class="hljs-keyword">return</span> nextLanes;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getHighestPriorityLanes</span>(<span class="hljs-params">lanes</span>) </span>{
  <span class="hljs-keyword">return</span> getHighestPriorityLane(lanes);
}

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getHighestPriorityLane</span>(<span class="hljs-params">lanes</span>) </span>{
  <span class="hljs-keyword">return</span> lanes &amp; -lanes;
}

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">includesNonIdleWork</span>(<span class="hljs-params">lanes</span>) </span>{
  <span class="hljs-keyword">return</span> (lanes &amp; NonIdleLanes) !== NoLanes;
}
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">includesBlockingLane</span>(<span class="hljs-params">root, lanes</span>) </span>{
  <span class="hljs-keyword">const</span> SyncDefaultLanes = InputContinuousLane | DefaultLane;
  <span class="hljs-keyword">return</span> (lanes &amp; SyncDefaultLanes) !== NoLanes;
}
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isSubsetOfLanes</span>(<span class="hljs-params">set, subset</span>) </span>{
  <span class="hljs-keyword">return</span> (<span class="hljs-keyword">set</span> &amp; subset) === subset;
}
</code></pre>
<h3 id="t26436.8 ReactEventPriorities.js">36.8 ReactEventPriorities.js <a href="#t26436.8 ReactEventPriorities.js"> # </a></h3>
<p>src\react-reconciler\src\ReactEventPriorities.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">import</span> {
  NoLane, DefaultLane, getHighestPriorityLane,
  includesNonIdleWork, SyncLane, InputContinuousLane, IdleLane
} <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;./ReactFiberLane&apos;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> DefaultEventPriority = DefaultLane;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> DiscreteEventPriority = SyncLane;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> ContinuousEventPriority = InputContinuousLane;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> IdleEventPriority = IdleLane;

<span class="hljs-keyword">let</span> currentUpdatePriority = NoLane;

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getCurrentUpdatePriority</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> currentUpdatePriority;
}
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setCurrentUpdatePriority</span>(<span class="hljs-params">newPriority</span>) </span>{
  currentUpdatePriority = newPriority;
}
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isHigherEventPriority</span>(<span class="hljs-params">a, b</span>) </span>{
  <span class="hljs-keyword">return</span> a !== <span class="hljs-number">0</span> &amp;&amp; a &lt; b;
}
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">lanesToEventPriority</span>(<span class="hljs-params">lanes</span>) </span>{
  <span class="hljs-keyword">const</span> lane = getHighestPriorityLane(lanes);
  <span class="hljs-keyword">if</span> (!isHigherEventPriority(DiscreteEventPriority, lane)) {
    <span class="hljs-keyword">return</span> DiscreteEventPriority;
  }
  <span class="hljs-keyword">if</span> (!isHigherEventPriority(ContinuousEventPriority, lane)) {
    <span class="hljs-keyword">return</span> ContinuousEventPriority;
  }
  <span class="hljs-keyword">if</span> (includesNonIdleWork(lane)) {
    <span class="hljs-keyword">return</span> DefaultEventPriority;
  }
  <span class="hljs-keyword">return</span> IdleEventPriority;
}
</code></pre>
<h3 id="t26536.9 ReactDOMHostConfig.js">36.9 ReactDOMHostConfig.js <a href="#t26536.9 ReactDOMHostConfig.js"> # </a></h3>
<p>src\react-dom-bindings\src\client\ReactDOMHostConfig.js</p>
<pre><code class="lang-diff">import { setInitialProperties, diffProperties, updateProperties } from &quot;./ReactDOMComponent&quot;;
import { precacheFiberNode, updateFiberProps } from &quot;./ReactDOMComponentTree&quot;;
<span class="hljs-addition">+import { getEventPriority } from &apos;../events/ReactDOMEventListener&apos;;</span>
<span class="hljs-addition">+import { DefaultEventPriority } from &apos;react-reconciler/src/ReactEventPriorities&apos;;</span>

export function shouldSetTextContent(type, props) {
  return typeof props.children <span class="hljs-comment">=== &quot;string&quot; || typeof props.children === &quot;number&quot;;</span>
}
export const appendInitialChild = (parent, child) =&gt; {
  parent.appendChild(child);
};
export const createInstance = (type, props, internalInstanceHandle) =&gt; {
  const domElement = document.createElement(type);
  precacheFiberNode(internalInstanceHandle, domElement);
  updateFiberProps(domElement, props);
  return domElement;
};
export const createTextInstance = (content) =&gt; document.createTextNode(content);
export function finalizeInitialChildren(domElement, type, props) {
  setInitialProperties(domElement, type, props);
}
export function appendChild(parentInstance, child) {
  parentInstance.appendChild(child);
}
export function insertBefore(parentInstance, child, beforeChild) {
  parentInstance.insertBefore(child, beforeChild);
}

export function prepareUpdate(domElement, type, oldProps, newProps) {
  return diffProperties(domElement, type, oldProps, newProps);
}

export function commitUpdate(domElement, updatePayload, type, oldProps, newProps) {
  updateProperties(domElement, updatePayload, type, oldProps, newProps);
  updateFiberProps(domElement, newProps);
}
export function removeChild(parentInstance, child) {
  parentInstance.removeChild(child);
}
<span class="hljs-addition">+export function getCurrentEventPriority() {</span>
<span class="hljs-addition">+  const currentEvent = window.event;</span>
<span class="hljs-addition">+  if (currentEvent === undefined) {</span>
<span class="hljs-addition">+    return DefaultEventPriority;</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+  return getEventPriority(currentEvent.type);</span>
<span class="hljs-addition">+}</span>
</code></pre>
<h3 id="t26636.10 ReactDOMEventListener.js">36.10 ReactDOMEventListener.js <a href="#t26636.10 ReactDOMEventListener.js"> # </a></h3>
<p>src\react-dom-bindings\src\events\ReactDOMEventListener.js</p>
<pre><code class="lang-diff">import getEventTarget from &quot;./getEventTarget&quot;;
import { getClosestInstanceFromNode } from &quot;../client/ReactDOMComponentTree&quot;;
import { dispatchEventForPluginEventSystem } from &quot;./DOMPluginEventSystem&quot;;
<span class="hljs-addition">+import { DiscreteEventPriority, ContinuousEventPriority, DefaultEventPriority } from &apos;react-reconciler/src/ReactEventPriorities&apos;;</span>

export function createEventListenerWrapperWithPriority(
  targetContainer,
  domEventName,
  eventSystemFlags
) {
  const listenerWrapper = dispatchDiscreteEvent;
  return listenerWrapper.bind(null, domEventName, eventSystemFlags, targetContainer);
}
function dispatchDiscreteEvent(domEventName, eventSystemFlags, container, nativeEvent) {
  dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
}
export function dispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
  const nativeEventTarget = getEventTarget(nativeEvent);
  const targetInst = getClosestInstanceFromNode(nativeEventTarget);
  dispatchEventForPluginEventSystem(
    domEventName,
    eventSystemFlags,
    nativeEvent,
    targetInst,
    targetContainer
  );
}
<span class="hljs-addition">+export function getEventPriority(domEventName) {</span>
<span class="hljs-addition">+  switch (domEventName) {</span>
<span class="hljs-addition">+    case &apos;click&apos;:</span>
<span class="hljs-addition">+      return DiscreteEventPriority;</span>
<span class="hljs-addition">+    case &apos;drag&apos;:</span>
<span class="hljs-addition">+      return ContinuousEventPriority;</span>
<span class="hljs-addition">+    default:</span>
<span class="hljs-addition">+      return DefaultEventPriority;</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+}</span>
</code></pre>
<h3 id="t26736.11 Scheduler.js">36.11 Scheduler.js <a href="#t26736.11 Scheduler.js"> # </a></h3>
<p>src\react-reconciler\src\Scheduler.js</p>
<pre><code class="lang-diff">import * as Scheduler from &apos;scheduler&apos;

export const scheduleCallback = Scheduler.unstable_scheduleCallback
export const NormalPriority = Scheduler.unstable_NormalPriority
<span class="hljs-addition">+export const ImmediatePriority = Scheduler.unstable_ImmediatePriority;</span>
<span class="hljs-addition">+export const UserBlockingPriority = Scheduler.unstable_UserBlockingPriority;</span>
<span class="hljs-addition">+export const LowPriority = Scheduler.unstable_LowPriority;</span>
<span class="hljs-addition">+export const IdlePriority = Scheduler.unstable_IdlePriority;</span>
</code></pre>
<h2 id="t26837.&#x66F4;&#x65B0;&#x6E32;&#x67D3;">37.&#x66F4;&#x65B0;&#x6E32;&#x67D3; <a href="#t26837.&#x66F4;&#x65B0;&#x6E32;&#x67D3;"> # </a></h2>
<h3 id="t26937.1 main.jsx">37.1 main.jsx <a href="#t26937.1 main.jsx"> # </a></h3>
<p>src\main.jsx</p>
<pre><code class="lang-diff">import * as React from &quot;react&quot;;
import { createRoot } from &quot;react-dom/client&quot;;
<span class="hljs-addition">+function FunctionComponent() {</span>
<span class="hljs-addition">+  const [number, setNumber] = React.useState(0);</span>
<span class="hljs-addition">+  return &lt;button onClick={() =&gt; {</span>
<span class="hljs-addition">+    setNumber(number + 1)</span>
<span class="hljs-addition">+  }}&gt;{number}&lt;/button&gt;</span>
<span class="hljs-addition">+}</span>
const element = &lt;FunctionComponent /&gt;;
const container = document.getElementById(&quot;root&quot;);
const root = createRoot(container);
root.render(element);
</code></pre>
<h3 id="t27037.2 ReactFiberHooks.js">37.2 ReactFiberHooks.js <a href="#t27037.2 ReactFiberHooks.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberHooks.js</p>
<pre><code class="lang-diff">import ReactSharedInternals from &quot;shared/ReactSharedInternals&quot;;
import { enqueueConcurrentHookUpdate } from &quot;./ReactFiberConcurrentUpdates&quot;;
<span class="hljs-addition">+import { scheduleUpdateOnFiber, requestUpdateLane } from &quot;./ReactFiberWorkLoop&quot;;</span>
import is from &quot;shared/objectIs&quot;;
import { Passive as PassiveEffect, Update as UpdateEffect } from &quot;./ReactFiberFlags&quot;;
import { HasEffect as HookHasEffect, Passive as HookPassive, Layout as HookLayout } from &quot;./ReactHookEffectTags&quot;;

const { ReactCurrentDispatcher } = ReactSharedInternals;
let currentlyRenderingFiber = null;
let workInProgressHook = null;
let currentHook = null;

const HooksDispatcherOnMountInDEV = {
  useReducer: mountReducer,
  useState: mountState,
  useEffect: mountEffect,
  useLayoutEffect: mountLayoutEffect,
};
const HooksDispatcherOnUpdateInDEV = {
  useReducer: updateReducer,
  useState: updateState,
  useEffect: updateEffect,
  useLayoutEffect: updateLayoutEffect,
};
export function useLayoutEffect(reducer, initialArg) {
  return ReactCurrentDispatcher.current.useLayoutEffect(reducer, initialArg);
}
function updateLayoutEffect(create, deps) {
  return updateEffectImpl(UpdateEffect, HookLayout, create, deps);
}
function mountLayoutEffect(create, deps) {
  const fiberFlags = UpdateEffect;
  return mountEffectImpl(fiberFlags, HookLayout, create, deps);
}
function updateEffect(create, deps) {
  return updateEffectImpl(PassiveEffect, HookPassive, create, deps);
}
function updateEffectImpl(fiberFlags, hookFlags, create, deps) {
  const hook = updateWorkInProgressHook();
  const nextDeps = deps <span class="hljs-comment">=== undefined ? null : deps;</span>
  let destroy;
  if (currentHook !== null) {
    const prevEffect = currentHook.memoizedState;
    destroy = prevEffect.destroy;
    if (nextDeps !== null) {
      const prevDeps = prevEffect.deps;
      if (areHookInputsEqual(nextDeps, prevDeps)) {
        hook.memoizedState = pushEffect(hookFlags, create, destroy, nextDeps);
        return;
      }
    }
  }
  currentlyRenderingFiber.flags |= fiberFlags;
  hook.memoizedState = pushEffect(HookHasEffect | hookFlags, create, destroy, nextDeps);
}
function areHookInputsEqual(nextDeps, prevDeps) {
  if (prevDeps <span class="hljs-comment">=== null) {</span>
    return false;
  }
  for (let i = 0; i &lt; prevDeps.length &amp;&amp; i &lt; nextDeps.length; i++) {
    if (is(nextDeps[i], prevDeps[i])) {
      continue;
    }
    return false;
  }

  return true;
}
function mountEffect(create, deps) {
  return mountEffectImpl(PassiveEffect, HookPassive, create, deps);
}
function mountEffectImpl(fiberFlags, hookFlags, create, deps) {
  const hook = mountWorkInProgressHook();
  const nextDeps = deps <span class="hljs-comment">=== undefined ? null : deps;</span>
  currentlyRenderingFiber.flags |= fiberFlags;
  hook.memoizedState = pushEffect(HookHasEffect | hookFlags, create, undefined, nextDeps);
}
function pushEffect(tag, create, destroy, deps) {
  const effect = {
    tag,
    create,
    destroy,
    deps,
    next: null,
  };
  let componentUpdateQueue = currentlyRenderingFiber.updateQueue;
  if (componentUpdateQueue <span class="hljs-comment">=== null) {</span>
    componentUpdateQueue = createFunctionComponentUpdateQueue();
    currentlyRenderingFiber.updateQueue = componentUpdateQueue;
    componentUpdateQueue.lastEffect = effect.next = effect;
  } else {
    const lastEffect = componentUpdateQueue.lastEffect;
    if (lastEffect <span class="hljs-comment">=== null) {</span>
      componentUpdateQueue.lastEffect = effect.next = effect;
    } else {
      const firstEffect = lastEffect.next;
      lastEffect.next = effect;
      effect.next = firstEffect;
      componentUpdateQueue.lastEffect = effect;
    }
  }
  return effect;
}
function createFunctionComponentUpdateQueue() {
  return {
    lastEffect: null,
  };
}
function basicStateReducer(state, action) {
  return typeof action <span class="hljs-comment">=== &quot;function&quot; ? action(state) : action;</span>
}
function mountReducer(reducer, initialArg) {
  const hook = mountWorkInProgressHook();
  hook.memoizedState = initialArg;
  const queue = {
    pending: null,
    dispatch: null,
  };
  hook.queue = queue;
  const dispatch = (queue.dispatch = dispatchReducerAction.bind(null, currentlyRenderingFiber, queue));
  return [hook.memoizedState, dispatch];
}
function updateReducer(reducer) {
  const hook = updateWorkInProgressHook();
  const queue = hook.queue;
  queue.lastRenderedReducer = reducer;
  const current = currentHook;
  const pendingQueue = queue.pending;
  let baseQueue = null;
  let newState = current.memoizedState;
  if (pendingQueue !== null) {
    baseQueue = pendingQueue;
    queue.pending = null;
  }
  if (baseQueue !== null) {
    const first = baseQueue.next;
    let update = first;
    do {
      if (update.hasEagerState) {
        newState = update.eagerState;
      } else {
        const action = update.action;
        newState = reducer(newState, action);
      }
      update = update.next;
    } while (update !== null &amp;&amp; update !== first);
  }
  hook.memoizedState = newState;
  queue.lastRenderedState = newState;
  const dispatch = queue.dispatch;
  return [hook.memoizedState, dispatch];
}
function mountState(initialState) {
  const hook = mountWorkInProgressHook();
  hook.memoizedState = initialState;
  const queue = {
    pending: null,
    dispatch: null,
    lastRenderedReducer: basicStateReducer,
    lastRenderedState: initialState,
  };
  hook.queue = queue;
  const dispatch = (queue.dispatch = dispatchSetState.bind(null, currentlyRenderingFiber, queue));
  return [hook.memoizedState, dispatch];
}
function dispatchSetState(fiber, queue, action) {
<span class="hljs-addition">+ const lane = requestUpdateLane(fiber);</span>
  const update = {
<span class="hljs-addition">+   lane,</span>
    action,
    hasEagerState: false,
    eagerState: null,
    next: null,
  };
  const lastRenderedReducer = queue.lastRenderedReducer;
  const currentState = queue.lastRenderedState;
  const eagerState = lastRenderedReducer(currentState, action);
  update.hasEagerState = true;
  update.eagerState = eagerState;
  if (is(eagerState, currentState)) {
    return;
  }
<span class="hljs-addition">+ const root = enqueueConcurrentHookUpdate(fiber, queue, update, lane);</span>
<span class="hljs-addition">+ scheduleUpdateOnFiber(root, fiber, lane);</span>
}
function updateState(initialState) {
  return updateReducer(basicStateReducer, initialState);
}
function mountWorkInProgressHook() {
  const hook = {
    memoizedState: null,
    queue: null,
    next: null,
  };
  if (workInProgressHook <span class="hljs-comment">=== null) {</span>
    currentlyRenderingFiber.memoizedState = workInProgressHook = hook;
  } else {
    workInProgressHook = workInProgressHook.next = hook;
  }
  return workInProgressHook;
}
function dispatchReducerAction(fiber, queue, action) {
  const update = {
    action,
    next: null,
  };
  const root = enqueueConcurrentHookUpdate(fiber, queue, update);
  scheduleUpdateOnFiber(root, fiber);
}

function updateWorkInProgressHook() {
  let nextCurrentHook;
  if (currentHook <span class="hljs-comment">=== null) {</span>
    const current = currentlyRenderingFiber.alternate;
    if (current !== null) {
      nextCurrentHook = current.memoizedState;
    } else {
      nextCurrentHook = null;
    }
  } else {
    nextCurrentHook = currentHook.next;
  }

  let nextWorkInProgressHook;
  if (workInProgressHook <span class="hljs-comment">=== null) {</span>
    nextWorkInProgressHook = currentlyRenderingFiber.memoizedState;
  } else {
    nextWorkInProgressHook = workInProgressHook.next;
  }

  if (nextWorkInProgressHook !== null) {
    workInProgressHook = nextWorkInProgressHook;
    nextWorkInProgressHook = workInProgressHook.next;
    currentHook = nextCurrentHook;
  } else {
    currentHook = nextCurrentHook;
    const newHook = {
      memoizedState: currentHook.memoizedState,
      queue: currentHook.queue,
      next: null,
    };
    if (workInProgressHook <span class="hljs-comment">=== null) {</span>
      currentlyRenderingFiber.memoizedState = workInProgressHook = newHook;
    } else {
      workInProgressHook = workInProgressHook.next = newHook;
    }
  }
  return workInProgressHook;
}
export function renderWithHooks(current, workInProgress, Component, props) {
  currentlyRenderingFiber = workInProgress;
  workInProgress.updateQueue = null;
  workInProgress.memoizedState = null;
  if (current !== null &amp;&amp; current.memoizedState !== null) {
    ReactCurrentDispatcher.current = HooksDispatcherOnUpdateInDEV;
  } else {
    ReactCurrentDispatcher.current = HooksDispatcherOnMountInDEV;
  }
  const children = Component(props);
  currentlyRenderingFiber = null;
  workInProgressHook = null;
  currentHook = null;
  return children;
}
</code></pre>
<h3 id="t27137.3 ReactFiberWorkLoop.js">37.3 ReactFiberWorkLoop.js <a href="#t27137.3 ReactFiberWorkLoop.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberWorkLoop.js</p>
<pre><code class="lang-diff">import {
  scheduleCallback as Scheduler_scheduleCallback,
  ImmediatePriority as ImmediateSchedulerPriority,
  UserBlockingPriority as UserBlockingSchedulerPriority,
  NormalPriority as NormalSchedulerPriority,
  IdlePriority as IdleSchedulerPriority,
} from &quot;./Scheduler&quot;;
import { createWorkInProgress } from &quot;./ReactFiber&quot;;
import { beginWork } from &quot;./ReactFiberBeginWork&quot;;
import { completeWork } from &quot;./ReactFiberCompleteWork&quot;;
import { MutationMask, NoFlags, Passive } from &quot;./ReactFiberFlags&quot;;
import {
  commitMutationEffects,
  commitPassiveUnmountEffects,
  commitPassiveMountEffects,
  commitLayoutEffects,
} from &quot;./ReactFiberCommitWork&quot;;
import { finishQueueingConcurrentUpdates } from &quot;./ReactFiberConcurrentUpdates&quot;;
import {
  NoLane, markRootUpdated, NoLanes,
  getNextLanes, getHighestPriorityLane, SyncLane,
  includesBlockingLane
} from &apos;./ReactFiberLane&apos;;
import {
  getCurrentUpdatePriority, lanesToEventPriority, DiscreteEventPriority, ContinuousEventPriority,
<span class="hljs-addition">+ DefaultEventPriority, IdleEventPriority, setCurrentUpdatePriority</span>
} from &apos;./ReactEventPriorities&apos;;
import { getCurrentEventPriority } from &apos;react-dom-bindings/src/client/ReactDOMHostConfig&apos;;
<span class="hljs-addition">+import { scheduleSyncCallback, flushSyncCallbacks } from &apos;./ReactFiberSyncTaskQueue&apos;;</span>

let workInProgress = null;
let rootDoesHavePassiveEffects = false;
let rootWithPendingPassiveEffects = null;
let workInProgressRootRenderLanes = NoLanes;

export function scheduleUpdateOnFiber(root, fiber, lane) {
  markRootUpdated(root, lane);
  ensureRootIsScheduled(root);
}
function ensureRootIsScheduled(root) {
  const nextLanes = getNextLanes(root, NoLanes);
  const newCallbackPriority = getHighestPriorityLane(nextLanes);
  if (newCallbackPriority <span class="hljs-comment">=== SyncLane) {</span>
<span class="hljs-addition">+   scheduleSyncCallback(performSyncWorkOnRoot.bind(null, root));</span>
<span class="hljs-addition">+   queueMicrotask(flushSyncCallbacks);</span>
  } else {
    let schedulerPriorityLevel;
    switch (lanesToEventPriority(nextLanes)) {
      case DiscreteEventPriority:
        schedulerPriorityLevel = ImmediateSchedulerPriority;
        break;
      case ContinuousEventPriority:
        schedulerPriorityLevel = UserBlockingSchedulerPriority;
        break;
      case DefaultEventPriority:
        schedulerPriorityLevel = NormalSchedulerPriority;
        break;
      case IdleEventPriority:
        schedulerPriorityLevel = IdleSchedulerPriority;
        break;
      default:
        schedulerPriorityLevel = NormalSchedulerPriority;
        break;
    }
    Scheduler_scheduleCallback(schedulerPriorityLevel, performConcurrentWorkOnRoot.bind(null, root))
  }
}
<span class="hljs-addition">+function performSyncWorkOnRoot(root) {</span>
<span class="hljs-addition">+  const lanes = getNextLanes(root, NoLanes);</span>
<span class="hljs-addition">+  renderRootSync(root, lanes);</span>
<span class="hljs-addition">+  const finishedWork = root.current.alternate</span>
<span class="hljs-addition">+  root.finishedWork = finishedWork</span>
<span class="hljs-addition">+  commitRoot(root)</span>
<span class="hljs-addition">+  return null;//&#x5982;&#x679C;&#x6CA1;&#x6709;&#x4EFB;&#x52A1;&#x4E86;&#x4E00;&#x5B9A;&#x8981;&#x8FD4;&#x56DE;null</span>
<span class="hljs-addition">+}</span>
function performConcurrentWorkOnRoot(root) {
  const lanes = getNextLanes(root, NoLanes);
  if (lanes <span class="hljs-comment">=== NoLanes) {</span>
    return null;
  }
  const shouldTimeSlice = !includesBlockingLane(root, lanes) &amp;&amp; (!didTimeout);
  if (shouldTimeSlice) {
    renderRootConcurrent(root, lanes)
  } else {
    renderRootSync(root, lanes);
  }
  const finishedWork = root.current.alternate;
  root.finishedWork = finishedWork;
  commitRoot(root);
}
function renderRootConcurrent(root, lanes) {
  console.log(root, lanes);
}
export function flushPassiveEffects() {
  if (rootWithPendingPassiveEffects !== null) {
    const root = rootWithPendingPassiveEffects;
    commitPassiveUnmountEffects(root.current);
    commitPassiveMountEffects(root, root.current);
  }
}
<span class="hljs-addition">+function commitRoot(root) {</span>
<span class="hljs-addition">+  const previousPriority = getCurrentUpdatePriority();</span>
<span class="hljs-addition">+  try {</span>
<span class="hljs-addition">+    setCurrentUpdatePriority(DiscreteEventPriority);</span>
<span class="hljs-addition">+    commitRootImpl(root);</span>
<span class="hljs-addition">+  } finally {</span>
<span class="hljs-addition">+    setCurrentUpdatePriority(previousPriority);</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+function commitRootImpl(root) {</span>
  const { finishedWork } = root;
  if ((finishedWork.subtreeFlags &amp; Passive) !== NoFlags || (finishedWork.flags &amp; Passive) !== NoFlags) {
    if (!rootDoesHavePassiveEffects) {
      rootDoesHavePassiveEffects = true;
      Scheduler_scheduleCallback(NormalSchedulerPriority, flushPassiveEffects);
    }
  }
  const subtreeHasEffects = (finishedWork.subtreeFlags &amp; MutationMask) !== NoFlags;
  const rootHasEffect = (finishedWork.flags &amp; MutationMask) !== NoFlags;
  if (subtreeHasEffects || rootHasEffect) {
    commitMutationEffects(finishedWork, root);
    commitLayoutEffects(finishedWork, root);
    root.current = finishedWork;
    if (rootDoesHavePassiveEffects) {
      rootDoesHavePassiveEffects = false;
      rootWithPendingPassiveEffects = root;
    }
  }
  root.current = finishedWork;
<span class="hljs-addition">+}</span>
function prepareFreshStack(root, lanes) {
  workInProgress = createWorkInProgress(root.current, null);
  workInProgressRootRenderLanes = lanes;
  finishQueueingConcurrentUpdates();
}
function renderRootSync(root, lanes) {
  prepareFreshStack(root, lanes);
  workLoopSync();
}

function workLoopSync() {
  while (workInProgress !== null) {
    performUnitOfWork(workInProgress);
  }
}
function performUnitOfWork(unitOfWork) {
  const current = unitOfWork.alternate;
  const next = beginWork(current, unitOfWork, workInProgressRootRenderLanes);
  unitOfWork.memoizedProps = unitOfWork.pendingProps;
  if (next <span class="hljs-comment">=== null) {</span>
    completeUnitOfWork(unitOfWork);
  } else {
    workInProgress = next;
  }
}

function completeUnitOfWork(unitOfWork) {
  let completedWork = unitOfWork;
  do {
    const current = completedWork.alternate;
    const returnFiber = completedWork.return;
    completeWork(current, completedWork);
    const siblingFiber = completedWork.sibling;
    if (siblingFiber !== null) {
      workInProgress = siblingFiber;
      return;
    }
    completedWork = returnFiber;
    workInProgress = completedWork;
  } while (completedWork !== null);
}

export function requestUpdateLane() {
  const updateLane = getCurrentUpdatePriority();
  if (updateLane !== NoLane) {
    return updateLane;
  }
  const eventLane = getCurrentEventPriority();
  return eventLane;
}
</code></pre>
<h3 id="t27237.4 ReactFiberSyncTaskQueue.js">37.4 ReactFiberSyncTaskQueue.js <a href="#t27237.4 ReactFiberSyncTaskQueue.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberSyncTaskQueue.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">import</span> { DiscreteEventPriority, getCurrentUpdatePriority, setCurrentUpdatePriority } <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;./ReactEventPriorities&apos;</span>;

<span class="hljs-keyword">let</span> syncQueue = <span class="hljs-literal">null</span>;
<span class="hljs-keyword">let</span> isFlushingSyncQueue = <span class="hljs-literal">false</span>;

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">scheduleSyncCallback</span>(<span class="hljs-params">callback</span>) </span>{
  <span class="hljs-keyword">if</span> (syncQueue === <span class="hljs-literal">null</span>) {
    syncQueue = [callback];
  } <span class="hljs-keyword">else</span> {
    syncQueue.push(callback);
  }
}

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flushSyncCallbacks</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">if</span> (!isFlushingSyncQueue &amp;&amp; syncQueue !== <span class="hljs-literal">null</span>) {
    isFlushingSyncQueue = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">const</span> previousUpdatePriority = getCurrentUpdatePriority();
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">const</span> isSync = <span class="hljs-literal">true</span>;
      <span class="hljs-keyword">const</span> queue = syncQueue;
      setCurrentUpdatePriority(DiscreteEventPriority);
      <span class="hljs-keyword">for</span> (; i &lt; queue.length; i++) {
        <span class="hljs-keyword">let</span> callback = queue[i];
        <span class="hljs-keyword">do</span> {
          callback = callback(isSync);
        } <span class="hljs-keyword">while</span> (callback !== <span class="hljs-literal">null</span>);
      }
      syncQueue = <span class="hljs-literal">null</span>;
    } <span class="hljs-keyword">finally</span> {
      setCurrentUpdatePriority(previousUpdatePriority);
      isFlushingSyncQueue = <span class="hljs-literal">false</span>;
    }
  }
  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
}
</code></pre>
<h3 id="t27337.5  ReactFiberConcurrentUpdates.js">37.5  ReactFiberConcurrentUpdates.js <a href="#t27337.5  ReactFiberConcurrentUpdates.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberConcurrentUpdates.js</p>
<pre><code class="lang-diff">import { HostRoot } from &quot;./ReactWorkTags&quot;;

const concurrentQueues = [];
let concurrentQueuesIndex = 0;

export function markUpdateLaneFromFiberToRoot(sourceFiber) {
  let node = sourceFiber;
  let parent = sourceFiber.return;
  while (parent !== null) {
    node = parent;
    parent = parent.return;
  }
  if (node.tag <span class="hljs-comment">=== HostRoot) {</span>
    const root = node.stateNode;
    return root;
  }
  return null;
}
<span class="hljs-addition">+export function enqueueConcurrentHookUpdate(fiber, queue, update, lane) {</span>
<span class="hljs-addition">+ enqueueUpdate(fiber, queue, update, lane);</span>
  return getRootForUpdatedFiber(fiber);
}
export function enqueueConcurrentClassUpdate(fiber, queue, update, lane) {
  enqueueUpdate(fiber, queue, update, lane);
  return getRootForUpdatedFiber(fiber);
}

function enqueueUpdate(fiber, queue, update, lane) {
  concurrentQueues[concurrentQueuesIndex++] = fiber;
  concurrentQueues[concurrentQueuesIndex++] = queue;
  concurrentQueues[concurrentQueuesIndex++] = update;
  concurrentQueues[concurrentQueuesIndex++] = lane;
}
function getRootForUpdatedFiber(sourceFiber) {
  let node = sourceFiber;
  let parent = node.return;
  while (parent !== null) {
    node = parent;
    parent = node.return;
  }
  return node.tag <span class="hljs-comment">=== HostRoot ? node.stateNode : null;</span>
}

export function finishQueueingConcurrentUpdates() {
  const endIndex = concurrentQueuesIndex;
  concurrentQueuesIndex = 0;
  let i = 0;
  while (i &lt; endIndex) {
    const fiber = concurrentQueues[i++];
    const queue = concurrentQueues[i++];
    const update = concurrentQueues[i++];
    const lane = concurrentQueues[i++]
    if (queue !== null &amp;&amp; update !== null) {
      const pending = queue.pending;
      if (pending <span class="hljs-comment">=== null) {</span>
        update.next = update;
      } else {
        update.next = pending.next;
        pending.next = update;
      }
      queue.pending = update;
    }
  }
}

</code></pre>
<h3 id="t27437.6 ReactDOMEventListener.js">37.6 ReactDOMEventListener.js <a href="#t27437.6 ReactDOMEventListener.js"> # </a></h3>
<p>src\react-dom-bindings\src\events\ReactDOMEventListener.js</p>
<pre><code class="lang-diff">import getEventTarget from &quot;./getEventTarget&quot;;
import { getClosestInstanceFromNode } from &quot;../client/ReactDOMComponentTree&quot;;
import { dispatchEventForPluginEventSystem } from &quot;./DOMPluginEventSystem&quot;;
import {
  DiscreteEventPriority, ContinuousEventPriority, DefaultEventPriority,
<span class="hljs-addition">+ getCurrentUpdatePriority, setCurrentUpdatePriority</span>
} from &apos;react-reconciler/src/ReactEventPriorities&apos;;

export function createEventListenerWrapperWithPriority(
  targetContainer,
  domEventName,
  eventSystemFlags
) {
  const listenerWrapper = dispatchDiscreteEvent;
  return listenerWrapper.bind(null, domEventName, eventSystemFlags, targetContainer);
}
<span class="hljs-addition">+function dispatchDiscreteEvent(domEventName, eventSystemFlags, container, nativeEvent) {</span>
<span class="hljs-addition">+  const previousPriority = getCurrentUpdatePriority();</span>
<span class="hljs-addition">+  try {</span>
<span class="hljs-addition">+    setCurrentUpdatePriority(DiscreteEventPriority);</span>
     dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent)
<span class="hljs-addition">+  } finally {</span>
<span class="hljs-addition">+    setCurrentUpdatePriority(previousPriority);</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+}</span>
export function dispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
  const nativeEventTarget = getEventTarget(nativeEvent);
  const targetInst = getClosestInstanceFromNode(nativeEventTarget);
  dispatchEventForPluginEventSystem(
    domEventName,
    eventSystemFlags,
    nativeEvent,
    targetInst,
    targetContainer
  );
}


export function getEventPriority(domEventName) {
  switch (domEventName) {
    case &apos;click&apos;:
      return DiscreteEventPriority;
    case &apos;drag&apos;:
      return ContinuousEventPriority;
    default:
      return DefaultEventPriority;
  }
}
</code></pre>
<h2 id="t27538.&#x5E76;&#x53D1;&#x6E32;&#x67D3;">38.&#x5E76;&#x53D1;&#x6E32;&#x67D3; <a href="#t27538.&#x5E76;&#x53D1;&#x6E32;&#x67D3;"> # </a></h2>
<h3 id="t27638.1  src\main.jsx">38.1  src\main.jsx <a href="#t27638.1  src\main.jsx"> # </a></h3>
<p>src\main.jsx</p>
<pre><code class="lang-diff">import * as React from &quot;react&quot;;
import { createRoot } from &quot;react-dom/client&quot;;

<span class="hljs-addition">+function FunctionComponent() {</span>
<span class="hljs-addition">+  console.log(&apos;FunctionComponent&apos;);</span>
<span class="hljs-addition">+  const [number, setNumber] = React.useState(0);</span>
<span class="hljs-addition">+  React.useEffect(() =&gt; {</span>
<span class="hljs-addition">+    setNumber(number =&gt; number + 1)</span>
<span class="hljs-addition">+  }, []);</span>
<span class="hljs-addition">+  return (&lt;button onClick={() =&gt; setNumber(number + 1)}&gt;{number}&lt;/button&gt;)</span>
<span class="hljs-addition">+}</span>
const element = &lt;FunctionComponent /&gt;;
const container = document.getElementById(&quot;root&quot;);
const root = createRoot(container, { unstable_concurrentUpdatesByDefault: true });
root.render(element);
</code></pre>
<h3 id="t27738.2  ReactFiberWorkLoop.js">38.2  ReactFiberWorkLoop.js <a href="#t27738.2  ReactFiberWorkLoop.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberWorkLoop.js</p>
<pre><code class="lang-diff">import {
  scheduleCallback as Scheduler_scheduleCallback,
  ImmediatePriority as ImmediateSchedulerPriority,
  UserBlockingPriority as UserBlockingSchedulerPriority,
  NormalPriority as NormalSchedulerPriority,
  IdlePriority as IdleSchedulerPriority,
<span class="hljs-addition">+ shouldYield</span>
} from &quot;./Scheduler&quot;;
import { createWorkInProgress } from &quot;./ReactFiber&quot;;
import { beginWork } from &quot;./ReactFiberBeginWork&quot;;
import { completeWork } from &quot;./ReactFiberCompleteWork&quot;;
import { MutationMask, NoFlags, Passive } from &quot;./ReactFiberFlags&quot;;
import {
  commitMutationEffects,
  commitPassiveUnmountEffects,
  commitPassiveMountEffects,
  commitLayoutEffects,
} from &quot;./ReactFiberCommitWork&quot;;
import { finishQueueingConcurrentUpdates } from &quot;./ReactFiberConcurrentUpdates&quot;;
import {
  NoLane, markRootUpdated, NoLanes,
  getNextLanes, getHighestPriorityLane, SyncLane,
  includesBlockingLane
} from &apos;./ReactFiberLane&apos;;
import {
  getCurrentUpdatePriority, lanesToEventPriority, DiscreteEventPriority, ContinuousEventPriority,
  DefaultEventPriority, IdleEventPriority, setCurrentUpdatePriority
} from &apos;./ReactEventPriorities&apos;;
import { getCurrentEventPriority } from &apos;react-dom-bindings/src/client/ReactDOMHostConfig&apos;;
import { scheduleSyncCallback, flushSyncCallbacks } from &apos;./ReactFiberSyncTaskQueue&apos;;

let workInProgress = null;
let rootDoesHavePassiveEffects = false;
let rootWithPendingPassiveEffects = null;
let workInProgressRootRenderLanes = NoLanes;

<span class="hljs-addition">+const RootInProgress = 0;</span>
<span class="hljs-addition">+const RootCompleted = 5;</span>
<span class="hljs-addition">+let workInProgressRoot = null;</span>
<span class="hljs-addition">+let workInProgressRootExitStatus = RootInProgress;</span>

export function scheduleUpdateOnFiber(root, fiber, lane) {
  markRootUpdated(root, lane);
  ensureRootIsScheduled(root);
}
function ensureRootIsScheduled(root) {
  const nextLanes = getNextLanes(root, NoLanes);
<span class="hljs-addition">+ if (nextLanes === NoLanes) {</span>
<span class="hljs-addition">+   root.callbackNode = null;</span>
<span class="hljs-addition">+   root.callbackPriority = NoLane;</span>
<span class="hljs-addition">+   return;</span>
<span class="hljs-addition">+ }</span>
  const newCallbackPriority = getHighestPriorityLane(nextLanes);
<span class="hljs-addition">+ let newCallbackNode;</span>
  if (newCallbackPriority <span class="hljs-comment">=== SyncLane) {</span>
    scheduleSyncCallback(performSyncWorkOnRoot.bind(null, root));
    queueMicrotask(flushSyncCallbacks);
<span class="hljs-addition">+   newCallbackNode = null;</span>
  } else {
    let schedulerPriorityLevel;
    switch (lanesToEventPriority(nextLanes)) {
      case DiscreteEventPriority:
        schedulerPriorityLevel = ImmediateSchedulerPriority;
        break;
      case ContinuousEventPriority:
        schedulerPriorityLevel = UserBlockingSchedulerPriority;
        break;
      case DefaultEventPriority:
        schedulerPriorityLevel = NormalSchedulerPriority;
        break;
      case IdleEventPriority:
        schedulerPriorityLevel = IdleSchedulerPriority;
        break;
      default:
        schedulerPriorityLevel = NormalSchedulerPriority;
        break;
    }
<span class="hljs-addition">+   newCallbackNode = Scheduler_scheduleCallback(schedulerPriorityLevel, performConcurrentWorkOnRoot.bind(null, root))</span>
  }
<span class="hljs-addition">+ root.callbackNode = newCallbackNode;</span>
}
function performSyncWorkOnRoot(root) {
  const lanes = getNextLanes(root, NoLanes);
  renderRootSync(root, lanes);
  const finishedWork = root.current.alternate
  root.finishedWork = finishedWork
  commitRoot(root)
  return null;
}
function performConcurrentWorkOnRoot(root, didTimeout) {
<span class="hljs-addition">+ const originalCallbackNode = root.callbackNode;</span>
  const lanes = getNextLanes(root, NoLanes);
  if (lanes <span class="hljs-comment">=== NoLanes) {</span>
    return null;
  }
  const shouldTimeSlice = !includesBlockingLane(root, lanes) &amp;&amp; (!didTimeout);
<span class="hljs-addition">+ const exitStatus = shouldTimeSlice ? renderRootConcurrent(root, lanes) : renderRootSync(root, lanes);</span>
<span class="hljs-addition">+ if (exitStatus !== RootInProgress) {</span>
<span class="hljs-addition">+   const finishedWork = root.current.alternate</span>
<span class="hljs-addition">+   root.finishedWork = finishedWork</span>
<span class="hljs-addition">+   commitRoot(root)</span>
<span class="hljs-addition">+ }</span>
<span class="hljs-addition">+ if (root.callbackNode === originalCallbackNode) {</span>
<span class="hljs-addition">+   return performConcurrentWorkOnRoot.bind(null, root);</span>
<span class="hljs-addition">+ }</span>
<span class="hljs-addition">+ return null;</span>
}
function renderRootConcurrent(root, lanes) {
<span class="hljs-addition">+ if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {</span>
<span class="hljs-addition">+   prepareFreshStack(root, lanes);</span>
<span class="hljs-addition">+ }</span>
<span class="hljs-addition">+ workLoopConcurrent();</span>
<span class="hljs-addition">+ if (workInProgress !== null) {</span>
<span class="hljs-addition">+   return RootInProgress;</span>
<span class="hljs-addition">+ }</span>
<span class="hljs-addition">+ workInProgressRoot = null;</span>
<span class="hljs-addition">+ workInProgressRootRenderLanes = NoLanes;</span>
<span class="hljs-addition">+ return workInProgressRootExitStatus;</span>
}
<span class="hljs-addition">+function workLoopConcurrent() {</span>
<span class="hljs-addition">+  sleep(6);</span>
<span class="hljs-addition">+  performUnitOfWork(workInProgress);</span>
<span class="hljs-addition">+  console.log(&apos;shouldYield()&apos;, shouldYield(), workInProgress?.type);</span>
<span class="hljs-addition">+}</span>
export function flushPassiveEffects() {
  if (rootWithPendingPassiveEffects !== null) {
    const root = rootWithPendingPassiveEffects;
    commitPassiveUnmountEffects(root.current);
    commitPassiveMountEffects(root, root.current);
  }
}
function commitRoot(root) {
  const previousPriority = getCurrentUpdatePriority();
  try {
    setCurrentUpdatePriority(DiscreteEventPriority);
    commitRootImpl(root);
  } finally {
    setCurrentUpdatePriority(previousPriority);
  }
}
function commitRootImpl(root) {
  const { finishedWork } = root;
<span class="hljs-addition">+ root.callbackNode = null;</span>
<span class="hljs-addition">+ root.callbackPriority = NoLane;</span>
<span class="hljs-addition">+ workInProgressRoot = null;</span>
<span class="hljs-addition">+ workInProgressRootRenderLanes = NoLanes;</span>
  if ((finishedWork.subtreeFlags &amp; Passive) !== NoFlags || (finishedWork.flags &amp; Passive) !== NoFlags) {
    if (!rootDoesHavePassiveEffects) {
      rootDoesHavePassiveEffects = true;
      Scheduler_scheduleCallback(NormalSchedulerPriority, flushPassiveEffects);
    }
  }
  const subtreeHasEffects = (finishedWork.subtreeFlags &amp; MutationMask) !== NoFlags;
  const rootHasEffect = (finishedWork.flags &amp; MutationMask) !== NoFlags;
  if (subtreeHasEffects || rootHasEffect) {
    commitMutationEffects(finishedWork, root);
    commitLayoutEffects(finishedWork, root);
    root.current = finishedWork;
    if (rootDoesHavePassiveEffects) {
      rootDoesHavePassiveEffects = false;
      rootWithPendingPassiveEffects = root;
    }
  }
  root.current = finishedWork;
}
function prepareFreshStack(root, lanes) {
<span class="hljs-addition">+ workInProgressRoot = root;</span>
  workInProgress = createWorkInProgress(root.current, null);
  workInProgressRootRenderLanes = lanes;
  finishQueueingConcurrentUpdates();
}
function renderRootSync(root, lanes) {
<span class="hljs-addition">+ //&#x4E0D;&#x662F;&#x4E00;&#x4E2A;&#x6839;&#xFF0C;&#x6216;&#x8005;&#x662F;&#x66F4;&#x9AD8;&#x4F18;&#x5148;&#x7EA7;&#x7684;&#x66F4;&#x65B0;</span>
<span class="hljs-addition">+ if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {</span>
    prepareFreshStack(root, lanes)
<span class="hljs-addition">+ }</span>
  workLoopSync();
<span class="hljs-addition">+ return workInProgressRootExitStatus;</span>
}

function workLoopSync() {
  while (workInProgress !== null) {
    performUnitOfWork(workInProgress);
  }
}
function performUnitOfWork(unitOfWork) {
  const current = unitOfWork.alternate;
  const next = beginWork(current, unitOfWork, workInProgressRootRenderLanes);
  unitOfWork.memoizedProps = unitOfWork.pendingProps;
  if (next <span class="hljs-comment">=== null) {</span>
    completeUnitOfWork(unitOfWork);
  } else {
    workInProgress = next;
  }
}

function completeUnitOfWork(unitOfWork) {
  let completedWork = unitOfWork;
  do {
    const current = completedWork.alternate;
    const returnFiber = completedWork.return;
    completeWork(current, completedWork);
    const siblingFiber = completedWork.sibling;
    if (siblingFiber !== null) {
      workInProgress = siblingFiber;
      return;
    }
    completedWork = returnFiber;
    workInProgress = completedWork;
  } while (completedWork !== null);
<span class="hljs-addition">+ if (workInProgressRootExitStatus === RootInProgress) {</span>
<span class="hljs-addition">+   workInProgressRootExitStatus = RootCompleted;</span>
<span class="hljs-addition">+ }</span>
}

export function requestUpdateLane() {
  const updateLane = getCurrentUpdatePriority();
  if (updateLane !== NoLane) {
    return updateLane;
  }
  const eventLane = getCurrentEventPriority();
  return eventLane;
}

<span class="hljs-addition">+function sleep(time) {</span>
<span class="hljs-addition">+  const timeStamp = new Date().getTime();</span>
<span class="hljs-addition">+  const endTime = timeStamp + time;</span>
<span class="hljs-addition">+  while (true) {</span>
<span class="hljs-addition">+    if (new Date().getTime() &gt; endTime) {</span>
<span class="hljs-addition">+      return;</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+}</span>
</code></pre>
<h3 id="t27838.3 Scheduler.js">38.3 Scheduler.js <a href="#t27838.3 Scheduler.js"> # </a></h3>
<p>src\react-reconciler\src\Scheduler.js</p>
<pre><code class="lang-diff">import * as Scheduler from &apos;scheduler&apos;
export const scheduleCallback = Scheduler.unstable_scheduleCallback
export const NormalPriority = Scheduler.unstable_NormalPriority
export const ImmediatePriority = Scheduler.unstable_ImmediatePriority;
export const UserBlockingPriority = Scheduler.unstable_UserBlockingPriority;
export const LowPriority = Scheduler.unstable_LowPriority;
export const IdlePriority = Scheduler.unstable_IdlePriority;
<span class="hljs-addition">+export const shouldYield = Scheduler.unstable_shouldYield</span>
</code></pre>
<h3 id="t27938.4 Scheduler.js">38.4 Scheduler.js <a href="#t27938.4 Scheduler.js"> # </a></h3>
<p>src\scheduler\src\forks\Scheduler.js</p>
<pre><code class="lang-diff">import {
  ImmediatePriority,
  UserBlockingPriority,
  NormalPriority,
  LowPriority,
  IdlePriority,
} from &quot;../SchedulerPriorities&quot;;
import { push, pop, peek } from &quot;../SchedulerMinHeap&quot;;
import { frameYieldMs } from &quot;../SchedulerFeatureFlags&quot;;

const maxSigned31BitInt = 1073741823;
const IMMEDIATE_PRIORITY_TIMEOUT = -1;
const USER_BLOCKING_PRIORITY_TIMEOUT = 250;
const NORMAL_PRIORITY_TIMEOUT = 5000;
const LOW_PRIORITY_TIMEOUT = 10000;
const IDLE_PRIORITY_TIMEOUT = maxSigned31BitInt;

const taskQueue = [];
let taskIdCounter = 1;
let scheduledHostCallback = null;
let startTime = -1;
let currentTask = null;
const frameInterval = frameYieldMs;
const channel = new MessageChannel();
const port = channel.port2;

const getCurrentTime = () =&gt; performance.now();
channel.port1.onmessage = performWorkUntilDeadline;

function schedulePerformWorkUntilDeadline() {
  port.postMessage(null);
}
function performWorkUntilDeadline() {
  if (scheduledHostCallback !== null) {
    startTime = getCurrentTime();
    let hasMoreWork = true;
    try {
      hasMoreWork = scheduledHostCallback(startTime);
    } finally {
      if (hasMoreWork) {
        schedulePerformWorkUntilDeadline();
      } else {
        scheduledHostCallback = null;
      }
    }
  }
}
function requestHostCallback(callback) {
  scheduledHostCallback = callback;
  schedulePerformWorkUntilDeadline();
}

function unstable_scheduleCallback(priorityLevel, callback) {
  const currentTime = getCurrentTime();
  const startTime = currentTime;
  let timeout;
  switch (priorityLevel) {
    case ImmediatePriority:
      timeout = IMMEDIATE_PRIORITY_TIMEOUT;
      break;
    case UserBlockingPriority:
      timeout = USER_BLOCKING_PRIORITY_TIMEOUT;
      break;
    case IdlePriority:
      timeout = IDLE_PRIORITY_TIMEOUT;
      break;
    case LowPriority:
      timeout = LOW_PRIORITY_TIMEOUT;
      break;
    case NormalPriority:
    default:
      timeout = NORMAL_PRIORITY_TIMEOUT;
      break;
  }
  const expirationTime = startTime + timeout;
  const newTask = {
    id: taskIdCounter++,
    callback,
    priorityLevel,
    startTime,
    expirationTime,
    sort<span class="hljs-comment">Index: -1,</span>
  };
  newTask.sortIndex = expirationTime;
  push(taskQueue, newTask);
  requestHostCallback(flushWork);
  return newTask;
}

function flushWork(initialTime) {
  return workLoop(initialTime);
}

function shouldYieldToHost() {
  const timeElapsed = getCurrentTime() - startTime;
  if (timeElapsed &lt; frameInterval) {
    return false;
  }
  return true;
}
function workLoop(initialTime) {
  let currentTime = initialTime;
  currentTask = peek(taskQueue);
  while (currentTask !== null) {
    if (currentTask.expirationTime &gt; currentTime &amp;&amp; shouldYieldToHost()) {
      break;
    }
    const callback = currentTask.callback;
    if (typeof callback <span class="hljs-comment">=== &quot;function&quot;) {</span>
      currentTask.callback = null;
      const didUserCallbackTimeout = currentTask.expirationTime &lt;= currentTime;
      const continuationCallback = callback(didUserCallbackTimeout);
      currentTime = getCurrentTime();
      if (typeof continuationCallback <span class="hljs-comment">=== &quot;function&quot;) {</span>
        currentTask.callback = continuationCallback;
        return true;
      }
      if (currentTask <span class="hljs-comment">=== peek(taskQueue)) {</span>
        pop(taskQueue);
      }
    } else {
      pop(taskQueue);
    }
    currentTask = peek(taskQueue);
  }
  if (currentTask !== null) {
    return true;
  }
  return false;
}

export {
  NormalPriority as unstable_NormalPriority,
  unstable_scheduleCallback,
<span class="hljs-addition">+ shouldYieldToHost as unstable_shouldYield</span>
};
</code></pre>
<h3 id="t28038.5 ReactFiberLane.js">38.5 ReactFiberLane.js <a href="#t28038.5 ReactFiberLane.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberLane.js</p>
<pre><code class="lang-diff"><span class="hljs-addition">+import { allowConcurrentByDefault } from &apos;shared/ReactFeatureFlags&apos;;</span>

export const TotalLanes = 31;
export const NoLanes = 0b0000000000000000000000000000000;
export const NoLane = 0b0000000000000000000000000000000;
export const SyncLane = 0b0000000000000000000000000000001;// 1
export const InputContinuousLane = 0b0000000000000000000000000000100;// 4
export const DefaultLane = 0b0000000000000000000000000010000;// 16
export const NonIdleLanes = 0b0001111111111111111111111111111;
export const IdleLane = 0b0100000000000000000000000000000;

export function mergeLanes(a, b) {
  return a | b;
}
export function markRootUpdated(root, updateLane) {
  root.pendingLanes |= updateLane;
}

export function getNextLanes(root) {
  const pendingLanes = root.pendingLanes;
  if (pendingLanes <span class="hljs-comment">=== NoLanes) {</span>
    return NoLanes;
  }
  const nextLanes = getHighestPriorityLanes(pendingLanes);
  return nextLanes;
}

function getHighestPriorityLanes(lanes) {
  return getHighestPriorityLane(lanes);
}

export function getHighestPriorityLane(lanes) {
  return lanes &amp; -lanes;
}

export function includesNonIdleWork(lanes) {
  return (lanes &amp; NonIdleLanes) !== NoLanes;
}
export function includesBlockingLane(root, lanes) {
<span class="hljs-addition">+ if (allowConcurrentByDefault) {</span>
<span class="hljs-addition">+   return false;</span>
<span class="hljs-addition">+ }</span>
  const SyncDefaultLanes = InputContinuousLane | DefaultLane;
  return (lanes &amp; SyncDefaultLanes) !== NoLanes;
}
export function isSubsetOfLanes(set, subset) {
  return (set &amp; subset) <span class="hljs-comment">=== subset;</span>
}
</code></pre>
<h3 id="t28138.6 ReactFeatureFlags.js">38.6 ReactFeatureFlags.js <a href="#t28138.6 ReactFeatureFlags.js"> # </a></h3>
<p>src\shared\ReactFeatureFlags.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> allowConcurrentByDefault = <span class="hljs-literal">true</span>; 
</code></pre>
<h2 id="t28239.&#x6279;&#x91CF;&#x66F4;&#x65B0;">39.&#x6279;&#x91CF;&#x66F4;&#x65B0; <a href="#t28239.&#x6279;&#x91CF;&#x66F4;&#x65B0;"> # </a></h2>
<h3 id="t28339.1  src\main.jsx">39.1  src\main.jsx <a href="#t28339.1  src\main.jsx"> # </a></h3>
<p>src\main.jsx</p>
<pre><code class="lang-diff">import * as React from &quot;react&quot;;
import { createRoot } from &quot;react-dom/client&quot;;

<span class="hljs-addition">+function FunctionComponent() {</span>
<span class="hljs-addition">+  console.log(&apos;FunctionComponent&apos;);</span>
<span class="hljs-addition">+  const [number, setNumber] = React.useState(0);</span>
<span class="hljs-addition">+  React.useEffect(() =&gt; {</span>
<span class="hljs-addition">+    setNumber(number =&gt; number + 1)</span>
<span class="hljs-addition">+    setNumber(number =&gt; number + 1)</span>
<span class="hljs-addition">+  }, []);</span>
<span class="hljs-addition">+  return (&lt;button onClick={() =&gt; {</span>
<span class="hljs-addition">+    setNumber(number =&gt; number + 1)</span>
<span class="hljs-addition">+    setNumber(number =&gt; number + 1)</span>
<span class="hljs-addition">+  }}&gt;{number}&lt;/button&gt;)</span>
<span class="hljs-addition">+}</span>
const element = &lt;FunctionComponent /&gt;;
const container = document.getElementById(&quot;root&quot;);
const root = createRoot(container, { unstable_concurrentUpdatesByDefault: true });
root.render(element);
</code></pre>
<h3 id="t28439.2 ReactFiberHooks.js">39.2 ReactFiberHooks.js <a href="#t28439.2 ReactFiberHooks.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberHooks.js</p>
<pre><code class="lang-diff">import ReactSharedInternals from &quot;shared/ReactSharedInternals&quot;;
import { enqueueConcurrentHookUpdate } from &quot;./ReactFiberConcurrentUpdates&quot;;
import { scheduleUpdateOnFiber, requestUpdateLane } from &quot;./ReactFiberWorkLoop&quot;;
import is from &quot;shared/objectIs&quot;;
import { Passive as PassiveEffect, Update as UpdateEffect } from &quot;./ReactFiberFlags&quot;;
import { HasEffect as HookHasEffect, Passive as HookPassive, Layout as HookLayout } from &quot;./ReactHookEffectTags&quot;;
<span class="hljs-addition">+import { NoLanes } from &apos;./ReactFiberLane&apos;;</span>

const { ReactCurrentDispatcher } = ReactSharedInternals;
let currentlyRenderingFiber = null;
let workInProgressHook = null;
let currentHook = null;

const HooksDispatcherOnMountInDEV = {
  useReducer: mountReducer,
  useState: mountState,
  useEffect: mountEffect,
  useLayoutEffect: mountLayoutEffect,
};
const HooksDispatcherOnUpdateInDEV = {
  useReducer: updateReducer,
  useState: updateState,
  useEffect: updateEffect,
  useLayoutEffect: updateLayoutEffect,
};
export function useLayoutEffect(reducer, initialArg) {
  return ReactCurrentDispatcher.current.useLayoutEffect(reducer, initialArg);
}
function updateLayoutEffect(create, deps) {
  return updateEffectImpl(UpdateEffect, HookLayout, create, deps);
}
function mountLayoutEffect(create, deps) {
  const fiberFlags = UpdateEffect;
  return mountEffectImpl(fiberFlags, HookLayout, create, deps);
}
function updateEffect(create, deps) {
  return updateEffectImpl(PassiveEffect, HookPassive, create, deps);
}
function updateEffectImpl(fiberFlags, hookFlags, create, deps) {
  const hook = updateWorkInProgressHook();
  const nextDeps = deps <span class="hljs-comment">=== undefined ? null : deps;</span>
  let destroy;
  if (currentHook !== null) {
    const prevEffect = currentHook.memoizedState;
    destroy = prevEffect.destroy;
    if (nextDeps !== null) {
      const prevDeps = prevEffect.deps;
      if (areHookInputsEqual(nextDeps, prevDeps)) {
        hook.memoizedState = pushEffect(hookFlags, create, destroy, nextDeps);
        return;
      }
    }
  }
  currentlyRenderingFiber.flags |= fiberFlags;
  hook.memoizedState = pushEffect(HookHasEffect | hookFlags, create, destroy, nextDeps);
}
function areHookInputsEqual(nextDeps, prevDeps) {
  if (prevDeps <span class="hljs-comment">=== null) {</span>
    return false;
  }
  for (let i = 0; i &lt; prevDeps.length &amp;&amp; i &lt; nextDeps.length; i++) {
    if (is(nextDeps[i], prevDeps[i])) {
      continue;
    }
    return false;
  }

  return true;
}
function mountEffect(create, deps) {
  return mountEffectImpl(PassiveEffect, HookPassive, create, deps);
}
function mountEffectImpl(fiberFlags, hookFlags, create, deps) {
  const hook = mountWorkInProgressHook();
  const nextDeps = deps <span class="hljs-comment">=== undefined ? null : deps;</span>
  currentlyRenderingFiber.flags |= fiberFlags;
  hook.memoizedState = pushEffect(HookHasEffect | hookFlags, create, undefined, nextDeps);
}
function pushEffect(tag, create, destroy, deps) {
  const effect = {
    tag,
    create,
    destroy,
    deps,
    next: null,
  };
  let componentUpdateQueue = currentlyRenderingFiber.updateQueue;
  if (componentUpdateQueue <span class="hljs-comment">=== null) {</span>
    componentUpdateQueue = createFunctionComponentUpdateQueue();
    currentlyRenderingFiber.updateQueue = componentUpdateQueue;
    componentUpdateQueue.lastEffect = effect.next = effect;
  } else {
    const lastEffect = componentUpdateQueue.lastEffect;
    if (lastEffect <span class="hljs-comment">=== null) {</span>
      componentUpdateQueue.lastEffect = effect.next = effect;
    } else {
      const firstEffect = lastEffect.next;
      lastEffect.next = effect;
      effect.next = firstEffect;
      componentUpdateQueue.lastEffect = effect;
    }
  }
  return effect;
}
function createFunctionComponentUpdateQueue() {
  return {
    lastEffect: null,
  };
}
function basicStateReducer(state, action) {
  return typeof action <span class="hljs-comment">=== &quot;function&quot; ? action(state) : action;</span>
}
function mountReducer(reducer, initialArg) {
  const hook = mountWorkInProgressHook();
  hook.memoizedState = initialArg;
  const queue = {
    pending: null,
    dispatch: null,
  };
  hook.queue = queue;
  const dispatch = (queue.dispatch = dispatchReducerAction.bind(null, currentlyRenderingFiber, queue));
  return [hook.memoizedState, dispatch];
}
function updateReducer(reducer) {
  const hook = updateWorkInProgressHook();
  const queue = hook.queue;
  queue.lastRenderedReducer = reducer;
  const current = currentHook;
  const pendingQueue = queue.pending;
  let baseQueue = null;
  let newState = current.memoizedState;
  if (pendingQueue !== null) {
    baseQueue = pendingQueue;
    queue.pending = null;
  }
  if (baseQueue !== null) {
    const first = baseQueue.next;
    let update = first;
    do {
      if (update.hasEagerState) {
        newState = update.eagerState;
      } else {
        const action = update.action;
        newState = reducer(newState, action);
      }
      update = update.next;
    } while (update !== null &amp;&amp; update !== first);
  }
  hook.memoizedState = newState;
  queue.lastRenderedState = newState;
  const dispatch = queue.dispatch;
  return [hook.memoizedState, dispatch];
}
function mountState(initialState) {
  const hook = mountWorkInProgressHook();
  hook.memoizedState = initialState;
  const queue = {
    pending: null,
    dispatch: null,
    lastRenderedReducer: basicStateReducer,
    lastRenderedState: initialState,
  };
  hook.queue = queue;
  const dispatch = (queue.dispatch = dispatchSetState.bind(null, currentlyRenderingFiber, queue));
  return [hook.memoizedState, dispatch];
}
function dispatchSetState(fiber, queue, action) {
  const lane = requestUpdateLane(fiber);
  const update = {
    lane,
    action,
    hasEagerState: false,
    eagerState: null,
    next: null,
  };
<span class="hljs-addition">+ const alternate = fiber.alternate;</span>
<span class="hljs-addition">+ if (fiber.lanes === NoLanes &amp;&amp; (alternate === null || alternate.lanes === NoLanes)) {</span>
    const lastRenderedReducer = queue.lastRenderedReducer;
    const currentState = queue.lastRenderedState;
    const eagerState = lastRenderedReducer(currentState, action);
    update.hasEagerState = true;
    update.eagerState = eagerState;
    if (is(eagerState, currentState)) {
      return;
    }
<span class="hljs-addition">+ }</span>
  const root = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
  scheduleUpdateOnFiber(root, fiber, lane);
}
function updateState(initialState) {
  return updateReducer(basicStateReducer, initialState);
}
function mountWorkInProgressHook() {
  const hook = {
    memoizedState: null,
    queue: null,
    next: null,
  };
  if (workInProgressHook <span class="hljs-comment">=== null) {</span>
    currentlyRenderingFiber.memoizedState = workInProgressHook = hook;
  } else {
    workInProgressHook = workInProgressHook.next = hook;
  }
  return workInProgressHook;
}
function dispatchReducerAction(fiber, queue, action) {
  const update = {
    action,
    next: null,
  };
  const root = enqueueConcurrentHookUpdate(fiber, queue, update);
  scheduleUpdateOnFiber(root, fiber);
}

function updateWorkInProgressHook() {
  let nextCurrentHook;
  if (currentHook <span class="hljs-comment">=== null) {</span>
    const current = currentlyRenderingFiber.alternate;
    if (current !== null) {
      nextCurrentHook = current.memoizedState;
    } else {
      nextCurrentHook = null;
    }
  } else {
    nextCurrentHook = currentHook.next;
  }

  let nextWorkInProgressHook;
  if (workInProgressHook <span class="hljs-comment">=== null) {</span>
    nextWorkInProgressHook = currentlyRenderingFiber.memoizedState;
  } else {
    nextWorkInProgressHook = workInProgressHook.next;
  }

  if (nextWorkInProgressHook !== null) {
    workInProgressHook = nextWorkInProgressHook;
    nextWorkInProgressHook = workInProgressHook.next;
    currentHook = nextCurrentHook;
  } else {
    currentHook = nextCurrentHook;
    const newHook = {
      memoizedState: currentHook.memoizedState,
      queue: currentHook.queue,
      next: null,
    };
    if (workInProgressHook <span class="hljs-comment">=== null) {</span>
      currentlyRenderingFiber.memoizedState = workInProgressHook = newHook;
    } else {
      workInProgressHook = workInProgressHook.next = newHook;
    }
  }
  return workInProgressHook;
}

export function renderWithHooks(current, workInProgress, Component, props) {
  currentlyRenderingFiber = workInProgress;
  workInProgress.updateQueue = null;
  workInProgress.memoizedState = null;
  if (current !== null &amp;&amp; current.memoizedState !== null) {
    ReactCurrentDispatcher.current = HooksDispatcherOnUpdateInDEV;
  } else {
    ReactCurrentDispatcher.current = HooksDispatcherOnMountInDEV;
  }
  const children = Component(props);
  currentlyRenderingFiber = null;
  workInProgressHook = null;
  currentHook = null;
  return children;
}
</code></pre>
<h3 id="t28539.3  ReactFiberWorkLoop.js">39.3  ReactFiberWorkLoop.js <a href="#t28539.3  ReactFiberWorkLoop.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberWorkLoop.js</p>
<pre><code class="lang-diff">import {
  scheduleCallback as Scheduler_scheduleCallback,
  ImmediatePriority as ImmediateSchedulerPriority,
  UserBlockingPriority as UserBlockingSchedulerPriority,
  NormalPriority as NormalSchedulerPriority,
  IdlePriority as IdleSchedulerPriority,
  shouldYield
} from &quot;./Scheduler&quot;;
import { createWorkInProgress } from &quot;./ReactFiber&quot;;
import { beginWork } from &quot;./ReactFiberBeginWork&quot;;
import { completeWork } from &quot;./ReactFiberCompleteWork&quot;;
import { MutationMask, NoFlags, Passive } from &quot;./ReactFiberFlags&quot;;
import {
  commitMutationEffects,
  commitPassiveUnmountEffects,
  commitPassiveMountEffects,
  commitLayoutEffects,
} from &quot;./ReactFiberCommitWork&quot;;
import { finishQueueingConcurrentUpdates } from &quot;./ReactFiberConcurrentUpdates&quot;;
import {
  NoLane, markRootUpdated, NoLanes,
  getNextLanes, getHighestPriorityLane, SyncLane,
  includesBlockingLane
} from &apos;./ReactFiberLane&apos;;
import {
  getCurrentUpdatePriority, lanesToEventPriority, DiscreteEventPriority, ContinuousEventPriority,
  DefaultEventPriority, IdleEventPriority, setCurrentUpdatePriority
} from &apos;./ReactEventPriorities&apos;;
import { getCurrentEventPriority } from &apos;react-dom-bindings/src/client/ReactDOMHostConfig&apos;;
import { scheduleSyncCallback, flushSyncCallbacks } from &apos;./ReactFiberSyncTaskQueue&apos;;

let workInProgress = null;
let rootDoesHavePassiveEffects = false;
let rootWithPendingPassiveEffects = null;
let workInProgressRootRenderLanes = NoLanes;

const RootInProgress = 0;
const RootCompleted = 5;
let workInProgressRoot = null;
let workInProgressRootExitStatus = RootInProgress;

export function scheduleUpdateOnFiber(root, fiber, lane) {
  markRootUpdated(root, lane);
  ensureRootIsScheduled(root);
}
function ensureRootIsScheduled(root) {
  const nextLanes = getNextLanes(root, NoLanes);
  if (nextLanes <span class="hljs-comment">=== NoLanes) {</span>
    root.callbackNode = null;
    root.callbackPriority = NoLane;
    return;
  }
  const newCallbackPriority = getHighestPriorityLane(nextLanes);
<span class="hljs-addition">+ const existingCallbackPriority = root.callbackPriority;</span>
<span class="hljs-addition">+ if (existingCallbackPriority === newCallbackPriority) {</span>
<span class="hljs-addition">+   return;</span>
<span class="hljs-addition">+ }</span>
<span class="hljs-addition">+  let newCallbackNode;</span>
  if (newCallbackPriority <span class="hljs-comment">=== SyncLane) {</span>
    scheduleSyncCallback(performSyncWorkOnRoot.bind(null, root));
    queueMicrotask(flushSyncCallbacks);
    newCallbackNode = null;
  } else {
    let schedulerPriorityLevel;
    switch (lanesToEventPriority(nextLanes)) {
      case DiscreteEventPriority:
        schedulerPriorityLevel = ImmediateSchedulerPriority;
        break;
      case ContinuousEventPriority:
        schedulerPriorityLevel = UserBlockingSchedulerPriority;
        break;
      case DefaultEventPriority:
        schedulerPriorityLevel = NormalSchedulerPriority;
        break;
      case IdleEventPriority:
        schedulerPriorityLevel = IdleSchedulerPriority;
        break;
      default:
        schedulerPriorityLevel = NormalSchedulerPriority;
        break;
    }
<span class="hljs-addition">+   newCallbackNode = Scheduler_scheduleCallback(schedulerPriorityLevel, performConcurrentWorkOnRoot.bind(null, root))</span>
  }
<span class="hljs-addition">+ root.callbackPriority = newCallbackPriority;</span>
<span class="hljs-addition">+ root.callbackNode = newCallbackNode;</span>
}
function performSyncWorkOnRoot(root) {
  const lanes = getNextLanes(root, NoLanes);
  renderRootSync(root, lanes);
  const finishedWork = root.current.alternate
  root.finishedWork = finishedWork
  commitRoot(root)
  return null;
}
function performConcurrentWorkOnRoot(root, didTimeout) {
  const originalCallbackNode = root.callbackNode;
  const lanes = getNextLanes(root, NoLanes);
  if (lanes <span class="hljs-comment">=== NoLanes) {</span>
    return null;
  }
  const shouldTimeSlice = !includesBlockingLane(root, lanes) &amp;&amp; (!didTimeout);
  const exitStatus = shouldTimeSlice ? renderRootConcurrent(root, lanes) : renderRootSync(root, lanes);
  if (exitStatus !== RootInProgress) {
    const finishedWork = root.current.alternate
    root.finishedWork = finishedWork
    commitRoot(root)
  }
  if (root.callbackNode <span class="hljs-comment">=== originalCallbackNode) {</span>
    return performConcurrentWorkOnRoot.bind(null, root);
  }
  return null;
}
function renderRootConcurrent(root, lanes) {
  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {
    prepareFreshStack(root, lanes);
  }
  workLoopConcurrent();
  if (workInProgress !== null) {
    return RootInProgress;
  }
  workInProgressRoot = null;
  workInProgressRootRenderLanes = NoLanes;
  return workInProgressRootExitStatus;
}
function workLoopConcurrent() {
  while (workInProgress !== null &amp;&amp; !shouldYield()) {
    performUnitOfWork(workInProgress);
  }
}
export function flushPassiveEffects() {
  if (rootWithPendingPassiveEffects !== null) {
    const root = rootWithPendingPassiveEffects;
    commitPassiveUnmountEffects(root.current);
    commitPassiveMountEffects(root, root.current);
  }
}
function commitRoot(root) {
  const previousPriority = getCurrentUpdatePriority();
  try {
    setCurrentUpdatePriority(DiscreteEventPriority);
    commitRootImpl(root);
  } finally {
    setCurrentUpdatePriority(previousPriority);
  }
}
function commitRootImpl(root) {
  const { finishedWork } = root;
  root.callbackNode = null;
<span class="hljs-addition">+ root.callbackPriority = NoLane;</span>
  if ((finishedWork.subtreeFlags &amp; Passive) !== NoFlags || (finishedWork.flags &amp; Passive) !== NoFlags) {
    if (!rootDoesHavePassiveEffects) {
      rootDoesHavePassiveEffects = true;
      Scheduler_scheduleCallback(NormalSchedulerPriority, flushPassiveEffects);
    }
  }
  const subtreeHasEffects = (finishedWork.subtreeFlags &amp; MutationMask) !== NoFlags;
  const rootHasEffect = (finishedWork.flags &amp; MutationMask) !== NoFlags;
  if (subtreeHasEffects || rootHasEffect) {
    commitMutationEffects(finishedWork, root);
    commitLayoutEffects(finishedWork, root);
    root.current = finishedWork;
    if (rootDoesHavePassiveEffects) {
      rootDoesHavePassiveEffects = false;
      rootWithPendingPassiveEffects = root;
    }
  }
  root.current = finishedWork;
}
function prepareFreshStack(root, lanes) {
  workInProgress = createWorkInProgress(root.current, null);
  workInProgressRootRenderLanes = lanes;
  finishQueueingConcurrentUpdates();
}
function renderRootSync(root, lanes) {
  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {
    prepareFreshStack(root, lanes)
  }
  workLoopSync();
  workInProgressRoot = null;
  workInProgressRootRenderLanes = NoLanes;
  return workInProgressRootExitStatus;
}

function workLoopSync() {
  while (workInProgress !== null) {
    performUnitOfWork(workInProgress);
  }
}
function performUnitOfWork(unitOfWork) {
  const current = unitOfWork.alternate;
  const next = beginWork(current, unitOfWork, workInProgressRootRenderLanes);
  unitOfWork.memoizedProps = unitOfWork.pendingProps;
  if (next <span class="hljs-comment">=== null) {</span>
    completeUnitOfWork(unitOfWork);
  } else {
    workInProgress = next;
  }
}

function completeUnitOfWork(unitOfWork) {
  let completedWork = unitOfWork;
  do {
    const current = completedWork.alternate;
    const returnFiber = completedWork.return;
    completeWork(current, completedWork);
    const siblingFiber = completedWork.sibling;
    if (siblingFiber !== null) {
      workInProgress = siblingFiber;
      return;
    }
    completedWork = returnFiber;
    workInProgress = completedWork;
  } while (completedWork !== null);
  if (workInProgressRootExitStatus <span class="hljs-comment">=== RootInProgress) {</span>
    workInProgressRootExitStatus = RootCompleted;
  }
}

export function requestUpdateLane() {
  const updateLane = getCurrentUpdatePriority();
  if (updateLane !== NoLane) {
    return updateLane;
  }
  const eventLane = getCurrentEventPriority();
  return eventLane;
}
</code></pre>
<h2 id="t28640.&#x9AD8;&#x4F18;&#x66F4;&#x65B0;&#x6253;&#x65AD;&#x4F4E;&#x4F18;&#x66F4;&#x65B0;(useRef)">40.&#x9AD8;&#x4F18;&#x66F4;&#x65B0;&#x6253;&#x65AD;&#x4F4E;&#x4F18;&#x66F4;&#x65B0;(useRef) <a href="#t28640.&#x9AD8;&#x4F18;&#x66F4;&#x65B0;&#x6253;&#x65AD;&#x4F4E;&#x4F18;&#x66F4;&#x65B0;(useRef)"> # </a></h2>
<h3 id="t28740.1 src\main.jsx">40.1 src\main.jsx <a href="#t28740.1 src\main.jsx"> # </a></h3>
<p>src\main.jsx</p>
<pre><code class="lang-diff">import * as React from &quot;react&quot;;
import { createRoot } from &quot;react-dom/client&quot;;

function FunctionComponent() {
<span class="hljs-addition">+function FunctionComponent() {</span>
<span class="hljs-addition">+  const [numbers, setNumbers] = React.useState(new Array(10).fill(&apos;A&apos;));</span>
<span class="hljs-addition">+  const divRef = React.useRef();</span>
<span class="hljs-addition">+  React.useEffect(() =&gt; {</span>
<span class="hljs-addition">+    setTimeout(() =&gt; {</span>
<span class="hljs-addition">+      divRef.current.click();</span>
<span class="hljs-addition">+    }, 10);</span>
<span class="hljs-addition">+    setNumbers(numbers =&gt; numbers.map(item =&gt; item + &apos;B&apos;))</span>
<span class="hljs-addition">+  }, []);</span>
<span class="hljs-addition">+  return (&lt;div ref={divRef} onClick={() =&gt; {</span>
<span class="hljs-addition">+    setNumbers(numbers =&gt; numbers.map(item =&gt; item + &apos;C&apos;))</span>
<span class="hljs-addition">+  }}&gt;{numbers.map((number, index) =&gt; &lt;span key={index}&gt;{number}&lt;/span&gt;)}&lt;/div&gt;)</span>
<span class="hljs-addition">+}</span>
const element = &lt;FunctionComponent /&gt;;
const container = document.getElementById(&quot;root&quot;);
const root = createRoot(container, { unstable_concurrentUpdatesByDefault: true });
root.render(element);
</code></pre>
<h3 id="t28840.2 react\index.js">40.2 react\index.js <a href="#t28840.2 react\index.js"> # </a></h3>
<p>src\react\index.js</p>
<pre><code class="lang-diff">export {
  __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
  useReducer,
  useState,
  useEffect,
  useLayoutEffect,
<span class="hljs-addition">+ useRef</span>
} from &quot;./src/React&quot;;
</code></pre>
<h3 id="t28940.3 React.js">40.3 React.js <a href="#t28940.3 React.js"> # </a></h3>
<p>src\react\src\React.js</p>
<pre><code class="lang-diff"><span class="hljs-addition">+import { useReducer, useState, useEffect, useLayoutEffect, useRef } from &quot;./ReactHooks&quot;;</span>
import ReactSharedInternals from &quot;./ReactSharedInternals&quot;;

export {
  useReducer,
  useState,
  useEffect,
  useLayoutEffect,
<span class="hljs-addition">+ useRef,</span>
  ReactSharedInternals as __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
};
</code></pre>
<h3 id="t29040.4 ReactHooks.js">40.4 ReactHooks.js <a href="#t29040.4 ReactHooks.js"> # </a></h3>
<p>src\react\src\ReactHooks.js</p>
<pre><code class="lang-diff">import ReactCurrentDispatcher from &quot;./ReactCurrentDispatcher&quot;;

function resolveDispatcher() {
  const dispatcher = ReactCurrentDispatcher.current;
  return dispatcher;
}

export function useReducer(reducer, initialArg, init) {
  const dispatcher = resolveDispatcher();
  return dispatcher.useReducer(reducer, initialArg, init);
}

export function useState(initialState) {
  const dispatcher = resolveDispatcher();
  return dispatcher.useState(initialState);
}

export function useEffect(create, deps) {
  const dispatcher = resolveDispatcher();
  return dispatcher.useEffect(create, deps);
}
export function useLayoutEffect(create, deps) {
  const dispatcher = resolveDispatcher();
  return dispatcher.useLayoutEffect(create, deps);
}
<span class="hljs-addition">+export function useRef(initialValue) {</span>
<span class="hljs-addition">+  const dispatcher = resolveDispatcher();</span>
<span class="hljs-addition">+  return dispatcher.useRef(initialValue);</span>
<span class="hljs-addition">+}</span>
</code></pre>
<h3 id="t29140.5 ReactFiberWorkLoop.js">40.5 ReactFiberWorkLoop.js <a href="#t29140.5 ReactFiberWorkLoop.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberWorkLoop.js</p>
<pre><code class="lang-diff">import {
  scheduleCallback as Scheduler_scheduleCallback,
  ImmediatePriority as ImmediateSchedulerPriority,
  UserBlockingPriority as UserBlockingSchedulerPriority,
  NormalPriority as NormalSchedulerPriority,
  IdlePriority as IdleSchedulerPriority,
  shouldYield&#xFF0C;
<span class="hljs-addition">+ cancelCallback as Scheduler_cancelCallback</span>
} from &quot;./Scheduler&quot;;
import { createWorkInProgress } from &quot;./ReactFiber&quot;;
import { beginWork } from &quot;./ReactFiberBeginWork&quot;;
import { completeWork } from &quot;./ReactFiberCompleteWork&quot;;
import { MutationMask, NoFlags, Passive } from &quot;./ReactFiberFlags&quot;;
import {
  commitMutationEffects,
  commitPassiveUnmountEffects,
  commitPassiveMountEffects,
  commitLayoutEffects,
} from &quot;./ReactFiberCommitWork&quot;;
import { finishQueueingConcurrentUpdates } from &quot;./ReactFiberConcurrentUpdates&quot;;
import {
  NoLane, markRootUpdated, NoLanes,
  getNextLanes, getHighestPriorityLane, SyncLane,
  includesBlockingLane
} from &apos;./ReactFiberLane&apos;;
import {
  getCurrentUpdatePriority, lanesToEventPriority, DiscreteEventPriority, ContinuousEventPriority,
  DefaultEventPriority, IdleEventPriority, setCurrentUpdatePriority
} from &apos;./ReactEventPriorities&apos;;
import { getCurrentEventPriority } from &apos;react-dom-bindings/src/client/ReactDOMHostConfig&apos;;
import { scheduleSyncCallback, flushSyncCallbacks } from &apos;./ReactFiberSyncTaskQueue&apos;;

let workInProgress = null;
let rootDoesHavePassiveEffects = false;
let rootWithPendingPassiveEffects = null;
let workInProgressRootRenderLanes = NoLanes;

const RootInProgress = 0;
const RootCompleted = 5;
let workInProgressRoot = null;
let workInProgressRootExitStatus = RootInProgress;

export function scheduleUpdateOnFiber(root, fiber, lane) {
  markRootUpdated(root, lane);
  ensureRootIsScheduled(root);
}
function ensureRootIsScheduled(root) {
<span class="hljs-addition">+ const existingCallbackNode = root.callbackNode;</span>
<span class="hljs-addition">+ const nextLanes = getNextLanes(root, root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes);</span>
  if (nextLanes <span class="hljs-comment">=== NoLanes) {</span>
    root.callbackNode = null;
    root.callbackPriority = NoLane;
    return;
  }
  const newCallbackPriority = getHighestPriorityLane(nextLanes);
  const existingCallbackPriority = root.callbackPriority;
  if (existingCallbackPriority <span class="hljs-comment">=== newCallbackPriority) {</span>
    return;
  }
<span class="hljs-addition">+ if (existingCallbackNode != null) {</span>
<span class="hljs-addition">+   Scheduler_cancelCallback(existingCallbackNode);</span>
<span class="hljs-addition">+ }</span>
  let newCallbackNode;
  if (newCallbackPriority <span class="hljs-comment">=== SyncLane) {</span>
    scheduleSyncCallback(performSyncWorkOnRoot.bind(null, root));
    queueMicrotask(flushSyncCallbacks);
    newCallbackNode = null;
  } else {
    let schedulerPriorityLevel;
    switch (lanesToEventPriority(nextLanes)) {
      case DiscreteEventPriority:
        schedulerPriorityLevel = ImmediateSchedulerPriority;
        break;
      case ContinuousEventPriority:
        schedulerPriorityLevel = UserBlockingSchedulerPriority;
        break;
      case DefaultEventPriority:
        schedulerPriorityLevel = NormalSchedulerPriority;
        break;
      case IdleEventPriority:
        schedulerPriorityLevel = IdleSchedulerPriority;
        break;
      default:
        schedulerPriorityLevel = NormalSchedulerPriority;
        break;
    }
    newCallbackNode = Scheduler_scheduleCallback(schedulerPriorityLevel, performConcurrentWorkOnRoot.bind(null, root))
  }
  root.callbackPriority = newCallbackPriority;
  root.callbackNode = newCallbackNode;
}
function performSyncWorkOnRoot(root) {
  const lanes = getNextLanes(root, NoLanes);
  renderRootSync(root, lanes);
  const finishedWork = root.current.alternate
  root.finishedWork = finishedWork
  commitRoot(root)
  return null;
}
function performConcurrentWorkOnRoot(root, didTimeout) {
  const originalCallbackNode = root.callbackNode;
  const lanes = getNextLanes(root, NoLanes);
  if (lanes <span class="hljs-comment">=== NoLanes) {</span>
    return null;
  }
  const shouldTimeSlice = !includesBlockingLane(root, lanes) &amp;&amp; (!didTimeout);
  const exitStatus = shouldTimeSlice ? renderRootConcurrent(root, lanes) : renderRootSync(root, lanes);
  if (exitStatus !== RootInProgress) {
    const finishedWork = root.current.alternate
    root.finishedWork = finishedWork
    commitRoot(root)
  }
  if (root.callbackNode <span class="hljs-comment">=== originalCallbackNode) {</span>
    return performConcurrentWorkOnRoot.bind(null, root);
  }
  return null;
}
function renderRootConcurrent(root, lanes) {
  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {
    prepareFreshStack(root, lanes);
  }
  workLoopConcurrent();
  if (workInProgress !== null) {
    return RootInProgress;
  }
  workInProgressRoot = null;
  workInProgressRootRenderLanes = NoLanes;
  return workInProgressRootExitStatus;
}
function workLoopConcurrent() {
  while (workInProgress !== null &amp;&amp; !shouldYield()) {
    performUnitOfWork(workInProgress);
  }
}
export function flushPassiveEffects() {
  if (rootWithPendingPassiveEffects !== null) {
    const root = rootWithPendingPassiveEffects;
    commitPassiveUnmountEffects(root.current);
    commitPassiveMountEffects(root, root.current);
  }
}
function commitRoot(root) {
  const previousPriority = getCurrentUpdatePriority();
  try {
    setCurrentUpdatePriority(DiscreteEventPriority);
    commitRootImpl(root);
  } finally {
    setCurrentUpdatePriority(previousPriority);
  }
}
function commitRootImpl(root) {
  const { finishedWork } = root;
  console.log(&apos;commit&apos;, finishedWork.child.memoizedState.memoizedState);
  root.callbackNode = null;
  root.callbackPriority = NoLane;
  if ((finishedWork.subtreeFlags &amp; Passive) !== NoFlags || (finishedWork.flags &amp; Passive) !== NoFlags) {
    if (!rootDoesHavePassiveEffects) {
      rootDoesHavePassiveEffects = true;
      Scheduler_scheduleCallback(NormalSchedulerPriority, flushPassiveEffects);
    }
  }
  const subtreeHasEffects = (finishedWork.subtreeFlags &amp; MutationMask) !== NoFlags;
  const rootHasEffect = (finishedWork.flags &amp; MutationMask) !== NoFlags;
  if (subtreeHasEffects || rootHasEffect) {
    commitMutationEffects(finishedWork, root);
    commitLayoutEffects(finishedWork, root);
    root.current = finishedWork;
    if (rootDoesHavePassiveEffects) {
      rootDoesHavePassiveEffects = false;
      rootWithPendingPassiveEffects = root;
    }
  }
  root.current = finishedWork;
}
function prepareFreshStack(root, lanes) {
  workInProgress = createWorkInProgress(root.current, null);
  workInProgressRootRenderLanes = lanes;
  finishQueueingConcurrentUpdates();
}
function renderRootSync(root, lanes) {
  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {
    prepareFreshStack(root, lanes)
  }
  workLoopSync();
  workInProgressRoot = null;
  workInProgressRootRenderLanes = NoLanes;
  return workInProgressRootExitStatus;
}

function workLoopSync() {
  while (workInProgress !== null) {
    performUnitOfWork(workInProgress);
  }
}
function performUnitOfWork(unitOfWork) {
  const current = unitOfWork.alternate;
  const next = beginWork(current, unitOfWork, workInProgressRootRenderLanes);
  unitOfWork.memoizedProps = unitOfWork.pendingProps;
  if (next <span class="hljs-comment">=== null) {</span>
    completeUnitOfWork(unitOfWork);
  } else {
    workInProgress = next;
  }
}

function completeUnitOfWork(unitOfWork) {
  let completedWork = unitOfWork;
  do {
    const current = completedWork.alternate;
    const returnFiber = completedWork.return;
    completeWork(current, completedWork);
    const siblingFiber = completedWork.sibling;
    if (siblingFiber !== null) {
      workInProgress = siblingFiber;
      return;
    }
    completedWork = returnFiber;
    workInProgress = completedWork;
  } while (completedWork !== null);
  if (workInProgressRootExitStatus <span class="hljs-comment">=== RootInProgress) {</span>
    workInProgressRootExitStatus = RootCompleted;
  }
}

export function requestUpdateLane() {
  const updateLane = getCurrentUpdatePriority();
  if (updateLane !== NoLane) {
    return updateLane;
  }
  const eventLane = getCurrentEventPriority();
  return eventLane;
}
</code></pre>
<h3 id="t29240.6 ReactFiberLane.js">40.6 ReactFiberLane.js <a href="#t29240.6 ReactFiberLane.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberLane.js</p>
<pre><code class="lang-diff">import { allowConcurrentByDefault } from &apos;shared/ReactFeatureFlags&apos;;

export const TotalLanes = 31;
export const NoLanes = 0b0000000000000000000000000000000;
export const NoLane = 0b0000000000000000000000000000000;
export const SyncLane = 0b0000000000000000000000000000001;// 1
export const InputContinuousLane = 0b0000000000000000000000000000100;// 4
export const DefaultLane = 0b0000000000000000000000000010000;// 16
export const NonIdleLanes = 0b0001111111111111111111111111111;
export const IdleLane = 0b0100000000000000000000000000000;

export function mergeLanes(a, b) {
  return a | b;
}
export function markRootUpdated(root, updateLane) {
  root.pendingLanes |= updateLane;
}

<span class="hljs-addition">+export function getNextLanes(root, wipLanes) {</span>
  const pendingLanes = root.pendingLanes;
  if (pendingLanes <span class="hljs-comment">=== NoLanes) {</span>
    return NoLanes;
  }
  const nextLanes = getHighestPriorityLanes(pendingLanes);
<span class="hljs-addition">+ if (wipLanes !== NoLanes &amp;&amp; wipLanes !== nextLanes) {</span>
<span class="hljs-addition">+   if (nextLanes &gt;= wipLanes) {</span>
<span class="hljs-addition">+     return wipLanes;</span>
<span class="hljs-addition">+   }</span>
<span class="hljs-addition">+ }</span>
  return nextLanes;
}

function getHighestPriorityLanes(lanes) {
  return getHighestPriorityLane(lanes);
}

export function getHighestPriorityLane(lanes) {
  return lanes &amp; -lanes;
}

export function includesNonIdleWork(lanes) {
  return (lanes &amp; NonIdleLanes) !== NoLanes;
}
export function includesBlockingLane(root, lanes) {
  if (allowConcurrentByDefault) {
    return false;
  }
  const SyncDefaultLanes = InputContinuousLane | DefaultLane;
  return (lanes &amp; SyncDefaultLanes) !== NoLanes;
}
export function isSubsetOfLanes(set, subset) {
  return (set &amp; subset) <span class="hljs-comment">=== subset;</span>
}
</code></pre>
<h3 id="t29340.7  ReactFiberHooks.js">40.7  ReactFiberHooks.js <a href="#t29340.7  ReactFiberHooks.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberHooks.js</p>
<pre><code class="lang-diff">import ReactSharedInternals from &quot;shared/ReactSharedInternals&quot;;
import { enqueueConcurrentHookUpdate } from &quot;./ReactFiberConcurrentUpdates&quot;;
import { scheduleUpdateOnFiber, requestUpdateLane } from &quot;./ReactFiberWorkLoop&quot;;
import is from &quot;shared/objectIs&quot;;
import { Passive as PassiveEffect, Update as UpdateEffect } from &quot;./ReactFiberFlags&quot;;
import { HasEffect as HookHasEffect, Passive as HookPassive, Layout as HookLayout } from &quot;./ReactHookEffectTags&quot;;
import { NoLanes } from &apos;./ReactFiberLane&apos;;

const { ReactCurrentDispatcher } = ReactSharedInternals;
let currentlyRenderingFiber = null;
let workInProgressHook = null;
let currentHook = null;

const HooksDispatcherOnMountInDEV = {
  useReducer: mountReducer,
  useState: mountState,
  useEffect: mountEffect,
  useLayoutEffect: mountLayoutEffect,
<span class="hljs-addition">+ useRef: mountRef,</span>
};
const HooksDispatcherOnUpdateInDEV = {
  useReducer: updateReducer,
  useState: updateState,
  useEffect: updateEffect,
  useLayoutEffect: updateLayoutEffect,
<span class="hljs-addition">+ useRef: updateRef</span>
};
<span class="hljs-addition">+function mountRef(initialValue) {</span>
<span class="hljs-addition">+  const hook = mountWorkInProgressHook();</span>
<span class="hljs-addition">+  const ref = {</span>
<span class="hljs-addition">+    current: initialValue,</span>
<span class="hljs-addition">+  };</span>
<span class="hljs-addition">+  hook.memoizedState = ref;</span>
<span class="hljs-addition">+  return ref;</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+function updateRef() {</span>
<span class="hljs-addition">+  const hook = updateWorkInProgressHook();</span>
<span class="hljs-addition">+  return hook.memoizedState;</span>
<span class="hljs-addition">+}</span>
export function useLayoutEffect(reducer, initialArg) {
  return ReactCurrentDispatcher.current.useLayoutEffect(reducer, initialArg);
}
function updateLayoutEffect(create, deps) {
  return updateEffectImpl(UpdateEffect, HookLayout, create, deps);
}
function mountLayoutEffect(create, deps) {
  const fiberFlags = UpdateEffect;
  return mountEffectImpl(fiberFlags, HookLayout, create, deps);
}
function updateEffect(create, deps) {
  return updateEffectImpl(PassiveEffect, HookPassive, create, deps);
}
function updateEffectImpl(fiberFlags, hookFlags, create, deps) {
  const hook = updateWorkInProgressHook();
  const nextDeps = deps <span class="hljs-comment">=== undefined ? null : deps;</span>
  let destroy;
  if (currentHook !== null) {
    const prevEffect = currentHook.memoizedState;
    destroy = prevEffect.destroy;
    if (nextDeps !== null) {
      const prevDeps = prevEffect.deps;
      if (areHookInputsEqual(nextDeps, prevDeps)) {
        hook.memoizedState = pushEffect(hookFlags, create, destroy, nextDeps);
        return;
      }
    }
  }
  currentlyRenderingFiber.flags |= fiberFlags;
  hook.memoizedState = pushEffect(HookHasEffect | hookFlags, create, destroy, nextDeps);
}
function areHookInputsEqual(nextDeps, prevDeps) {
  if (prevDeps <span class="hljs-comment">=== null) {</span>
    return false;
  }
  for (let i = 0; i &lt; prevDeps.length &amp;&amp; i &lt; nextDeps.length; i++) {
    if (is(nextDeps[i], prevDeps[i])) {
      continue;
    }
    return false;
  }

  return true;
}
function mountEffect(create, deps) {
  return mountEffectImpl(PassiveEffect, HookPassive, create, deps);
}
function mountEffectImpl(fiberFlags, hookFlags, create, deps) {
  const hook = mountWorkInProgressHook();
  const nextDeps = deps <span class="hljs-comment">=== undefined ? null : deps;</span>
  currentlyRenderingFiber.flags |= fiberFlags;
  hook.memoizedState = pushEffect(HookHasEffect | hookFlags, create, undefined, nextDeps);
}
function pushEffect(tag, create, destroy, deps) {
  const effect = {
    tag,
    create,
    destroy,
    deps,
    next: null,
  };
  let componentUpdateQueue = currentlyRenderingFiber.updateQueue;
  if (componentUpdateQueue <span class="hljs-comment">=== null) {</span>
    componentUpdateQueue = createFunctionComponentUpdateQueue();
    currentlyRenderingFiber.updateQueue = componentUpdateQueue;
    componentUpdateQueue.lastEffect = effect.next = effect;
  } else {
    const lastEffect = componentUpdateQueue.lastEffect;
    if (lastEffect <span class="hljs-comment">=== null) {</span>
      componentUpdateQueue.lastEffect = effect.next = effect;
    } else {
      const firstEffect = lastEffect.next;
      lastEffect.next = effect;
      effect.next = firstEffect;
      componentUpdateQueue.lastEffect = effect;
    }
  }
  return effect;
}
function createFunctionComponentUpdateQueue() {
  return {
    lastEffect: null,
  };
}
function basicStateReducer(state, action) {
  return typeof action <span class="hljs-comment">=== &quot;function&quot; ? action(state) : action;</span>
}
function mountReducer(reducer, initialArg) {
  const hook = mountWorkInProgressHook();
  hook.memoizedState = initialArg;
  const queue = {
    pending: null,
    dispatch: null,
  };
  hook.queue = queue;
  const dispatch = (queue.dispatch = dispatchReducerAction.bind(null, currentlyRenderingFiber, queue));
  return [hook.memoizedState, dispatch];
}
function updateReducer(reducer) {
  const hook = updateWorkInProgressHook();
  const queue = hook.queue;
  queue.lastRenderedReducer = reducer;
  const current = currentHook;
  const pendingQueue = queue.pending;
  let baseQueue = null;
  let newState = current.memoizedState;
  if (pendingQueue !== null) {
    baseQueue = pendingQueue;
    queue.pending = null;
  }
  if (baseQueue !== null) {
    const first = baseQueue.next;
    let update = first;
    do {
      if (update.hasEagerState) {
        newState = update.eagerState;
      } else {
        const action = update.action;
        newState = reducer(newState, action);
      }
      update = update.next;
    } while (update !== null &amp;&amp; update !== first);
  }
  hook.memoizedState = newState;
  queue.lastRenderedState = newState;
  const dispatch = queue.dispatch;
  return [hook.memoizedState, dispatch];
}
function mountState(initialState) {
  const hook = mountWorkInProgressHook();
  hook.memoizedState = initialState;
  const queue = {
    pending: null,
    dispatch: null,
    lastRenderedReducer: basicStateReducer,
    lastRenderedState: initialState,
  };
  hook.queue = queue;
  const dispatch = (queue.dispatch = dispatchSetState.bind(null, currentlyRenderingFiber, queue));
  return [hook.memoizedState, dispatch];
}
function dispatchSetState(fiber, queue, action) {
  const lane = requestUpdateLane(fiber);
  const update = {
    lane,
    action,
    hasEagerState: false,
    eagerState: null,
    next: null,
  };
  const alternate = fiber.alternate;
  if (fiber.lanes <span class="hljs-comment">=== NoLanes &amp;&amp; (alternate === null || alternate.lanes === NoLanes)) {</span>
    const lastRenderedReducer = queue.lastRenderedReducer;
    const currentState = queue.lastRenderedState;
    const eagerState = lastRenderedReducer(currentState, action);
    update.hasEagerState = true;
    update.eagerState = eagerState;
    if (is(eagerState, currentState)) {
      return;
    }
  }
  const root = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
  scheduleUpdateOnFiber(root, fiber, lane);
}
function updateState(initialState) {
  return updateReducer(basicStateReducer, initialState);
}
function mountWorkInProgressHook() {
  const hook = {
    memoizedState: null,
    queue: null,
    next: null,
  };
  if (workInProgressHook <span class="hljs-comment">=== null) {</span>
    currentlyRenderingFiber.memoizedState = workInProgressHook = hook;
  } else {
    workInProgressHook = workInProgressHook.next = hook;
  }
  return workInProgressHook;
}
function dispatchReducerAction(fiber, queue, action) {
  const update = {
    action,
    next: null,
  };
  const root = enqueueConcurrentHookUpdate(fiber, queue, update);
  scheduleUpdateOnFiber(root, fiber);
}

function updateWorkInProgressHook() {
  let nextCurrentHook;
  if (currentHook <span class="hljs-comment">=== null) {</span>
    const current = currentlyRenderingFiber.alternate;
    if (current !== null) {
      nextCurrentHook = current.memoizedState;
    } else {
      nextCurrentHook = null;
    }
  } else {
    nextCurrentHook = currentHook.next;
  }

  let nextWorkInProgressHook;
  if (workInProgressHook <span class="hljs-comment">=== null) {</span>
    nextWorkInProgressHook = currentlyRenderingFiber.memoizedState;
  } else {
    nextWorkInProgressHook = workInProgressHook.next;
  }

  if (nextWorkInProgressHook !== null) {
    workInProgressHook = nextWorkInProgressHook;
    nextWorkInProgressHook = workInProgressHook.next;
    currentHook = nextCurrentHook;
  } else {
    currentHook = nextCurrentHook;
    const newHook = {
      memoizedState: currentHook.memoizedState,
      queue: currentHook.queue,
      next: null,
    };
    if (workInProgressHook <span class="hljs-comment">=== null) {</span>
      currentlyRenderingFiber.memoizedState = workInProgressHook = newHook;
    } else {
      workInProgressHook = workInProgressHook.next = newHook;
    }
  }
  return workInProgressHook;
}

export function renderWithHooks(current, workInProgress, Component, props) {
  currentlyRenderingFiber = workInProgress;
  workInProgress.updateQueue = null;
  workInProgress.memoizedState = null;
  if (current !== null &amp;&amp; current.memoizedState !== null) {
    ReactCurrentDispatcher.current = HooksDispatcherOnUpdateInDEV;
  } else {
    ReactCurrentDispatcher.current = HooksDispatcherOnMountInDEV;
  }
  const children = Component(props);
  currentlyRenderingFiber = null;
  workInProgressHook = null;
  currentHook = null;
  return children;
}
</code></pre>
<h3 id="t29440.8 ReactFiberFlags.js">40.8 ReactFiberFlags.js <a href="#t29440.8 ReactFiberFlags.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberFlags.js</p>
<pre><code class="lang-diff">export const NoFlags = 0b00000000000000000000000000;
export const Placement = 0b00000000000000000000000010;
export const Update = 0b00000000000000000000000100;
export const ChildDeletion = 0b00000000000000000000001000;
export const Passive = 0b00000000000000010000000000;
export const LayoutMask = Update;
<span class="hljs-addition">+export const Ref = 0b00000000000000000100000000;</span>
<span class="hljs-addition">+export const MutationMask = Placement | Update | Ref;</span>
</code></pre>
<h3 id="t29540.9 ReactFiberCompleteWork.js">40.9 ReactFiberCompleteWork.js <a href="#t29540.9 ReactFiberCompleteWork.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberCompleteWork.js</p>
<pre><code class="lang-diff">import {
  appendInitialChild,
  createInstance,
  createTextInstance,
  finalizeInitialChildren,
  prepareUpdate,
} from &quot;react-dom-bindings/src/client/ReactDOMHostConfig&quot;;
import { HostComponent, HostRoot, HostText, FunctionComponent } from &quot;./ReactWorkTags&quot;;
<span class="hljs-addition">+import { Ref, NoFlags, Update } from &quot;./ReactFiberFlags&quot;;</span>
<span class="hljs-addition">+</span>
<span class="hljs-addition">+function markRef(workInProgress) {</span>
<span class="hljs-addition">+  workInProgress.flags |= Ref;</span>
<span class="hljs-addition">+}</span>

function bubbleProperties(completedWork) {
  let subtreeFlags = NoFlags;
  let child = completedWork.child;
  while (child !== null) {
    subtreeFlags |= child.subtreeFlags;
    subtreeFlags |= child.flags;
    child = child.sibling;
  }
  completedWork.subtreeFlags |= subtreeFlags;
}

function appendAllChildren(parent, workInProgress) {
  // &#x6211;&#x4EEC;&#x53EA;&#x6709;&#x521B;&#x5EFA;&#x7684;&#x9876;&#x7EA7;fiber&#xFF0C;&#x4F46;&#x9700;&#x8981;&#x9012;&#x5F52;&#x5176;&#x5B50;&#x8282;&#x70B9;&#x6765;&#x67E5;&#x627E;&#x6240;&#x6709;&#x7EC8;&#x7AEF;&#x8282;&#x70B9;
  let node = workInProgress.child;
  while (node !== null) {
    // &#x5982;&#x679C;&#x662F;&#x539F;&#x751F;&#x8282;&#x70B9;&#xFF0C;&#x76F4;&#x63A5;&#x6DFB;&#x52A0;&#x5230;&#x7236;&#x8282;&#x70B9;&#x4E0A;
    if (node.tag <span class="hljs-comment">=== HostComponent || node.tag === HostText) {</span>
      appendInitialChild(parent, node.stateNode);
      // &#x518D;&#x770B;&#x770B;&#x7B2C;&#x4E00;&#x4E2A;&#x8282;&#x8282;&#x70B9;&#x662F;&#x4E0D;&#x662F;&#x539F;&#x751F;&#x8282;&#x70B9;
    } else if (node.child !== null) {
      // node.child.return = node
      node = node.child;
      continue;
    }
    if (node <span class="hljs-comment">=== workInProgress) {</span>
      return;
    }
    // &#x5982;&#x679C;&#x6CA1;&#x6709;&#x5F1F;&#x5F1F;&#x5C31;&#x627E;&#x7236;&#x4EB2;&#x7684;&#x5F1F;&#x5F1F;
    while (node.sibling <span class="hljs-comment">=== null) {</span>
      // &#x5982;&#x679C;&#x627E;&#x5230;&#x4E86;&#x6839;&#x8282;&#x70B9;&#x6216;&#x8005;&#x56DE;&#x5230;&#x4E86;&#x539F;&#x8282;&#x70B9;&#x7ED3;&#x675F;
      if (node.return <span class="hljs-comment">=== null || node.return === workInProgress) {</span>
        return;
      }
      node = node.return;
    }
    // node.sibling.return = node.return
    // &#x4E0B;&#x4E00;&#x4E2A;&#x5F1F;&#x5F1F;&#x8282;&#x70B9;
    node = node.sibling;
  }
}
function markUpdate(workInProgress) {
  workInProgress.flags |= Update;
}
function updateHostComponent(current, workInProgress, type, newProps) {
  const oldProps = current.memoizedProps;
  const instance = workInProgress.stateNode;
  const updatePayload = prepareUpdate(instance, type, oldProps, newProps);
  workInProgress.updateQueue = updatePayload;
  if (updatePayload) {
    markUpdate(workInProgress);
  }
}
export function completeWork(current, workInProgress) {
  const newProps = workInProgress.pendingProps;
  switch (workInProgress.tag) {
    case HostComponent: {
      const { type } = workInProgress;
      if (current !== null &amp;&amp; workInProgress.stateNode != null) {
        updateHostComponent(current, workInProgress, type, newProps);
<span class="hljs-addition">+       if (current.ref !== workInProgress.ref) {</span>
<span class="hljs-addition">+         markRef(workInProgress);</span>
<span class="hljs-addition">+       }</span>
      } else {
        const instance = createInstance(type, newProps, workInProgress);
        appendAllChildren(instance, workInProgress);
        workInProgress.stateNode = instance;
        finalizeInitialChildren(instance, type, newProps);
<span class="hljs-addition">+       if (workInProgress.ref !== null) {</span>
<span class="hljs-addition">+         markRef(workInProgress);</span>
<span class="hljs-addition">+       }</span>
      }
      bubbleProperties(workInProgress);
      return null;
      break;
    }
    case FunctionComponent:
      bubbleProperties(workInProgress);
      break;
    case HostRoot:
      bubbleProperties(workInProgress);
      break;
    case HostText: {
      const newText = newProps;
      workInProgress.stateNode = createTextInstance(newText);
      bubbleProperties(workInProgress);
      break;
    }
    default:
      break;
  }
}
</code></pre>
<h3 id="t29640.10 ReactFiberCommitWork.js">40.10 ReactFiberCommitWork.js <a href="#t29640.10 ReactFiberCommitWork.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberCommitWork.js</p>
<pre><code class="lang-diff">import { HostRoot, HostComponent, HostText, FunctionComponent } from &quot;./ReactWorkTags&quot;;
<span class="hljs-addition">+import { Passive, MutationMask, Placement, Update, LayoutMask, Ref } from &quot;./ReactFiberFlags&quot;;</span>
import { insertBefore, appendChild, commitUpdate, removeChild } from &quot;react-dom-bindings/src/client/ReactDOMHostConfig&quot;;
import { HasEffect as HookHasEffect, Passive as HookPassive, Layout as HookLayout } from &quot;./ReactHookEffectTags&quot;;

export function commitMutationEffects(finishedWork, root) {
  commitMutationEffectsOnFiber(finishedWork, root);
}
export function commitPassiveUnmountEffects(finishedWork) {
  commitPassiveUnmountOnFiber(finishedWork);
}
function commitPassiveUnmountOnFiber(finishedWork) {
  switch (finishedWork.tag) {
    case FunctionComponent: {
      recursivelyTraversePassiveUnmountEffects(finishedWork);
      if (finishedWork.flags &amp; Passive) {
        commitHookPassiveUnmountEffects(finishedWork, finishedWork.return, HookPassive | HookHasEffect);
      }
      break;
    }
    default: {
      recursivelyTraversePassiveUnmountEffects(finishedWork);
      break;
    }
  }
}
function recursivelyTraversePassiveUnmountEffects(parentFiber) {
  if (parentFiber.subtreeFlags &amp; Passive) {
    let child = parentFiber.child;
    while (child !== null) {
      commitPassiveUnmountOnFiber(child);
      child = child.sibling;
    }
  }
}
function commitHookPassiveUnmountEffects(finishedWork, nearestMountedAncestor, hookFlags) {
  commitHookEffectListUnmount(hookFlags, finishedWork, nearestMountedAncestor);
}

function commitHookEffectListUnmount(flags, finishedWork) {
  const updateQueue = finishedWork.updateQueue;
  const lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;
  if (lastEffect !== null) {
    const firstEffect = lastEffect.next;
    let effect = firstEffect;
    do {
      if ((effect.tag &amp; flags) <span class="hljs-comment">=== flags) {</span>
        const destroy = effect.destroy;
        effect.destroy = undefined;
        if (destroy !== undefined) {
          destroy();
        }
      }
      effect = effect.next;
    } while (effect !== firstEffect);
  }
}

export function commitPassiveMountEffects(root, finishedWork) {
  commitPassiveMountOnFiber(root, finishedWork);
}
function commitPassiveMountOnFiber(finishedRoot, finishedWork) {
  const flags = finishedWork.flags;
  switch (finishedWork.tag) {
    case FunctionComponent: {
      recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork);
      if (flags &amp; Passive) {
        commitHookPassiveMountEffects(finishedWork, HookPassive | HookHasEffect);
      }
      break;
    }
    case HostRoot: {
      recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork);
      break;
    }
    default:
      break;
  }
}
function commitHookPassiveMountEffects(finishedWork, hookFlags) {
  commitHookEffectListMount(hookFlags, finishedWork);
}
function commitHookEffectListMount(flags, finishedWork) {
  const updateQueue = finishedWork.updateQueue;
  const lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;
  if (lastEffect !== null) {
    const firstEffect = lastEffect.next;
    let effect = firstEffect;
    do {
      if ((effect.tag &amp; flags) <span class="hljs-comment">=== flags) {</span>
        const create = effect.create;
        effect.destroy = create();
      }
      effect = effect.next;
    } while (effect !== firstEffect);
  }
}
function recursivelyTraversePassiveMountEffects(root, parentFiber) {
  if (parentFiber.subtreeFlags &amp; Passive) {
    let child = parentFiber.child;
    while (child !== null) {
      commitPassiveMountOnFiber(root, child);
      child = child.sibling;
    }
  }
}
let hostParent = null;
function commitDeletionEffects(root, returnFiber, deletedFiber) {
  let parent = returnFiber;
  findParent: while (parent !== null) {
    switch (parent.tag) {
      case HostComponent: {
        hostParent = parent.stateNode;
        break findParent;
      }
      case HostRoot: {
        hostParent = parent.stateNode.containerInfo;
        break findParent;
      }
      default:
        break;
    }
    parent = parent.return;
  }
  commitDeletionEffectsOnFiber(root, returnFiber, deletedFiber);
  hostParent = null;
}
function commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, deletedFiber) {
  switch (deletedFiber.tag) {
    case HostComponent:
    case HostText: {
      recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
      if (hostParent !== null) {
        removeChild(hostParent, deletedFiber.stateNode);
      }
      break;
    }
    default:
      break;
  }
}
function recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, parent) {
  let child = parent.child;
  while (child !== null) {
    commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, child);
    child = child.sibling;
  }
}
function recursivelyTraverseMutationEffects(root, parentFiber) {
  const deletions = parentFiber.deletions;
  if (deletions !== null) {
    for (let i = 0; i &lt; deletions.length; i++) {
      const childToDelete = deletions[i];
      commitDeletionEffects(root, parentFiber, childToDelete);
    }
  }
  if (parentFiber.subtreeFlags &amp; MutationMask) {
    let { child } = parentFiber;
    while (child !== null) {
      commitMutationEffectsOnFiber(child, root);
      child = child.sibling;
    }
  }
}
function isHostParent(fiber) {
  return fiber.tag <span class="hljs-comment">=== HostComponent || fiber.tag === HostRoot;</span>
}
function getHostParentFiber(fiber) {
  let parent = fiber.return;
  while (parent !== null) {
    if (isHostParent(parent)) {
      return parent;
    }
    parent = parent.return;
  }
  return parent;
}
function insertOrAppendPlacementNode(node, before, parent) {
  const { tag } = node;
  const isHost = tag <span class="hljs-comment">=== HostComponent || tag === HostText;</span>
  if (isHost) {
    const { stateNode } = node;
    if (before) {
      insertBefore(parent, stateNode, before);
    } else {
      appendChild(parent, stateNode);
    }
  } else {
    const { child } = node;
    if (child !== null) {
      insertOrAppendPlacementNode(child, before, parent);
      let { sibling } = child;
      while (sibling !== null) {
        insertOrAppendPlacementNode(sibling, before, parent);
        sibling = sibling.sibling;
      }
    }
  }
}
function getHostSibling(fiber) {
  let node = fiber;
  siblings: while (true) {
    // &#x5982;&#x679C;&#x6211;&#x4EEC;&#x6CA1;&#x6709;&#x627E;&#x5230;&#x4EFB;&#x4F55;&#x4E1C;&#x897F;&#xFF0C;&#x8BA9;&#x6211;&#x4EEC;&#x8BD5;&#x8BD5;&#x4E0B;&#x4E00;&#x4E2A;&#x5F1F;&#x5F1F;
    while (node.sibling <span class="hljs-comment">=== null) {</span>
      if (node.return <span class="hljs-comment">=== null || isHostParent(node.return)) {</span>
        // &#x5982;&#x679C;&#x6211;&#x4EEC;&#x662F;&#x6839;Fiber&#x6216;&#x8005;&#x7236;&#x4EB2;&#x662F;&#x539F;&#x751F;&#x8282;&#x70B9;&#xFF0C;&#x6211;&#x4EEC;&#x5C31;&#x662F;&#x6700;&#x540E;&#x7684;&#x5F1F;&#x5F1F;
        return null;
      }
      node = node.return;
    }
    // node.sibling.return = node.return
    node = node.sibling;
    while (node.tag !== HostComponent &amp;&amp; node.tag !== HostText) {
      // &#x5982;&#x679C;&#x5B83;&#x4E0D;&#x662F;&#x539F;&#x751F;&#x8282;&#x70B9;&#xFF0C;&#x5E76;&#x4E14;&#xFF0C;&#x6211;&#x4EEC;&#x53EF;&#x80FD;&#x5728;&#x5176;&#x4E2D;&#x6709;&#x4E00;&#x4E2A;&#x539F;&#x751F;&#x8282;&#x70B9;
      // &#x8BD5;&#x7740;&#x5411;&#x4E0B;&#x641C;&#x7D22;&#xFF0C;&#x76F4;&#x5230;&#x627E;&#x5230;&#x4E3A;&#x6B62;
      if (node.flags &amp; Placement) {
        // &#x5982;&#x679C;&#x6211;&#x4EEC;&#x6CA1;&#x6709;&#x5B69;&#x5B50;&#xFF0C;&#x53EF;&#x4EE5;&#x8BD5;&#x8BD5;&#x5F1F;&#x5F1F;
        continue siblings;
      } else {
        // node.child.return = node
        node = node.child;
      }
    } // Check if this host node is stable or about to be placed.
    // &#x68C0;&#x67E5;&#x6B64;&#x539F;&#x751F;&#x8282;&#x70B9;&#x662F;&#x5426;&#x7A33;&#x5B9A;&#x53EF;&#x4EE5;&#x653E;&#x7F6E;
    if (!(node.flags &amp; Placement)) {
      // &#x627E;&#x5230;&#x5B83;&#x4E86;!
      return node.stateNode;
    }
  }
}
function commitPlacement(finishedWork) {
  const parentFiber = getHostParentFiber(finishedWork);
  switch (parentFiber.tag) {
    case HostComponent: {
      const parent = parentFiber.stateNode;
      const before = getHostSibling(finishedWork);
      insertOrAppendPlacementNode(finishedWork, before, parent);
      break;
    }
    case HostRoot: {
      const parent = parentFiber.stateNode.containerInfo;
      const before = getHostSibling(finishedWork);
      insertOrAppendPlacementNode(finishedWork, before, parent);
      break;
    }
    default:
      break;
  }
}
function commitReconciliationEffects(finishedWork) {
  const { flags } = finishedWork;
  if (flags &amp; Placement) {
    commitPlacement(finishedWork);
    finishedWork.flags &amp;= ~Placement;
  }
}
export function commitMutationEffectsOnFiber(finishedWork, root) {
  const current = finishedWork.alternate;
  const flags = finishedWork.flags;
  switch (finishedWork.tag) {
    case HostRoot: {
      recursivelyTraverseMutationEffects(root, finishedWork);
      commitReconciliationEffects(finishedWork);
      break;
    }
    case FunctionComponent: {
      recursivelyTraverseMutationEffects(root, finishedWork);
      commitReconciliationEffects(finishedWork);
      if (flags &amp; Update) {
        commitHookEffectListUnmount(HookLayout | HookHasEffect, finishedWork, finishedWork.return);
      }
      break;
    }
    case HostComponent: {
      recursivelyTraverseMutationEffects(root, finishedWork);
      commitReconciliationEffects(finishedWork);
<span class="hljs-addition">+     if (flags &amp; Ref) {</span>
<span class="hljs-addition">+       commitAttachRef(finishedWork);</span>
<span class="hljs-addition">+     }</span>
      if (flags &amp; Update) {
        const instance = finishedWork.stateNode;
        if (instance != null) {
          const newProps = finishedWork.memoizedProps;
          const oldProps = current !== null ? current.memoizedProps : newProps;
          const type = finishedWork.type;
          const updatePayload = finishedWork.updateQueue;
          finishedWork.updateQueue = null;
          if (updatePayload !== null) {
            commitUpdate(instance, updatePayload, type, oldProps, newProps, finishedWork);
          }
        }
      }

      break;
    }
    case HostText: {
      recursivelyTraverseMutationEffects(root, finishedWork);
      commitReconciliationEffects(finishedWork);
      break;
    }
    default: {
      break;
    }
  }
}
<span class="hljs-addition">+function commitAttachRef(finishedWork) {</span>
<span class="hljs-addition">+  const ref = finishedWork.ref;</span>
<span class="hljs-addition">+  if (ref !== null) {</span>
<span class="hljs-addition">+    const instance = finishedWork.stateNode;</span>
<span class="hljs-addition">+    if (typeof ref === &quot;function&quot;) {</span>
<span class="hljs-addition">+      ref(instance)</span>
<span class="hljs-addition">+    } else {</span>
<span class="hljs-addition">+      ref.current = instance;</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+}</span>
export function commitLayoutEffects(finishedWork, root) {
  const current = finishedWork.alternate;
  commitLayoutEffectOnFiber(root, current, finishedWork);
}
function commitLayoutEffectOnFiber(finishedRoot, current, finishedWork) {
  const flags = finishedWork.flags;
  switch (finishedWork.tag) {
    case FunctionComponent: {
      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
      if (flags &amp; Update) {
        commitHookLayoutEffects(finishedWork, HookLayout | HookHasEffect);
      }
      break;
    }
    case HostRoot: {
      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
      break;
    }
    default:
      break;
  }
}
function recursivelyTraverseLayoutEffects(root, parentFiber) {
  if (parentFiber.subtreeFlags &amp; LayoutMask) {
    let child = parentFiber.child;
    while (child !== null) {
      const current = child.alternate;
      commitLayoutEffectOnFiber(root, current, child);
      child = child.sibling;
    }
  }
}
function commitHookLayoutEffects(finishedWork, hookFlags) {
  commitHookEffectListMount(hookFlags, finishedWork);
}
</code></pre>
<h3 id="t29740.11  ReactFiber.js">40.11  ReactFiber.js <a href="#t29740.11  ReactFiber.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiber.js</p>
<pre><code class="lang-diff">import { HostRoot, IndeterminateComponent, HostComponent, HostText } from &quot;./ReactWorkTags&quot;;
import { NoFlags } from &quot;./ReactFiberFlags&quot;;
export function FiberNode(tag, pendingProps, key) {
  this.tag = tag;
  this.key = key;
  this.type = null;
  this.stateNode = null;

  this.return = null;
  this.child = null;
  this.sibling = null;

  this.pendingProps = pendingProps;
  this.memoizedProps = null;
  this.updateQueue = null;
  this.memoizedState = null;

  this.flags = NoFlags;
  this.subtreeFlags = NoFlags;
  this.deletions = null;
  this.alternate = null;

  this.index = 0;
<span class="hljs-addition">+ this.ref = null;</span>
}
function createFiber(tag, pendingProps, key) {
  return new FiberNode(tag, pendingProps, key);
}
export function createHostRootFiber() {
  return createFiber(HostRoot, null, null);
}
// We use a double buffering pooling technique because we know that we&apos;ll
// only ever need at most two versions of a tree. We pool the &quot;other&quot; unused
// node that we&apos;re free to reuse. This is lazily created to avoid allocating
// extra objects for things that are never updated. It also allow us to
// reclaim the extra memory if needed.
//&#x6211;&#x4EEC;&#x4F7F;&#x7528;&#x53CC;&#x7F13;&#x51B2;&#x6C60;&#x6280;&#x672F;&#xFF0C;&#x56E0;&#x4E3A;&#x6211;&#x4EEC;&#x77E5;&#x9053;&#x4E00;&#x68F5;&#x6811;&#x6700;&#x591A;&#x53EA;&#x9700;&#x8981;&#x4E24;&#x4E2A;&#x7248;&#x672C;
//&#x6211;&#x4EEC;&#x5C06;&#x201C;&#x5176;&#x4ED6;&#x201D;&#x672A;&#x4F7F;&#x7528;&#x7684;&#x6211;&#x4EEC;&#x53EF;&#x4EE5;&#x81EA;&#x7531;&#x91CD;&#x7528;&#x7684;&#x8282;&#x70B9;
//&#x8FD9;&#x662F;&#x5EF6;&#x8FDF;&#x521B;&#x5EFA;&#x7684;&#xFF0C;&#x4EE5;&#x907F;&#x514D;&#x5206;&#x914D;&#x4ECE;&#x672A;&#x66F4;&#x65B0;&#x7684;&#x5185;&#x5BB9;&#x7684;&#x989D;&#x5916;&#x5BF9;&#x8C61;&#x3002;&#x5B83;&#x8FD8;&#x5141;&#x8BB8;&#x6211;&#x4EEC;&#x5982;&#x679C;&#x9700;&#x8981;&#xFF0C;&#x56DE;&#x6536;&#x989D;&#x5916;&#x7684;&#x5185;&#x5B58;
export function createWorkInProgress(current, pendingProps) {
  let workInProgress = current.alternate;
  if (workInProgress <span class="hljs-comment">=== null) {</span>
    workInProgress = createFiber(current.tag, pendingProps, current.key);
    workInProgress.type = current.type;
    workInProgress.stateNode = current.stateNode;
    workInProgress.alternate = current;
    current.alternate = workInProgress;
  } else {
    workInProgress.pendingProps = pendingProps;
    workInProgress.type = current.type;
    workInProgress.flags = NoFlags;
    workInProgress.subtreeFlags = NoFlags;
  }
  workInProgress.child = current.child;
  workInProgress.memoizedProps = current.memoizedProps;
  workInProgress.memoizedState = current.memoizedState;
  workInProgress.updateQueue = current.updateQueue;
  workInProgress.sibling = current.sibling;
  workInProgress.index = current.index;
<span class="hljs-addition">+ workInProgress.ref = current.ref;</span>
  return workInProgress;
}
export function createFiberFromTypeAndProps(type, key, pendingProps) {
  let fiberTag = IndeterminateComponent;
  if (typeof type <span class="hljs-comment">=== &quot;string&quot;) {</span>
    fiberTag = HostComponent;
  }
  const fiber = createFiber(fiberTag, pendingProps, key);
  fiber.type = type;
  return fiber;
}
export function createFiberFromElement(element) {
  const { type } = element;
  const { key } = element;
  const pendingProps = element.props;
  const fiber = createFiberFromTypeAndProps(type, key, pendingProps);
  return fiber;
}

export function createFiberFromText(content) {
  const fiber = createFiber(HostText, content, null);
  return fiber;
}
</code></pre>
<h3 id="t29840.12 ReactChildFiber.js">40.12 ReactChildFiber.js <a href="#t29840.12 ReactChildFiber.js"> # </a></h3>
<p>src\react-reconciler\src\ReactChildFiber.js</p>
<pre><code class="lang-diff">import { REACT_ELEMENT_TYPE } from &quot;shared/ReactSymbols&quot;;
import isArray from &quot;shared/isArray&quot;;
import { createFiberFromElement, FiberNode, createFiberFromText, createWorkInProgress } from &quot;./ReactFiber&quot;;
import { Placement, ChildDeletion } from &quot;./ReactFiberFlags&quot;;
import { HostText } from &quot;./ReactWorkTags&quot;;
function createChildReconciler(shouldTrackSideEffects) {
  function useFiber(fiber, pendingProps) {
    const clone = createWorkInProgress(fiber, pendingProps);
    clone.index = 0;
    clone.sibling = null;
    return clone;
  }
  function deleteChild(returnFiber, childToDelete) {
    if (!shouldTrackSideEffects) {
      return;
    }
    const deletions = returnFiber.deletions;
    if (deletions <span class="hljs-comment">=== null) {</span>
      returnFiber.deletions = [childToDelete];
      returnFiber.flags |= ChildDeletion;
    } else {
      deletions.push(childToDelete);
    }
  }
  function deleteRemainingChildren(returnFiber, currentFirstChild) {
    if (!shouldTrackSideEffects) {
      return null;
    }
    let childToDelete = currentFirstChild;
    while (childToDelete !== null) {
      deleteChild(returnFiber, childToDelete);
      childToDelete = childToDelete.sibling;
    }
    return null;
  }
  function reconcileSingleElement(returnFiber, currentFirstChild, element) {
    const key = element.key;
    let child = currentFirstChild;
    while (child !== null) {
      if (child.key <span class="hljs-comment">=== key) {</span>
        const elementType = element.type;
        if (child.type <span class="hljs-comment">=== elementType) {</span>
          deleteRemainingChildren(returnFiber, child.sibling);
          const existing = useFiber(child, element.props);
<span class="hljs-addition">+         existing.ref = element.ref;</span>
          existing.return = returnFiber;
          return existing;
        }
        deleteRemainingChildren(returnFiber, child);
        break;
      } else {
        deleteChild(returnFiber, child);
      }
      child = child.sibling;
    }
    const created = createFiberFromElement(element);
<span class="hljs-addition">+   created.ref = element.ref;</span>
    created.return = returnFiber;
    return created;
  }
  function placeSingleChild(newFiber) {
    if (shouldTrackSideEffects &amp;&amp; newFiber.alternate <span class="hljs-comment">=== null) {</span>
      newFiber.flags |= Placement;
    }
    return newFiber;
  }
  function reconcileSingleTextNode(returnFiber, currentFirstChild, content) {
    const created = new FiberNode(HostText, { content }, null);
    created.return = returnFiber;
    return created;
  }
  function createChild(returnFiber, newChild) {
    if ((typeof newChild <span class="hljs-comment">=== &quot;string&quot; &amp;&amp; newChild !== &quot;&quot;) || typeof newChild === &quot;number&quot;) {</span>
      const created = createFiberFromText(`${newChild}`);
      created.return = returnFiber;
      return created;
    }

    if (typeof newChild <span class="hljs-comment">=== &quot;object&quot; &amp;&amp; newChild !== null) {</span>
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE: {
          const created = createFiberFromElement(newChild);
<span class="hljs-addition">+         created.ref = newChild.ref;</span>
          created.return = returnFiber;
          return created;
        }
        default:
          break;
      }
    }
    return null;
  }
  function placeChild(newFiber, lastPlacedIndex, newIndex) {
    newFiber.index = newIndex;
    if (!shouldTrackSideEffects) {
      return lastPlacedIndex;
    }
    const current = newFiber.alternate;
    if (current !== null) {
      const oldIndex = current.index;
      if (oldIndex &lt; lastPlacedIndex) {
        newFiber.flags |= Placement;
        return lastPlacedIndex;
      } else {
        return oldIndex;
      }
    } else {
      newFiber.flags |= Placement;
      return lastPlacedIndex;
    }
  }
  function updateElement(returnFiber, current, element) {
    const elementType = element.type;
    if (current !== null) {
      if (current.type <span class="hljs-comment">=== elementType) {</span>
        const existing = useFiber(current, element.props);
<span class="hljs-addition">+       existing.ref = element.ref;</span>
        existing.return = returnFiber;
        return existing;
      }
    }
    const created = createFiberFromElement(element);
<span class="hljs-addition">+   created.ref = element.ref;</span>
    created.return = returnFiber;
    return created;
  }
  function updateSlot(returnFiber, oldFiber, newChild) {
    const key = oldFiber !== null ? oldFiber.key : null;
    if (typeof newChild <span class="hljs-comment">=== &quot;object&quot; &amp;&amp; newChild !== null) {</span>
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE: {
          if (newChild.key <span class="hljs-comment">=== key) {</span>
            return updateElement(returnFiber, oldFiber, newChild);
          } else {
            return null;
          }
        }
        default:
          return null;
      }
    }
  }
  function mapRemainingChildren(returnFiber, currentFirstChild) {
    const existingChildren = new Map();
    let existingChild = currentFirstChild;
    while (existingChild !== null) {
      if (existingChild.key !== null) {
        existingChildren.set(existingChild.key, existingChild);
      } else {
        existingChildren.set(existingChild.index, existingChild);
      }
      existingChild = existingChild.sibling;
    }
    return existingChildren;
  }
  function updateTextNode(returnFiber, current, textContent) {
    if (current <span class="hljs-comment">=== null || current.tag !== HostText) {</span>
      const created = createFiberFromText(textContent, returnFiber.mode);
      created.return = returnFiber;
      return created;
    } else {
      const existing = useFiber(current, textContent);
      existing.return = returnFiber;
      return existing;
    }
  }
  function updateFromMap(existingChildren, returnFiber, newIdx, newChild) {
    if ((typeof newChild <span class="hljs-comment">=== &quot;string&quot; &amp;&amp; newChild !== &quot;&quot;) || typeof newChild === &quot;number&quot;) {</span>
      const matchedFiber = existingChildren.get(newIdx) || null;
      return updateTextNode(returnFiber, matchedFiber, &quot;&quot; + newChild);
    }
    if (typeof newChild <span class="hljs-comment">=== &quot;object&quot; &amp;&amp; newChild !== null) {</span>
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE: {
          const matchedFiber = existingChildren.get(newChild.key <span class="hljs-comment">=== null ? newIdx : newChild.key) || null;</span>
          return updateElement(returnFiber, matchedFiber, newChild);
        }
      }
    }
    return null;
  }
  function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren) {
    let resultingFirstChild = null;
    let previousNewFiber = null;
    let newIdx = 0;
    let oldFiber = currentFirstChild;
    let nextOldFiber = null;
    let lastPlacedIndex = 0;
    for (; oldFiber !== null &amp;&amp; newIdx &lt; newChildren.length; newIdx++) {
      nextOldFiber = oldFiber.sibling;
      const newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx]);
      if (newFiber <span class="hljs-comment">=== null) {</span>
        break;
      }
      if (shouldTrackSideEffects) {
        if (oldFiber &amp;&amp; newFiber.alternate <span class="hljs-comment">=== null) {</span>
          deleteChild(returnFiber, oldFiber);
        }
      }
      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
      if (previousNewFiber <span class="hljs-comment">=== null) {</span>
        resultingFirstChild = newFiber;
      } else {
        previousNewFiber.sibling = newFiber;
      }
      previousNewFiber = newFiber;
      oldFiber = nextOldFiber;
    }
    if (newIdx <span class="hljs-comment">=== newChildren.length) {</span>
      deleteRemainingChildren(returnFiber, oldFiber);
      return resultingFirstChild;
    }
    if (oldFiber <span class="hljs-comment">=== null) {</span>
      for (; newIdx &lt; newChildren.length; newIdx++) {
        const newFiber = createChild(returnFiber, newChildren[newIdx]);
        if (newFiber <span class="hljs-comment">=== null) {</span>
          continue;
        }
        lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
        if (previousNewFiber <span class="hljs-comment">=== null) {</span>
          resultingFirstChild = newFiber;
        } else {
          previousNewFiber.sibling = newFiber;
        }
        previousNewFiber = newFiber;
      }
    }
    const existingChildren = mapRemainingChildren(returnFiber, oldFiber);
    for (; newIdx &lt; newChildren.length; newIdx++) {
      const newFiber = updateFromMap(existingChildren, returnFiber, newIdx, newChildren[newIdx]);
      if (newFiber !== null) {
        if (shouldTrackSideEffects) {
          if (newFiber.alternate !== null) {
            existingChildren.delete(newFiber.key <span class="hljs-comment">=== null ? newIdx : newFiber.key);</span>
          }
        }
        lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
        if (previousNewFiber <span class="hljs-comment">=== null) {</span>
          resultingFirstChild = newFiber;
        } else {
          previousNewFiber.sibling = newFiber;
        }
        previousNewFiber = newFiber;
      }
    }
    if (shouldTrackSideEffects) {
      existingChildren.forEach((child) =&gt; deleteChild(returnFiber, child));
    }
    return resultingFirstChild;
  }
  function reconcileChildFibers(returnFiber, currentFirstChild, newChild) {
    if (typeof newChild <span class="hljs-comment">=== &quot;object&quot; &amp;&amp; newChild !== null) {</span>
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE: {
          return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild));
        }
        default:
          break;
      }
      if (isArray(newChild)) {
        return reconcileChildrenArray(returnFiber, currentFirstChild, newChild);
      }
    }
    if (typeof newChild <span class="hljs-comment">=== &quot;string&quot;) {</span>
      return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, newChild));
    }
    return null;
  }
  return reconcileChildFibers;
}
export const reconcileChildFibers = createChildReconciler(true);
export const mountChildFibers = createChildReconciler(false);
</code></pre>
<h2 id="t29941.&#x9965;&#x997F;&#x95EE;&#x9898;">41.&#x9965;&#x997F;&#x95EE;&#x9898; <a href="#t29941.&#x9965;&#x997F;&#x95EE;&#x9898;"> # </a></h2>
<h3 id="t30041.1 src\main.jsx">41.1 src\main.jsx <a href="#t30041.1 src\main.jsx"> # </a></h3>
<p>src\main.jsx</p>
<pre><code class="lang-diff">import * as React from &quot;react&quot;;
import { createRoot } from &quot;react-dom/client&quot;;

<span class="hljs-addition">+let counter = 0;</span>
<span class="hljs-addition">+let timer;</span>
<span class="hljs-addition">+let bCounter = 0;</span>
<span class="hljs-addition">+let cCounter = 0;</span>
<span class="hljs-addition">+function FunctionComponent() {</span>
<span class="hljs-addition">+  const [numbers, setNumbers] = React.useState(new Array(100).fill(&apos;A&apos;));</span>
<span class="hljs-addition">+  const divRef = React.useRef();</span>
<span class="hljs-addition">+  const updateB = (numbers) =&gt; new Array(100).fill(numbers[0] + &apos;B&apos;)</span>
<span class="hljs-addition">+  updateB.id = &apos;updateB&apos; + (bCounter++);</span>
<span class="hljs-addition">+  const updateC = (numbers) =&gt; new Array(100).fill(numbers[0] + &apos;C&apos;)</span>
<span class="hljs-addition">+  updateC.id = &apos;updateC&apos; + (cCounter++);</span>
<span class="hljs-addition">+  React.useEffect(() =&gt; {</span>
<span class="hljs-addition">+    timer = setInterval(() =&gt; {</span>
<span class="hljs-addition">+      console.log(divRef);</span>
<span class="hljs-addition">+      divRef.current.click();</span>
<span class="hljs-addition">+      if (counter++ === 0) {</span>
<span class="hljs-addition">+        setNumbers(updateB)</span>
<span class="hljs-addition">+      }</span>
<span class="hljs-addition">+      divRef.current.click();</span>
<span class="hljs-addition">+      if (counter++ &gt; 10) {</span>
<span class="hljs-addition">+        clearInterval(timer);</span>
<span class="hljs-addition">+      }</span>
<span class="hljs-addition">+    });</span>
<span class="hljs-addition">+  }, []);</span>
<span class="hljs-addition">+  return (&lt;div ref={divRef} onClick={() =&gt; setNumbers(updateC)}&gt;</span>
<span class="hljs-addition">+    {numbers.map((number, index) =&gt; &lt;span key={index}&gt;{number}&lt;/span&gt;)}&lt;/ div&gt;)</span>
<span class="hljs-addition">+}</span>

const element = &lt;FunctionComponent /&gt;;
const container = document.getElementById(&quot;root&quot;);
const root = createRoot(container, { unstable_concurrentUpdatesByDefault: true });
root.render(element);
</code></pre>
<h3 id="t30141.2 Scheduler.js">41.2 Scheduler.js <a href="#t30141.2 Scheduler.js"> # </a></h3>
<p>src\scheduler\src\forks\Scheduler.js</p>
<pre><code class="lang-diff">import {
  ImmediatePriority,
  UserBlockingPriority,
  NormalPriority,
  LowPriority,
  IdlePriority,
} from &quot;../SchedulerPriorities&quot;;
import { push, pop, peek } from &quot;../SchedulerMinHeap&quot;;
import { frameYieldMs } from &quot;../SchedulerFeatureFlags&quot;;

const maxSigned31BitInt = 1073741823;
const IMMEDIATE_PRIORITY_TIMEOUT = -1;
const USER_BLOCKING_PRIORITY_TIMEOUT = 250;
const NORMAL_PRIORITY_TIMEOUT = 5000;
const LOW_PRIORITY_TIMEOUT = 10000;
const IDLE_PRIORITY_TIMEOUT = maxSigned31BitInt;

const taskQueue = [];
let taskIdCounter = 1;
let scheduledHostCallback = null;
let startTime = -1;
let currentTask = null;
const frameInterval = frameYieldMs;
const channel = new MessageChannel();
const port = channel.port2;

const getCurrentTime = () =&gt; performance.now();
channel.port1.onmessage = performWorkUntilDeadline;

function schedulePerformWorkUntilDeadline() {
  port.postMessage(null);
}
function performWorkUntilDeadline() {
  if (scheduledHostCallback !== null) {
    startTime = getCurrentTime();
    let hasMoreWork = true;
    try {
      hasMoreWork = scheduledHostCallback(startTime);
    } finally {
      if (hasMoreWork) {
        schedulePerformWorkUntilDeadline();
      } else {
        scheduledHostCallback = null;
      }
    }
  }
}
function requestHostCallback(callback) {
  scheduledHostCallback = callback;
  schedulePerformWorkUntilDeadline();
}

function unstable_scheduleCallback(priorityLevel, callback) {
  const currentTime = getCurrentTime();
  const startTime = currentTime;
  let timeout;
  switch (priorityLevel) {
    case ImmediatePriority:
      timeout = IMMEDIATE_PRIORITY_TIMEOUT;
      break;
    case UserBlockingPriority:
      timeout = USER_BLOCKING_PRIORITY_TIMEOUT;
      break;
    case IdlePriority:
      timeout = IDLE_PRIORITY_TIMEOUT;
      break;
    case LowPriority:
      timeout = LOW_PRIORITY_TIMEOUT;
      break;
    case NormalPriority:
    default:
      timeout = NORMAL_PRIORITY_TIMEOUT;
      break;
  }
  const expirationTime = startTime + timeout;
  const newTask = {
    id: taskIdCounter++,
    callback,
    priorityLevel,
    startTime,
    expirationTime,
    sort<span class="hljs-comment">Index: -1,</span>
  };
  newTask.sortIndex = expirationTime;
  push(taskQueue, newTask);
  requestHostCallback(flushWork);
  return newTask;
}

function flushWork(initialTime) {
  return workLoop(initialTime);
}

function shouldYieldToHost() {
  const timeElapsed = getCurrentTime() - startTime;
  if (timeElapsed &lt; frameInterval) {
    return false;
  }
  return true;
}
function workLoop(initialTime) {
  let currentTime = initialTime;
  currentTask = peek(taskQueue);
  while (currentTask !== null) {
    if (currentTask.expirationTime &gt; currentTime &amp;&amp; shouldYieldToHost()) {
      break;
    }
    const callback = currentTask.callback;
    if (typeof callback <span class="hljs-comment">=== &quot;function&quot;) {</span>
      currentTask.callback = null;
      const didUserCallbackTimeout = currentTask.expirationTime &lt;= currentTime;
      const continuationCallback = callback(didUserCallbackTimeout);
      currentTime = getCurrentTime();
      if (typeof continuationCallback <span class="hljs-comment">=== &quot;function&quot;) {</span>
        currentTask.callback = continuationCallback;
        return true;
      }
      if (currentTask <span class="hljs-comment">=== peek(taskQueue)) {</span>
        pop(taskQueue);
      }
    } else {
      pop(taskQueue);
    }
    currentTask = peek(taskQueue);
  }
  if (currentTask !== null) {
    return true;
  }
  return false;
}

<span class="hljs-addition">+function unstable_cancelCallback(task) {</span>
<span class="hljs-addition">+  task.callback = null;</span>
<span class="hljs-addition">+}</span>

export {
  NormalPriority as unstable_NormalPriority,
  unstable_scheduleCallback,
  shouldYieldToHost as unstable_shouldYield,
<span class="hljs-addition">+ unstable_cancelCallback,</span>
<span class="hljs-addition">+ getCurrentTime as unstable_now</span>
};

</code></pre>
<h3 id="t30241.3 Scheduler.js">41.3 Scheduler.js <a href="#t30241.3 Scheduler.js"> # </a></h3>
<p>src\react-reconciler\src\Scheduler.js</p>
<pre><code class="lang-diff">import * as Scheduler from &apos;scheduler&apos;
export const scheduleCallback = Scheduler.unstable_scheduleCallback
export const NormalPriority = Scheduler.unstable_NormalPriority
export const ImmediatePriority = Scheduler.unstable_ImmediatePriority;
export const UserBlockingPriority = Scheduler.unstable_UserBlockingPriority;
export const LowPriority = Scheduler.unstable_LowPriority;
export const IdlePriority = Scheduler.unstable_IdlePriority;
export const shouldYield = Scheduler.unstable_shouldYield
<span class="hljs-addition">+export const cancelCallback = Scheduler.unstable_cancelCallback</span>
<span class="hljs-addition">+export const now = Scheduler.unstable_now;</span>
</code></pre>
<h3 id="t30341.4 ReactFiberWorkLoop.js">41.4 ReactFiberWorkLoop.js <a href="#t30341.4 ReactFiberWorkLoop.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberWorkLoop.js</p>
<pre><code class="lang-diff">import {
  scheduleCallback as Scheduler_scheduleCallback,
  ImmediatePriority as ImmediateSchedulerPriority,
  UserBlockingPriority as UserBlockingSchedulerPriority,
  NormalPriority as NormalSchedulerPriority,
  IdlePriority as IdleSchedulerPriority,
  shouldYield,
<span class="hljs-addition">+ cancelCallback as Scheduler_cancelCallback,</span>
<span class="hljs-addition">+ now</span>
} from &quot;./Scheduler&quot;;
import { createWorkInProgress } from &quot;./ReactFiber&quot;;
import { beginWork } from &quot;./ReactFiberBeginWork&quot;;
import { completeWork } from &quot;./ReactFiberCompleteWork&quot;;
import { MutationMask, NoFlags, Passive } from &quot;./ReactFiberFlags&quot;;
import {
  commitMutationEffects,
  commitPassiveUnmountEffects,
  commitPassiveMountEffects,
  commitLayoutEffects,
} from &quot;./ReactFiberCommitWork&quot;;
import { finishQueueingConcurrentUpdates } from &quot;./ReactFiberConcurrentUpdates&quot;;
import {
  NoLane, markRootUpdated, NoLanes,
  getNextLanes, getHighestPriorityLane, SyncLane,
<span class="hljs-addition">+ includesBlockingLane, markStarvedLanesAsExpired, includesExpiredLane,</span>
<span class="hljs-addition">+ mergeLanes, markRootFinished, NoTimestamp</span>
} from &apos;./ReactFiberLane&apos;;
import {
  getCurrentUpdatePriority, lanesToEventPriority, DiscreteEventPriority, ContinuousEventPriority,
  DefaultEventPriority, IdleEventPriority, setCurrentUpdatePriority
} from &apos;./ReactEventPriorities&apos;;
import { getCurrentEventPriority } from &apos;react-dom-bindings/src/client/ReactDOMHostConfig&apos;;
import { scheduleSyncCallback, flushSyncCallbacks } from &apos;./ReactFiberSyncTaskQueue&apos;;

let workInProgress = null;
let rootDoesHavePassiveEffects = false;
let rootWithPendingPassiveEffects = null;
let workInProgressRootRenderLanes = NoLanes;

const RootInProgress = 0;
const RootCompleted = 5;
let workInProgressRoot = null;
let workInProgressRootExitStatus = RootInProgress;
<span class="hljs-addition">+let currentEventTime = NoTimestamp;</span>

<span class="hljs-addition">+function cancelCallback(callbackNode) {</span>
<span class="hljs-addition">+  console.log(&apos;cancelCallback&apos;);</span>
<span class="hljs-addition">+  return Scheduler_cancelCallback(callbackNode);</span>
<span class="hljs-addition">+}</span>

<span class="hljs-addition">+export function scheduleUpdateOnFiber(root, fiber, lane, eventTime) {</span>
  markRootUpdated(root, lane);
<span class="hljs-addition">+ ensureRootIsScheduled(root, eventTime);</span>
}
<span class="hljs-addition">+function ensureRootIsScheduled(root, currentTime) {</span>
  const existingCallbackNode = root.callbackNode;
<span class="hljs-addition">+ markStarvedLanesAsExpired(root, currentTime);</span>
  const nextLanes = getNextLanes(root, root <span class="hljs-comment">=== workInProgressRoot ? workInProgressRootRenderLanes : NoLanes);</span>
  if (nextLanes <span class="hljs-comment">=== NoLanes) {</span>
    root.callbackNode = null;
    root.callbackPriority = NoLane;
    return;
  }
  const newCallbackPriority = getHighestPriorityLane(nextLanes);
  const existingCallbackPriority = root.callbackPriority;
  if (existingCallbackPriority <span class="hljs-comment">=== newCallbackPriority) {</span>
    return;
  }
  if (existingCallbackNode != null) {
    cancelCallback(existingCallbackNode);
  }
  let newCallbackNode;
  if (newCallbackPriority <span class="hljs-comment">=== SyncLane) {</span>
    scheduleSyncCallback(performSyncWorkOnRoot.bind(null, root));
    queueMicrotask(flushSyncCallbacks);
    newCallbackNode = null;
  } else {
    let schedulerPriorityLevel;
    switch (lanesToEventPriority(nextLanes)) {
      case DiscreteEventPriority:
        schedulerPriorityLevel = ImmediateSchedulerPriority;
        break;
      case ContinuousEventPriority:
        schedulerPriorityLevel = UserBlockingSchedulerPriority;
        break;
      case DefaultEventPriority:
        schedulerPriorityLevel = NormalSchedulerPriority;
        break;
      case IdleEventPriority:
        schedulerPriorityLevel = IdleSchedulerPriority;
        break;
      default:
        schedulerPriorityLevel = NormalSchedulerPriority;
        break;
    }
    newCallbackNode = Scheduler_scheduleCallback(schedulerPriorityLevel, performConcurrentWorkOnRoot.bind(null, root))
  }
  root.callbackPriority = newCallbackPriority;
  root.callbackNode = newCallbackNode;
}
function performSyncWorkOnRoot(root) {
  const lanes = getNextLanes(root, NoLanes);
  renderRootSync(root, lanes);
  const finishedWork = root.current.alternate
  root.finishedWork = finishedWork
  commitRoot(root)
  return null;
}
function performConcurrentWorkOnRoot(root, didTimeout) {
  const originalCallbackNode = root.callbackNode;
  const lanes = getNextLanes(root, NoLanes);
  if (lanes <span class="hljs-comment">=== NoLanes) {</span>
    return null;
  }
<span class="hljs-addition">+ const nonIncludesBlockingLane = !includesBlockingLane(root, lanes);</span>
<span class="hljs-addition">+ const nonIncludesExpiredLane = !includesExpiredLane(root, lanes);</span>
<span class="hljs-addition">+ const nonTimeout = !didTimeout;</span>
<span class="hljs-addition">+ const shouldTimeSlice = nonIncludesBlockingLane &amp;&amp; nonIncludesExpiredLane &amp;&amp; nonTimeout;</span>
  const exitStatus = shouldTimeSlice ? renderRootConcurrent(root, lanes) : renderRootSync(root, lanes);
  if (exitStatus !== RootInProgress) {
    const finishedWork = root.current.alternate
    root.finishedWork = finishedWork
    commitRoot(root)
  }
  if (root.callbackNode <span class="hljs-comment">=== originalCallbackNode) {</span>
    return performConcurrentWorkOnRoot.bind(null, root);
  }
  return null;
}
function renderRootConcurrent(root, lanes) {
 if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {
    prepareFreshStack(root, lanes);
  }
  workLoopConcurrent();
  if (workInProgress !== null) {
    return RootInProgress;
  }
  workInProgressRoot = null;
  workInProgressRootRenderLanes = NoLanes;
  return workInProgressRootExitStatus;
}
function workLoopConcurrent() {
  while (workInProgress !== null &amp;&amp; !shouldYield()) {
<span class="hljs-addition">+   sleep(5)</span>
    performUnitOfWork(workInProgress);
  }
}
export function flushPassiveEffects() {
  if (rootWithPendingPassiveEffects !== null) {
    const root = rootWithPendingPassiveEffects;
    commitPassiveUnmountEffects(root.current);
    commitPassiveMountEffects(root, root.current);
  }
}
function commitRoot(root) {
  const previousPriority = getCurrentUpdatePriority();
  try {
    setCurrentUpdatePriority(DiscreteEventPriority);
    commitRootImpl(root);
  } finally {
    setCurrentUpdatePriority(previousPriority);
  }
}
function commitRootImpl(root) {
  const { finishedWork } = root;
<span class="hljs-addition">+ console.log(&apos;commit&apos;, finishedWork.child.memoizedState.memoizedState[0]);</span>
  root.callbackNode = null;
  root.callbackPriority = NoLane;
<span class="hljs-addition">+ const remainingLanes = mergeLanes(finishedWork.lanes, finishedWork.childLanes);</span>
<span class="hljs-addition">+ markRootFinished(root, remainingLanes);</span>
  if ((finishedWork.subtreeFlags &amp; Passive) !== NoFlags || (finishedWork.flags &amp; Passive) !== NoFlags) {
    if (!rootDoesHavePassiveEffects) {
      rootDoesHavePassiveEffects = true;
      Scheduler_scheduleCallback(NormalSchedulerPriority, flushPassiveEffects);
    }
  }
  const subtreeHasEffects = (finishedWork.subtreeFlags &amp; MutationMask) !== NoFlags;
  const rootHasEffect = (finishedWork.flags &amp; MutationMask) !== NoFlags;
  if (subtreeHasEffects || rootHasEffect) {
    commitMutationEffects(finishedWork, root);
    commitLayoutEffects(finishedWork, root);
    root.current = finishedWork;
    if (rootDoesHavePassiveEffects) {
      rootDoesHavePassiveEffects = false;
      rootWithPendingPassiveEffects = root;
    }
  }
  root.current = finishedWork;
<span class="hljs-addition">+ ensureRootIsScheduled(root, now());</span>
}
function prepareFreshStack(root, lanes) {
  workInProgressRoot = root;
  workInProgress = createWorkInProgress(root.current, null);
  workInProgressRootRenderLanes = lanes;
  finishQueueingConcurrentUpdates();
}
function renderRootSync(root, lanes) {
  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {
    prepareFreshStack(root, lanes)
  }
  workLoopSync();
  workInProgressRoot = null;
  workInProgressRootRenderLanes = NoLanes;
  return workInProgressRootExitStatus;
}

function workLoopSync() {
  while (workInProgress !== null) {
    performUnitOfWork(workInProgress);
  }
}
function performUnitOfWork(unitOfWork) {
  const current = unitOfWork.alternate;
  const next = beginWork(current, unitOfWork, workInProgressRootRenderLanes);
  unitOfWork.memoizedProps = unitOfWork.pendingProps;
  if (next <span class="hljs-comment">=== null) {</span>
    completeUnitOfWork(unitOfWork);
  } else {
    workInProgress = next;
  }
}

function completeUnitOfWork(unitOfWork) {
  let completedWork = unitOfWork;
  do {
    const current = completedWork.alternate;
    const returnFiber = completedWork.return;
    completeWork(current, completedWork);
    const siblingFiber = completedWork.sibling;
    if (siblingFiber !== null) {
      workInProgress = siblingFiber;
      return;
    }
    completedWork = returnFiber;
    workInProgress = completedWork;
  } while (completedWork !== null);
  if (workInProgressRootExitStatus <span class="hljs-comment">=== RootInProgress) {</span>
    workInProgressRootExitStatus = RootCompleted;
  }
}

export function requestUpdateLane() {
  const updateLane = getCurrentUpdatePriority();
  if (updateLane !== NoLane) {
    return updateLane;
  }
  const eventLane = getCurrentEventPriority();
  return eventLane;
}

<span class="hljs-addition">+export function requestEventTime() {</span>
<span class="hljs-addition">+  currentEventTime = now();</span>
<span class="hljs-addition">+  return currentEventTime;</span>
<span class="hljs-addition">+}</span>

<span class="hljs-addition">+function sleep(time) {</span>
<span class="hljs-addition">+  const timeStamp = new Date().getTime();</span>
<span class="hljs-addition">+  const endTime = timeStamp + time;</span>
<span class="hljs-addition">+  while (true) {</span>
<span class="hljs-addition">+    if (new Date().getTime() &gt; endTime) {</span>
<span class="hljs-addition">+      return;</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+}</span>
</code></pre>
<h3 id="t30441.5 ReactFiberLane.js">41.5 ReactFiberLane.js <a href="#t30441.5 ReactFiberLane.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberLane.js</p>
<pre><code class="lang-diff">import { allowConcurrentByDefault } from &apos;shared/ReactFeatureFlags&apos;;

<span class="hljs-addition">+export const NoTimestamp = -1;</span>

export const TotalLanes = 31;
export const NoLanes = 0b0000000000000000000000000000000;
export const NoLane = 0b0000000000000000000000000000000;
export const SyncLane = 0b0000000000000000000000000000001;// 1
export const InputContinuousLane = 0b0000000000000000000000000000100;// 4
export const DefaultLane = 0b0000000000000000000000000010000;// 16
export const NonIdleLanes = 0b0001111111111111111111111111111;
export const IdleLane = 0b0100000000000000000000000000000;

export function mergeLanes(a, b) {
  return a | b;
}
export function markRootUpdated(root, updateLane) {
  root.pendingLanes |= updateLane;
}

export function getNextLanes(root, wipLanes) {
  const pendingLanes = root.pendingLanes;
  if (pendingLanes <span class="hljs-comment">=== NoLanes) {</span>
    return NoLanes;
  }
  const nextLanes = getHighestPriorityLanes(pendingLanes);
  if (wipLanes !== NoLanes &amp;&amp; wipLanes !== nextLanes) {
    if (nextLanes &gt;= wipLanes) {
      return wipLanes;
    }
  }
  return nextLanes;
}

function getHighestPriorityLanes(lanes) {
  return getHighestPriorityLane(lanes);
}

export function getHighestPriorityLane(lanes) {
  return lanes &amp; -lanes;
}

export function includesNonIdleWork(lanes) {
  return (lanes &amp; NonIdleLanes) !== NoLanes;
}
export function includesBlockingLane(root, lanes) {
  if (allowConcurrentByDefault) {
    return false;
  }
  const SyncDefaultLanes = InputContinuousLane | DefaultLane;
  return (lanes &amp; SyncDefaultLanes) !== NoLanes;
}
export function isSubsetOfLanes(set, subset) {
  return (set &amp; subset) <span class="hljs-comment">=== subset;</span>
}


<span class="hljs-addition">+function pickArbitraryLaneIndex(lanes) {</span>
<span class="hljs-addition">+  return 31 - Math.clz32(lanes);</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+</span>
<span class="hljs-addition">+export function markStarvedLanesAsExpired(root, currentTime) {</span>
<span class="hljs-addition">+  const pendingLanes = root.pendingLanes;</span>
<span class="hljs-addition">+  const expirationTimes = root.expirationTimes;</span>
<span class="hljs-addition">+  let lanes = pendingLanes</span>
<span class="hljs-addition">+  while (lanes &gt; 0) {</span>
<span class="hljs-addition">+    const index = pickArbitraryLaneIndex(lanes);</span>
<span class="hljs-addition">+    const lane = 1 &lt;&lt; index;</span>
<span class="hljs-addition">+    const expirationTime = expirationTimes[index];</span>
<span class="hljs-addition">+    if (expirationTime === NoTimestamp) {</span>
<span class="hljs-addition">+      expirationTimes[index] = computeExpirationTime(lane, currentTime);</span>
<span class="hljs-addition">+    } else if (expirationTime &lt;= currentTime) {</span>
<span class="hljs-addition">+      root.expiredLanes |= lane;</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+    lanes &amp;= ~lane;</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+</span>
<span class="hljs-addition">+function computeExpirationTime(lane, currentTime) {</span>
<span class="hljs-addition">+  switch (lane) {</span>
<span class="hljs-addition">+    case SyncLane:</span>
<span class="hljs-addition">+    case InputContinuousLane:</span>
<span class="hljs-addition">+      return currentTime + 250;</span>
<span class="hljs-addition">+    case DefaultLane:</span>
<span class="hljs-addition">+      return currentTime + 5000;</span>
<span class="hljs-addition">+    case IdleLane:</span>
<span class="hljs-addition">+      return NoTimestamp;</span>
<span class="hljs-addition">+    default:</span>
<span class="hljs-addition">+      return NoTimestamp;</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+export function createLaneMap(initial) {</span>
<span class="hljs-addition">+  const laneMap = [];</span>
<span class="hljs-addition">+  for (let i = 0; i &lt; TotalLanes; i++) {</span>
<span class="hljs-addition">+    laneMap.push(initial);</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+  return laneMap;</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+export function includesExpiredLane(root, lanes) {</span>
<span class="hljs-addition">+  return (lanes &amp; root.expiredLanes) !== NoLanes;</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+export function markRootFinished(root, remainingLanes) {</span>
<span class="hljs-addition">+  const noLongerPendingLanes = root.pendingLanes &amp; ~remainingLanes;</span>
<span class="hljs-addition">+  root.pendingLanes = remainingLanes;</span>
<span class="hljs-addition">+  let lanes = noLongerPendingLanes;</span>
<span class="hljs-addition">+  const expirationTimes = root.expirationTimes;</span>
<span class="hljs-addition">+  while (lanes &gt; 0) {</span>
<span class="hljs-addition">+    const index = pickArbitraryLaneIndex(lanes);</span>
<span class="hljs-addition">+    const lane = 1 &lt;&lt; index;</span>
<span class="hljs-addition">+    expirationTimes[index] = NoTimestamp;</span>
<span class="hljs-addition">+    lanes &amp;= ~lane;</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+}</span>
</code></pre>
<h3 id="t30541.6 ReactFiber.js">41.6 ReactFiber.js <a href="#t30541.6 ReactFiber.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiber.js</p>
<pre><code class="lang-diff">import { HostRoot, IndeterminateComponent, HostComponent, HostText } from &quot;./ReactWorkTags&quot;;
import { NoFlags } from &quot;./ReactFiberFlags&quot;;
<span class="hljs-addition">+import { NoLanes } from &apos;./ReactFiberLane&apos;;</span>

export function FiberNode(tag, pendingProps, key) {
  this.tag = tag;
  this.key = key;
  this.type = null;
  this.stateNode = null;

  this.return = null;
  this.child = null;
  this.sibling = null;

  this.pendingProps = pendingProps;
  this.memoizedProps = null;
  this.updateQueue = null;
  this.memoizedState = null;

  this.flags = NoFlags;
  this.subtreeFlags = NoFlags;
  this.deletions = null;
  this.alternate = null;

  this.index = 0;
  this.ref = null;
<span class="hljs-addition">+ this.lanes = NoLanes;</span>
<span class="hljs-addition">+ this.childLanes = NoLanes;</span>
}
function createFiber(tag, pendingProps, key) {
  return new FiberNode(tag, pendingProps, key);
}
export function createHostRootFiber() {
  return createFiber(HostRoot, null, null);
}
// We use a double buffering pooling technique because we know that we&apos;ll
// only ever need at most two versions of a tree. We pool the &quot;other&quot; unused
// node that we&apos;re free to reuse. This is lazily created to avoid allocating
// extra objects for things that are never updated. It also allow us to
// reclaim the extra memory if needed.
//&#x6211;&#x4EEC;&#x4F7F;&#x7528;&#x53CC;&#x7F13;&#x51B2;&#x6C60;&#x6280;&#x672F;&#xFF0C;&#x56E0;&#x4E3A;&#x6211;&#x4EEC;&#x77E5;&#x9053;&#x4E00;&#x68F5;&#x6811;&#x6700;&#x591A;&#x53EA;&#x9700;&#x8981;&#x4E24;&#x4E2A;&#x7248;&#x672C;
//&#x6211;&#x4EEC;&#x5C06;&#x201C;&#x5176;&#x4ED6;&#x201D;&#x672A;&#x4F7F;&#x7528;&#x7684;&#x6211;&#x4EEC;&#x53EF;&#x4EE5;&#x81EA;&#x7531;&#x91CD;&#x7528;&#x7684;&#x8282;&#x70B9;
//&#x8FD9;&#x662F;&#x5EF6;&#x8FDF;&#x521B;&#x5EFA;&#x7684;&#xFF0C;&#x4EE5;&#x907F;&#x514D;&#x5206;&#x914D;&#x4ECE;&#x672A;&#x66F4;&#x65B0;&#x7684;&#x5185;&#x5BB9;&#x7684;&#x989D;&#x5916;&#x5BF9;&#x8C61;&#x3002;&#x5B83;&#x8FD8;&#x5141;&#x8BB8;&#x6211;&#x4EEC;&#x5982;&#x679C;&#x9700;&#x8981;&#xFF0C;&#x56DE;&#x6536;&#x989D;&#x5916;&#x7684;&#x5185;&#x5B58;
export function createWorkInProgress(current, pendingProps) {
  let workInProgress = current.alternate;
  if (workInProgress <span class="hljs-comment">=== null) {</span>
    workInProgress = createFiber(current.tag, pendingProps, current.key);
    workInProgress.type = current.type;
    workInProgress.stateNode = current.stateNode;
    workInProgress.alternate = current;
    current.alternate = workInProgress;
  } else {
    workInProgress.pendingProps = pendingProps;
    workInProgress.type = current.type;
    workInProgress.flags = NoFlags;
    workInProgress.subtreeFlags = NoFlags;
<span class="hljs-addition">+   workInProgress.deletions = null;</span>
  }
  workInProgress.child = current.child;
  workInProgress.memoizedProps = current.memoizedProps;
  workInProgress.memoizedState = current.memoizedState;
  workInProgress.updateQueue = current.updateQueue;
  workInProgress.sibling = current.sibling;
  workInProgress.index = current.index;
  workInProgress.ref = current.ref;
<span class="hljs-addition">+ workInProgress.flags = current.flags;</span>
<span class="hljs-addition">+ workInProgress.childLanes = current.childLanes;</span>
<span class="hljs-addition">+ workInProgress.lanes = current.lanes;</span>
  return workInProgress;
}
export function createFiberFromTypeAndProps(type, key, pendingProps) {
  let fiberTag = IndeterminateComponent;
  if (typeof type <span class="hljs-comment">=== &quot;string&quot;) {</span>
    fiberTag = HostComponent;
  }
  const fiber = createFiber(fiberTag, pendingProps, key);
  fiber.type = type;
  return fiber;
}
export function createFiberFromElement(element) {
  const { type } = element;
  const { key } = element;
  const pendingProps = element.props;
  const fiber = createFiberFromTypeAndProps(type, key, pendingProps);
  return fiber;
}

export function createFiberFromText(content) {
  const fiber = createFiber(HostText, content, null);
  return fiber;
}
</code></pre>
<h3 id="t30641.7 ReactFiberBeginWork.js">41.7 ReactFiberBeginWork.js <a href="#t30641.7 ReactFiberBeginWork.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberBeginWork.js</p>
<pre><code class="lang-diff">import { HostRoot, HostComponent, HostText, IndeterminateComponent, FunctionComponent } from &quot;./ReactWorkTags&quot;;
import { processUpdateQueue, cloneUpdateQueue } from &quot;./ReactFiberClassUpdateQueue&quot;;
import { mountChildFibers, reconcileChildFibers } from &quot;./ReactChildFiber&quot;;
import { shouldSetTextContent } from &quot;react-dom-bindings/src/client/ReactDOMHostConfig&quot;;
import { renderWithHooks } from &quot;react-reconciler/src/ReactFiberHooks&quot;;
<span class="hljs-addition">+import { NoLanes } from &apos;./ReactFiberLane&apos;;</span>

function reconcileChildren(current, workInProgress, nextChildren) {
  if (current <span class="hljs-comment">=== null) {</span>
    workInProgress.child = mountChildFibers(workInProgress, null, nextChildren);
  } else {
    workInProgress.child = reconcileChildFibers(workInProgress, current.child, nextChildren);
  }
}
function updateHostRoot(current, workInProgress, renderLanes) {
  const nextProps = workInProgress.pendingProps;
  cloneUpdateQueue(current, workInProgress);
  processUpdateQueue(workInProgress, nextProps, renderLanes)
  const nextState = workInProgress.memoizedState;
  const nextChildren = nextState.element;
  reconcileChildren(current, workInProgress, nextChildren);
  return workInProgress.child;
}
function updateHostComponent(current, workInProgress) {
  const { type } = workInProgress;
  const nextProps = workInProgress.pendingProps;
  let nextChildren = nextProps.children;
  const isDirectTextChild = shouldSetTextContent(type, nextProps);
  if (isDirectTextChild) {
    nextChildren = null;
  }
  reconcileChildren(current, workInProgress, nextChildren);
  return workInProgress.child;
}
function mountIndeterminateComponent(_current, workInProgress, Component) {
  const props = workInProgress.pendingProps;
  const value = renderWithHooks(null, workInProgress, Component, props);
  workInProgress.tag = FunctionComponent;
  reconcileChildren(null, workInProgress, value);
  return workInProgress.child;
}
<span class="hljs-addition">+function updateFunctionComponent(current, workInProgress, Component, nextProps, renderLanes) {</span>
<span class="hljs-addition">+ const nextChildren = renderWithHooks(current, workInProgress, Component, nextProps, renderLanes);</span>
  reconcileChildren(current, workInProgress, nextChildren);
  return workInProgress.child;
}
export function beginWork(current, workInProgress, renderLanes) {
<span class="hljs-addition">+ workInProgress.lanes = NoLanes;</span>
  switch (workInProgress.tag) {
    case IndeterminateComponent: {
      return mountIndeterminateComponent(current, workInProgress, workInProgress.type, renderLanes);
    }
    case FunctionComponent: {
      const Component = workInProgress.type;
      const resolvedProps = workInProgress.pendingProps;
<span class="hljs-addition">+     return updateFunctionComponent(current, workInProgress, Component, resolvedProps, renderLanes);</span>
    }
    case HostRoot:
      return updateHostRoot(current, workInProgress, renderLanes);
    case HostComponent:
      return updateHostComponent(current, workInProgress, renderLanes);
    case HostText:
    default:
      return null;
  }
}
</code></pre>
<h3 id="t30741.8 ReactFiberCompleteWork.js">41.8 ReactFiberCompleteWork.js <a href="#t30741.8 ReactFiberCompleteWork.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberCompleteWork.js</p>
<pre><code class="lang-diff">import {
  appendInitialChild,
  createInstance,
  createTextInstance,
  finalizeInitialChildren,
  prepareUpdate,
} from &quot;react-dom-bindings/src/client/ReactDOMHostConfig&quot;;
import { HostComponent, HostRoot, HostText, FunctionComponent } from &quot;./ReactWorkTags&quot;;
import { Ref, NoFlags, Update } from &quot;./ReactFiberFlags&quot;;
<span class="hljs-addition">+import { NoLanes, mergeLanes } from &apos;./ReactFiberLane&apos;;</span>

function markRef(workInProgress) {
  workInProgress.flags |= Ref;
}

function bubbleProperties(completedWork) {
<span class="hljs-addition">+ let newChildLanes = NoLanes;</span>
  let subtreeFlags = NoFlags;
  let child = completedWork.child;
  while (child !== null) {
<span class="hljs-addition">+   newChildLanes = mergeLanes(newChildLanes, mergeLanes(child.lanes, child.childLanes));</span>
    subtreeFlags |= child.subtreeFlags;
    subtreeFlags |= child.flags;
    child = child.sibling;
  }
<span class="hljs-addition">+ completedWork.childLanes = newChildLanes;</span>
  completedWork.subtreeFlags |= subtreeFlags;
}

function appendAllChildren(parent, workInProgress) {
  // &#x6211;&#x4EEC;&#x53EA;&#x6709;&#x521B;&#x5EFA;&#x7684;&#x9876;&#x7EA7;fiber&#xFF0C;&#x4F46;&#x9700;&#x8981;&#x9012;&#x5F52;&#x5176;&#x5B50;&#x8282;&#x70B9;&#x6765;&#x67E5;&#x627E;&#x6240;&#x6709;&#x7EC8;&#x7AEF;&#x8282;&#x70B9;
  let node = workInProgress.child;
  while (node !== null) {
    // &#x5982;&#x679C;&#x662F;&#x539F;&#x751F;&#x8282;&#x70B9;&#xFF0C;&#x76F4;&#x63A5;&#x6DFB;&#x52A0;&#x5230;&#x7236;&#x8282;&#x70B9;&#x4E0A;
    if (node.tag <span class="hljs-comment">=== HostComponent || node.tag === HostText) {</span>
      appendInitialChild(parent, node.stateNode);
      // &#x518D;&#x770B;&#x770B;&#x7B2C;&#x4E00;&#x4E2A;&#x8282;&#x8282;&#x70B9;&#x662F;&#x4E0D;&#x662F;&#x539F;&#x751F;&#x8282;&#x70B9;
    } else if (node.child !== null) {
      // node.child.return = node
      node = node.child;
      continue;
    }
    if (node <span class="hljs-comment">=== workInProgress) {</span>
      return;
    }
    // &#x5982;&#x679C;&#x6CA1;&#x6709;&#x5F1F;&#x5F1F;&#x5C31;&#x627E;&#x7236;&#x4EB2;&#x7684;&#x5F1F;&#x5F1F;
    while (node.sibling <span class="hljs-comment">=== null) {</span>
      // &#x5982;&#x679C;&#x627E;&#x5230;&#x4E86;&#x6839;&#x8282;&#x70B9;&#x6216;&#x8005;&#x56DE;&#x5230;&#x4E86;&#x539F;&#x8282;&#x70B9;&#x7ED3;&#x675F;
      if (node.return <span class="hljs-comment">=== null || node.return === workInProgress) {</span>
        return;
      }
      node = node.return;
    }
    // node.sibling.return = node.return
    // &#x4E0B;&#x4E00;&#x4E2A;&#x5F1F;&#x5F1F;&#x8282;&#x70B9;
    node = node.sibling;
  }
}
function markUpdate(workInProgress) {
  workInProgress.flags |= Update;
}
function updateHostComponent(current, workInProgress, type, newProps) {
  const oldProps = current.memoizedProps;
  const instance = workInProgress.stateNode;
  const updatePayload = prepareUpdate(instance, type, oldProps, newProps);
  workInProgress.updateQueue = updatePayload;
  if (updatePayload) {
    markUpdate(workInProgress);
  }
}
export function completeWork(current, workInProgress) {
  const newProps = workInProgress.pendingProps;
  switch (workInProgress.tag) {
    case HostComponent: {
      const { type } = workInProgress;
      if (current !== null &amp;&amp; workInProgress.stateNode != null) {
        updateHostComponent(current, workInProgress, type, newProps);
        if (current.ref !== workInProgress.ref) {
          markRef(workInProgress);
        }
      } else {
        const instance = createInstance(type, newProps, workInProgress);
        appendAllChildren(instance, workInProgress);
        workInProgress.stateNode = instance;
        finalizeInitialChildren(instance, type, newProps);
        if (workInProgress.ref !== null) {
          markRef(workInProgress);
        }
      }
      bubbleProperties(workInProgress);
      return null;
    }
    case FunctionComponent:
      bubbleProperties(workInProgress);
      break;
    case HostRoot:
      bubbleProperties(workInProgress);
      break;
    case HostText: {
      const newText = newProps;
      workInProgress.stateNode = createTextInstance(newText);
      bubbleProperties(workInProgress);
      break;
    }
    default:
      break;
  }
}
</code></pre>
<h3 id="t30841.9 ReactFiberConcurrentUpdates.js">41.9 ReactFiberConcurrentUpdates.js <a href="#t30841.9 ReactFiberConcurrentUpdates.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberConcurrentUpdates.js</p>
<pre><code class="lang-diff">import { HostRoot } from &quot;./ReactWorkTags&quot;;
<span class="hljs-addition">+import { mergeLanes, NoLanes } from &apos;./ReactFiberLane&apos;;</span>

const concurrentQueues = [];
let concurrentQueuesIndex = 0;

export function markUpdateLaneFromFiberToRoot(sourceFiber) {
  let node = sourceFiber;
  let parent = sourceFiber.return;
  while (parent !== null) {
    node = parent;
    parent = parent.return;
  }
  if (node.tag <span class="hljs-comment">=== HostRoot) {</span>
    const root = node.stateNode;
    return root;
  }
  return null;
}
export function enqueueConcurrentHookUpdate(fiber, queue, update, lane) {
  enqueueUpdate(fiber, queue, update, lane);
  return getRootForUpdatedFiber(fiber);
}
export function enqueueConcurrentClassUpdate(fiber, queue, update, lane) {
  enqueueUpdate(fiber, queue, update, lane);
  return getRootForUpdatedFiber(fiber);
}

function enqueueUpdate(fiber, queue, update, lane) {
  concurrentQueues[concurrentQueuesIndex++] = fiber;
  concurrentQueues[concurrentQueuesIndex++] = queue;
  concurrentQueues[concurrentQueuesIndex++] = update;
  concurrentQueues[concurrentQueuesIndex++] = lane;
<span class="hljs-addition">+ fiber.lanes = mergeLanes(fiber.lanes, lane);</span>
}
function getRootForUpdatedFiber(sourceFiber) {
  let node = sourceFiber;
  let parent = node.return;
  while (parent !== null) {
    node = parent;
    parent = node.return;
  }
  return node.tag <span class="hljs-comment">=== HostRoot ? node.stateNode : null;</span>
}

export function finishQueueingConcurrentUpdates() {
  const endIndex = concurrentQueuesIndex;
  concurrentQueuesIndex = 0;
  let i = 0;
  while (i &lt; endIndex) {
    const fiber = concurrentQueues[i++];
    const queue = concurrentQueues[i++];
    const update = concurrentQueues[i++];
    const lane = concurrentQueues[i++]
    if (queue !== null &amp;&amp; update !== null) {
      const pending = queue.pending;
      if (pending <span class="hljs-comment">=== null) {</span>
        update.next = update;
      } else {
        update.next = pending.next;
        pending.next = update;
      }
      queue.pending = update;
    }
  }
}
</code></pre>
<h3 id="t30941.10 ReactFiberHooks.js">41.10 ReactFiberHooks.js <a href="#t30941.10 ReactFiberHooks.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberHooks.js</p>
<pre><code class="lang-diff">import ReactSharedInternals from &quot;shared/ReactSharedInternals&quot;;
import { enqueueConcurrentHookUpdate } from &quot;./ReactFiberConcurrentUpdates&quot;;
<span class="hljs-addition">+import { scheduleUpdateOnFiber, requestUpdateLane, requestEventTime } from &quot;./ReactFiberWorkLoop&quot;;</span>
import is from &quot;shared/objectIs&quot;;
import { Passive as PassiveEffect, Update as UpdateEffect } from &quot;./ReactFiberFlags&quot;;
import { HasEffect as HookHasEffect, Passive as HookPassive, Layout as HookLayout } from &quot;./ReactHookEffectTags&quot;;
<span class="hljs-addition">+import { NoLanes, NoLane, mergeLanes, isSubsetOfLanes } from &apos;./ReactFiberLane&apos;;</span>

const { ReactCurrentDispatcher } = ReactSharedInternals;
let currentlyRenderingFiber = null;
let workInProgressHook = null;
let currentHook = null;
<span class="hljs-addition">+let renderLanes = NoLanes;</span>

const HooksDispatcherOnMountInDEV = {
  useReducer: mountReducer,
  useState: mountState,
  useEffect: mountEffect,
  useLayoutEffect: mountLayoutEffect,
  useRef: mountRef,
};
const HooksDispatcherOnUpdateInDEV = {
  useReducer: updateReducer,
  useState: updateState,
  useEffect: updateEffect,
  useLayoutEffect: updateLayoutEffect,
  useRef: updateRef
};
function mountRef(initialValue) {
  const hook = mountWorkInProgressHook();
  const ref = {
    current: initialValue,
  };
  hook.memoizedState = ref;
  return ref;
}
function updateRef() {
  const hook = updateWorkInProgressHook();
  return hook.memoizedState;
}
export function useLayoutEffect(reducer, initialArg) {
  return ReactCurrentDispatcher.current.useLayoutEffect(reducer, initialArg);
}
function updateLayoutEffect(create, deps) {
  return updateEffectImpl(UpdateEffect, HookLayout, create, deps);
}
function mountLayoutEffect(create, deps) {
  const fiberFlags = UpdateEffect;
  return mountEffectImpl(fiberFlags, HookLayout, create, deps);
}
function updateEffect(create, deps) {
  return updateEffectImpl(PassiveEffect, HookPassive, create, deps);
}
function updateEffectImpl(fiberFlags, hookFlags, create, deps) {
  const hook = updateWorkInProgressHook();
  const nextDeps = deps <span class="hljs-comment">=== undefined ? null : deps;</span>
  let destroy;
  if (currentHook !== null) {
    const prevEffect = currentHook.memoizedState;
    destroy = prevEffect.destroy;
    if (nextDeps !== null) {
      const prevDeps = prevEffect.deps;
      if (areHookInputsEqual(nextDeps, prevDeps)) {
        hook.memoizedState = pushEffect(hookFlags, create, destroy, nextDeps);
        return;
      }
    }
  }
  currentlyRenderingFiber.flags |= fiberFlags;
  hook.memoizedState = pushEffect(HookHasEffect | hookFlags, create, destroy, nextDeps);
}
function areHookInputsEqual(nextDeps, prevDeps) {
  if (prevDeps <span class="hljs-comment">=== null) {</span>
    return false;
  }
  for (let i = 0; i &lt; prevDeps.length &amp;&amp; i &lt; nextDeps.length; i++) {
    if (is(nextDeps[i], prevDeps[i])) {
      continue;
    }
    return false;
  }

  return true;
}
function mountEffect(create, deps) {
  return mountEffectImpl(PassiveEffect, HookPassive, create, deps);
}
function mountEffectImpl(fiberFlags, hookFlags, create, deps) {
  const hook = mountWorkInProgressHook();
  const nextDeps = deps <span class="hljs-comment">=== undefined ? null : deps;</span>
  currentlyRenderingFiber.flags |= fiberFlags;
  hook.memoizedState = pushEffect(HookHasEffect | hookFlags, create, undefined, nextDeps);
}
function pushEffect(tag, create, destroy, deps) {
  const effect = {
    tag,
    create,
    destroy,
    deps,
    next: null,
  };
  let componentUpdateQueue = currentlyRenderingFiber.updateQueue;
  if (componentUpdateQueue <span class="hljs-comment">=== null) {</span>
    componentUpdateQueue = createFunctionComponentUpdateQueue();
    currentlyRenderingFiber.updateQueue = componentUpdateQueue;
    componentUpdateQueue.lastEffect = effect.next = effect;
  } else {
    const lastEffect = componentUpdateQueue.lastEffect;
    if (lastEffect <span class="hljs-comment">=== null) {</span>
      componentUpdateQueue.lastEffect = effect.next = effect;
    } else {
      const firstEffect = lastEffect.next;
      lastEffect.next = effect;
      effect.next = firstEffect;
      componentUpdateQueue.lastEffect = effect;
    }
  }
  return effect;
}
function createFunctionComponentUpdateQueue() {
  return {
    lastEffect: null,
  };
}
function basicStateReducer(state, action) {
  return typeof action <span class="hljs-comment">=== &quot;function&quot; ? action(state) : action;</span>
}
function mountReducer(reducer, initialArg) {
  const hook = mountWorkInProgressHook();
  hook.memoizedState = initialArg;
  const queue = {
    pending: null,
    dispatch: null,
<span class="hljs-addition">+   lastRenderedReducer: reducer,</span>
<span class="hljs-addition">+   lastRenderedState: initialArg</span>
  };
  hook.queue = queue;
  const dispatch = (queue.dispatch = dispatchReducerAction.bind(null, currentlyRenderingFiber, queue));
  return [hook.memoizedState, dispatch];
}
function updateReducer(reducer) {
<span class="hljs-addition">+  const hook = updateWorkInProgressHook();</span>
<span class="hljs-addition">+  const queue = hook.queue;</span>
<span class="hljs-addition">+  queue.lastRenderedReducer = reducer;</span>
<span class="hljs-addition">+  const current = currentHook;</span>
<span class="hljs-addition">+  let baseQueue = current.baseQueue;</span>
<span class="hljs-addition">+  const pendingQueue = queue.pending;</span>
<span class="hljs-addition">+  if (pendingQueue !== null) {</span>
<span class="hljs-addition">+    if (baseQueue !== null) {</span>
<span class="hljs-addition">+      const baseFirst = baseQueue.next;</span>
<span class="hljs-addition">+      const pendingFirst = pendingQueue.next;</span>
<span class="hljs-addition">+      baseQueue.next = pendingFirst;</span>
<span class="hljs-addition">+      pendingQueue.next = baseFirst;</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+    current.baseQueue = baseQueue = pendingQueue;</span>
<span class="hljs-addition">+    queue.pending = null;</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+  if (baseQueue !== null) {</span>
<span class="hljs-addition">+    printQueue(baseQueue)</span>
<span class="hljs-addition">+    const first = baseQueue.next;</span>
<span class="hljs-addition">+    let newState = current.baseState;</span>
<span class="hljs-addition">+    let newBaseState = null;</span>
<span class="hljs-addition">+    let newBaseQueueFirst = null;</span>
<span class="hljs-addition">+    let newBaseQueueLast = null;</span>
<span class="hljs-addition">+    let update = first;</span>
<span class="hljs-addition">+    do {</span>
<span class="hljs-addition">+      const updateLane = update.lane;</span>
<span class="hljs-addition">+      const shouldSkipUpdate = !isSubsetOfLanes(renderLanes, updateLane);</span>
<span class="hljs-addition">+      if (shouldSkipUpdate) {</span>
<span class="hljs-addition">+        const clone = {</span>
<span class="hljs-addition">+          lane: updateLane,</span>
<span class="hljs-addition">+          action: update.action,</span>
<span class="hljs-addition">+          hasEagerState: update.hasEagerState,</span>
<span class="hljs-addition">+          eagerState: update.eagerState,</span>
<span class="hljs-addition">+          next: null,</span>
<span class="hljs-addition">+        };</span>
<span class="hljs-addition">+        if (newBaseQueueLast === null) {</span>
<span class="hljs-addition">+          newBaseQueueFirst = newBaseQueueLast = clone;</span>
<span class="hljs-addition">+          newBaseState = newState;</span>
<span class="hljs-addition">+        } else {</span>
<span class="hljs-addition">+          newBaseQueueLast = newBaseQueueLast.next = clone;</span>
<span class="hljs-addition">+        }</span>
<span class="hljs-addition">+        currentlyRenderingFiber.lanes = mergeLanes(currentlyRenderingFiber.lanes, updateLane);</span>
<span class="hljs-addition">+      } else {</span>
<span class="hljs-addition">+        if (newBaseQueueLast !== null) {</span>
<span class="hljs-addition">+          const clone = {</span>
<span class="hljs-addition">+            lane: NoLane,</span>
<span class="hljs-addition">+            action: update.action,</span>
<span class="hljs-addition">+            hasEagerState: update.hasEagerState,</span>
<span class="hljs-addition">+            eagerState: update.eagerState,</span>
<span class="hljs-addition">+            next: null,</span>
<span class="hljs-addition">+          };</span>
<span class="hljs-addition">+          newBaseQueueLast = newBaseQueueLast.next = clone;</span>
<span class="hljs-addition">+        }</span>
<span class="hljs-addition">+        if (update.hasEagerState) {</span>
<span class="hljs-addition">+          newState = update.eagerState;</span>
<span class="hljs-addition">+        } else {</span>
<span class="hljs-addition">+          const action = update.action;</span>
<span class="hljs-addition">+          newState = reducer(newState, action);</span>
<span class="hljs-addition">+        }</span>
<span class="hljs-addition">+      }</span>
<span class="hljs-addition">+      update = update.next;</span>
<span class="hljs-addition">+    } while (update !== null &amp;&amp; update !== first);</span>
<span class="hljs-addition">+    if (newBaseQueueLast === null) {</span>
<span class="hljs-addition">+      newBaseState = newState;</span>
<span class="hljs-addition">+    } else {</span>
<span class="hljs-addition">+      newBaseQueueLast.next = newBaseQueueFirst;</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+    hook.memoizedState = newState;</span>
<span class="hljs-addition">+    hook.baseState = newBaseState;</span>
<span class="hljs-addition">+    hook.baseQueue = newBaseQueueLast;</span>
<span class="hljs-addition">+    queue.lastRenderedState = newState;</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+  if (baseQueue === null) {</span>
<span class="hljs-addition">+    queue.lanes = NoLanes;</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+  const dispatch = queue.dispatch;</span>
<span class="hljs-addition">+  return [hook.memoizedState, dispatch];</span>
}
function mountState(initialState) {
  const hook = mountWorkInProgressHook();
  hook.memoizedState = initialState;
  const queue = {
    pending: null,
    dispatch: null,
    lastRenderedReducer: basicStateReducer,
    lastRenderedState: initialState,
  };
  hook.queue = queue;
  const dispatch = (queue.dispatch = dispatchSetState.bind(null, currentlyRenderingFiber, queue));
  return [hook.memoizedState, dispatch];
}
function dispatchSetState(fiber, queue, action) {
  const lane = requestUpdateLane(fiber);
  const update = {
    lane,
    action,
    hasEagerState: false,
    eagerState: null,
    next: null,
  };
  const alternate = fiber.alternate;
  if (fiber.lanes <span class="hljs-comment">=== NoLanes &amp;&amp; (alternate === null || alternate.lanes === NoLanes)) {</span>
    const lastRenderedReducer = queue.lastRenderedReducer;
    const currentState = queue.lastRenderedState;
    const eagerState = lastRenderedReducer(currentState, action);
    update.hasEagerState = true;
    update.eagerState = eagerState;
    if (is(eagerState, currentState)) {
      return;
    }
  }
  const root = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
<span class="hljs-addition">+ const eventTime = requestEventTime();</span>
<span class="hljs-addition">+ scheduleUpdateOnFiber(root, fiber, lane, eventTime);</span>
}
function updateState(initialState) {
  return updateReducer(basicStateReducer, initialState);
}
function mountWorkInProgressHook() {
  const hook = {
    memoizedState: null,
    queue: null,
    next: null,
<span class="hljs-addition">+   baseState: null,</span>
<span class="hljs-addition">+   baseQueue: null,</span>
  };
  if (workInProgressHook <span class="hljs-comment">=== null) {</span>
    currentlyRenderingFiber.memoizedState = workInProgressHook = hook;
  } else {
    workInProgressHook = workInProgressHook.next = hook;
  }
  return workInProgressHook;
}
function dispatchReducerAction(fiber, queue, action) {
  const update = {
    action,
    next: null,
  };
  const root = enqueueConcurrentHookUpdate(fiber, queue, update);
  scheduleUpdateOnFiber(root, fiber);
}

function updateWorkInProgressHook() {
  let nextCurrentHook;
  if (currentHook <span class="hljs-comment">=== null) {</span>
    const current = currentlyRenderingFiber.alternate;
    if (current !== null) {
      nextCurrentHook = current.memoizedState;
    } else {
      nextCurrentHook = null;
    }
  } else {
    nextCurrentHook = currentHook.next;
  }

  let nextWorkInProgressHook;
  if (workInProgressHook <span class="hljs-comment">=== null) {</span>
    nextWorkInProgressHook = currentlyRenderingFiber.memoizedState;
  } else {
    nextWorkInProgressHook = workInProgressHook.next;
  }

  if (nextWorkInProgressHook !== null) {
    workInProgressHook = nextWorkInProgressHook;
    nextWorkInProgressHook = workInProgressHook.next;
    currentHook = nextCurrentHook;
  } else {
    currentHook = nextCurrentHook;
    const newHook = {
      memoizedState: currentHook.memoizedState,
      queue: currentHook.queue,
      next: null,
<span class="hljs-addition">+     baseState: currentHook.baseState,</span>
<span class="hljs-addition">+     baseQueue: currentHook.baseQueue,</span>
    };
    if (workInProgressHook <span class="hljs-comment">=== null) {</span>
      currentlyRenderingFiber.memoizedState = workInProgressHook = newHook;
    } else {
      workInProgressHook = workInProgressHook.next = newHook;
    }
  }
  return workInProgressHook;
}

export function renderWithHooks(current, workInProgress, Component, props, nextRenderLanes) {
<span class="hljs-addition">+ renderLanes = nextRenderLanes;</span>
  currentlyRenderingFiber = workInProgress;
  workInProgress.updateQueue = null;
<span class="hljs-addition">+ workInProgress.memoizedState = null;</span>
  if (current !== null &amp;&amp; current.memoizedState !== null) {
    ReactCurrentDispatcher.current = HooksDispatcherOnUpdateInDEV;
  } else {
    ReactCurrentDispatcher.current = HooksDispatcherOnMountInDEV;
  }
  const children = Component(props);
  currentlyRenderingFiber = null;
  workInProgressHook = null;
  currentHook = null;
<span class="hljs-addition">+ renderLanes = NoLanes;</span>
  return children;
}

<span class="hljs-addition">+function printQueue(queue) {</span>
<span class="hljs-addition">+  const first = queue.next;</span>
<span class="hljs-addition">+  let desc = &apos;&apos;;</span>
<span class="hljs-addition">+  let update = first;</span>
<span class="hljs-addition">+  do {</span>
<span class="hljs-addition">+    desc += (&quot;=&gt;&quot; + (update.action.id));</span>
<span class="hljs-addition">+    update = update.next;</span>
<span class="hljs-addition">+  } while (update !== null &amp;&amp; update !== first);</span>
<span class="hljs-addition">+  desc += &quot;=&gt;null&quot;;</span>
<span class="hljs-addition">+  console.log(desc);</span>
<span class="hljs-addition">+}</span>
</code></pre>
<h3 id="t31041.11 ReactFiberReconciler.js">41.11 ReactFiberReconciler.js <a href="#t31041.11 ReactFiberReconciler.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberReconciler.js</p>
<pre><code class="lang-diff">import { createFiberRoot } from &quot;./ReactFiberRoot&quot;;
import { createUpdate, enqueueUpdate } from &quot;./ReactFiberClassUpdateQueue&quot;;
<span class="hljs-addition">+import { scheduleUpdateOnFiber, requestUpdateLane, requestEventTime } from &quot;./ReactFiberWorkLoop&quot;;</span>
export function createContainer(containerInfo) {
  return createFiberRoot(containerInfo);
}
export function updateContainer(element, container) {
  const current = container.current;
<span class="hljs-addition">+ const eventTime = requestEventTime();</span>
  const lane = requestUpdateLane(current);
  const update = createUpdate(lane);
  update.payload = { element };
  const root = enqueueUpdate(current, update, lane);
<span class="hljs-addition">+ scheduleUpdateOnFiber(root, current, lane, eventTime);</span>
}
</code></pre>
<h3 id="t31141.12 ReactFiberRoot.js">41.12 ReactFiberRoot.js <a href="#t31141.12 ReactFiberRoot.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberRoot.js</p>
<pre><code class="lang-diff">import { createHostRootFiber } from &quot;./ReactFiber&quot;;
import { initializeUpdateQueue } from &quot;./ReactFiberClassUpdateQueue&quot;;
<span class="hljs-addition">+import { NoTimestamp, createLaneMap, NoLanes } from &apos;react-reconciler/src/ReactFiberLane&apos;;</span>

function FiberRootNode(containerInfo) {
  this.containerInfo = containerInfo;
<span class="hljs-addition">+ this.expirationTimes = createLaneMap(NoTimestamp);</span>
<span class="hljs-addition">+ this.expiredLanes = NoLanes;</span>
}

export function createFiberRoot(containerInfo) {
  const root = new FiberRootNode(containerInfo);
  const uninitializedFiber = createHostRootFiber();
  root.current = uninitializedFiber;
  uninitializedFiber.stateNode = root;
  initializeUpdateQueue(uninitializedFiber);
  return root;
}
</code></pre>
<h2 id="t31242.context">42.context <a href="#t31242.context"> # </a></h2>
<h3 id="t31342.1 src\main.jsx">42.1 src\main.jsx <a href="#t31342.1 src\main.jsx"> # </a></h3>
<p>src\main.jsx</p>
<pre><code class="lang-diff">import * as React from &quot;react&quot;;
import { createRoot } from &quot;react-dom/client&quot;;

<span class="hljs-addition">+const NameContext = React.createContext(&apos;&apos;);</span>
<span class="hljs-addition">+const AgeContext = React.createContext(&apos;&apos;);</span>
<span class="hljs-addition">+</span>
<span class="hljs-addition">+function Child() {</span>
<span class="hljs-addition">+  const name = React.useContext(NameContext);</span>
<span class="hljs-addition">+  const age = React.useContext(AgeContext);</span>
<span class="hljs-addition">+  return &lt;button&gt;{name + age}&lt;/button&gt;</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+function App() {</span>
<span class="hljs-addition">+  const [name, setName] = React.useState(&apos;a&apos;);</span>
<span class="hljs-addition">+  const [age, setAge] = React.useState(&apos;1&apos;);</span>
<span class="hljs-addition">+  return (</span>
<span class="hljs-addition">+    &lt;div&gt;</span>
<span class="hljs-addition">+      &lt;button onClick={() =&gt; {</span>
<span class="hljs-addition">+        setName(name + &apos;a&apos;)</span>
<span class="hljs-addition">+      }}&gt;setName&lt;/button&gt;</span>
<span class="hljs-addition">+      &lt;button onClick={() =&gt; {</span>
<span class="hljs-addition">+        setAge(age + &apos;1&apos;)</span>
<span class="hljs-addition">+      }}&gt;setAge&lt;/button&gt;</span>
<span class="hljs-addition">+      &lt;NameContext.Provider value={name}&gt;</span>
<span class="hljs-addition">+        &lt;AgeContext.Provider value={age}&gt;</span>
<span class="hljs-addition">+          &lt;Child /&gt;</span>
<span class="hljs-addition">+        &lt;/AgeContext.Provider&gt;</span>
<span class="hljs-addition">+      &lt;/NameContext.Provider&gt;</span>
<span class="hljs-addition">+    &lt;/div&gt;</span>
<span class="hljs-addition">+  )</span>
<span class="hljs-addition">+}</span>

const element = &lt;App /&gt;;
const container = document.getElementById(&quot;root&quot;);
const root = createRoot(container, { unstable_concurrentUpdatesByDefault: true });
root.render(element);
</code></pre>
<h3 id="t31442.2  react\index.js">42.2  react\index.js <a href="#t31442.2  react\index.js"> # </a></h3>
<p>src\react\index.js</p>
<pre><code class="lang-diff">export {
  __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
  useReducer,
  useState,
  useEffect,
  useLayoutEffect,
  useRef,
<span class="hljs-addition">+ createContext,</span>
<span class="hljs-addition">+ useContext,</span>
} from &quot;./src/React&quot;;
</code></pre>
<h3 id="t31542.3 React.js">42.3 React.js <a href="#t31542.3 React.js"> # </a></h3>
<p>src\react\src\React.js</p>
<pre><code class="lang-diff"><span class="hljs-addition">+import { useReducer, useState, useEffect, useLayoutEffect, useRef, useContext } from &quot;./ReactHooks&quot;;</span>
import ReactSharedInternals from &quot;./ReactSharedInternals&quot;;
<span class="hljs-addition">+import { createContext } from &apos;./ReactContext&apos;;</span>

export {
  useReducer,
  useState,
  useEffect,
  useLayoutEffect,
  useRef,
<span class="hljs-addition">+ createContext,</span>
<span class="hljs-addition">+ useContext,</span>
  ReactSharedInternals as __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
};
</code></pre>
<h3 id="t31642.4 ReactContext.js">42.4 ReactContext.js <a href="#t31642.4 ReactContext.js"> # </a></h3>
<p>src\react\src\ReactContext.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">import</span> { REACT_PROVIDER_TYPE, REACT_CONTEXT_TYPE } <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;shared/ReactSymbols&apos;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createContext</span>(<span class="hljs-params">defaultValue</span>) </span>{
  <span class="hljs-keyword">const</span> context = {
    <span class="hljs-attr">$$typeof</span>: REACT_CONTEXT_TYPE,
    <span class="hljs-attr">_currentValue</span>: defaultValue,
    <span class="hljs-attr">Provider</span>: <span class="hljs-literal">null</span>
  };
  context.Provider = {
    <span class="hljs-attr">$$typeof</span>: REACT_PROVIDER_TYPE,
    <span class="hljs-attr">_context</span>: context
  };
  <span class="hljs-keyword">return</span> context;
}
</code></pre>
<h3 id="t31742.5 ReactHooks.js">42.5 ReactHooks.js <a href="#t31742.5 ReactHooks.js"> # </a></h3>
<p>src\react\src\ReactHooks.js</p>
<pre><code class="lang-diff">import ReactCurrentDispatcher from &quot;./ReactCurrentDispatcher&quot;;

function resolveDispatcher() {
  const dispatcher = ReactCurrentDispatcher.current;
  return dispatcher;
}

export function useReducer(reducer, initialArg, init) {
  const dispatcher = resolveDispatcher();
  return dispatcher.useReducer(reducer, initialArg, init);
}

export function useState(initialState) {
  const dispatcher = resolveDispatcher();
  return dispatcher.useState(initialState);
}

export function useEffect(create, deps) {
  const dispatcher = resolveDispatcher();
  return dispatcher.useEffect(create, deps);
}
export function useLayoutEffect(create, deps) {
  const dispatcher = resolveDispatcher();
  return dispatcher.useLayoutEffect(create, deps);
}
export function useRef(initialValue) {
  const dispatcher = resolveDispatcher();
  return dispatcher.useRef(initialValue);
}
<span class="hljs-addition">+export function useContext(Context) {</span>
<span class="hljs-addition">+  const dispatcher = resolveDispatcher();</span>
<span class="hljs-addition">+  return dispatcher.useContext(Context);</span>
<span class="hljs-addition">+}</span>
</code></pre>
<h3 id="t31842.6 ReactFiber.js">42.6 ReactFiber.js <a href="#t31842.6 ReactFiber.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiber.js</p>
<pre><code class="lang-diff"><span class="hljs-addition">+import { HostRoot, IndeterminateComponent, HostComponent, HostText, ContextProvider } from &quot;./ReactWorkTags&quot;;</span>
import { NoFlags } from &quot;./ReactFiberFlags&quot;;
import { NoLanes } from &apos;./ReactFiberLane&apos;;
<span class="hljs-addition">+import { REACT_PROVIDER_TYPE } from &apos;shared/ReactSymbols&apos;;</span>

export function FiberNode(tag, pendingProps, key) {
  this.tag = tag;
  this.key = key;
  this.type = null;
  this.stateNode = null;

  this.return = null;
  this.child = null;
  this.sibling = null;

  this.pendingProps = pendingProps;
  this.memoizedProps = null;
  this.updateQueue = null;
  this.memoizedState = null;

  this.flags = NoFlags;
  this.subtreeFlags = NoFlags;
  this.deletions = null;
  this.alternate = null;

  this.index = 0;
  this.ref = null;
  this.lanes = NoLanes;
  this.childLanes = NoLanes;
}
function createFiber(tag, pendingProps, key) {
  return new FiberNode(tag, pendingProps, key);
}
export function createHostRootFiber() {
  return createFiber(HostRoot, null, null);
}
// We use a double buffering pooling technique because we know that we&apos;ll
// only ever need at most two versions of a tree. We pool the &quot;other&quot; unused
// node that we&apos;re free to reuse. This is lazily created to avoid allocating
// extra objects for things that are never updated. It also allow us to
// reclaim the extra memory if needed.
//&#x6211;&#x4EEC;&#x4F7F;&#x7528;&#x53CC;&#x7F13;&#x51B2;&#x6C60;&#x6280;&#x672F;&#xFF0C;&#x56E0;&#x4E3A;&#x6211;&#x4EEC;&#x77E5;&#x9053;&#x4E00;&#x68F5;&#x6811;&#x6700;&#x591A;&#x53EA;&#x9700;&#x8981;&#x4E24;&#x4E2A;&#x7248;&#x672C;
//&#x6211;&#x4EEC;&#x5C06;&#x201C;&#x5176;&#x4ED6;&#x201D;&#x672A;&#x4F7F;&#x7528;&#x7684;&#x6211;&#x4EEC;&#x53EF;&#x4EE5;&#x81EA;&#x7531;&#x91CD;&#x7528;&#x7684;&#x8282;&#x70B9;
//&#x8FD9;&#x662F;&#x5EF6;&#x8FDF;&#x521B;&#x5EFA;&#x7684;&#xFF0C;&#x4EE5;&#x907F;&#x514D;&#x5206;&#x914D;&#x4ECE;&#x672A;&#x66F4;&#x65B0;&#x7684;&#x5185;&#x5BB9;&#x7684;&#x989D;&#x5916;&#x5BF9;&#x8C61;&#x3002;&#x5B83;&#x8FD8;&#x5141;&#x8BB8;&#x6211;&#x4EEC;&#x5982;&#x679C;&#x9700;&#x8981;&#xFF0C;&#x56DE;&#x6536;&#x989D;&#x5916;&#x7684;&#x5185;&#x5B58;
export function createWorkInProgress(current, pendingProps) {
  let workInProgress = current.alternate;
  if (workInProgress <span class="hljs-comment">=== null) {</span>
    workInProgress = createFiber(current.tag, pendingProps, current.key);
    workInProgress.type = current.type;
    workInProgress.stateNode = current.stateNode;
    workInProgress.alternate = current;
    current.alternate = workInProgress;
  } else {
    workInProgress.pendingProps = pendingProps;
    workInProgress.type = current.type;
    workInProgress.flags = NoFlags;
    workInProgress.subtreeFlags = NoFlags;
    workInProgress.deletions = null;
  }
  workInProgress.child = current.child;
  workInProgress.memoizedProps = current.memoizedProps;
  workInProgress.memoizedState = current.memoizedState;
  workInProgress.updateQueue = current.updateQueue;
  workInProgress.sibling = current.sibling;
  workInProgress.index = current.index;
  workInProgress.ref = current.ref;
  workInProgress.flags = current.flags;
  workInProgress.childLanes = current.childLanes;
  workInProgress.lanes = current.lanes;
  return workInProgress;
}
export function createFiberFromTypeAndProps(type, key, pendingProps) {
  let fiberTag = IndeterminateComponent;
  if (typeof type <span class="hljs-comment">=== &quot;string&quot;) {</span>
    fiberTag = HostComponent;
  } else {
<span class="hljs-addition">+   getTag: switch (type) {</span>
<span class="hljs-addition">+     default:</span>
<span class="hljs-addition">+       {</span>
<span class="hljs-addition">+         if (typeof type === &apos;object&apos; &amp;&amp; type !== null) {</span>
<span class="hljs-addition">+           switch (type.$$typeof) {</span>
<span class="hljs-addition">+             case REACT_PROVIDER_TYPE:</span>
<span class="hljs-addition">+               fiberTag = ContextProvider;</span>
<span class="hljs-addition">+               break getTag;</span>
<span class="hljs-addition">+             default:</span>
<span class="hljs-addition">+               break;</span>
<span class="hljs-addition">+           }</span>
<span class="hljs-addition">+         }</span>
<span class="hljs-addition">+       }</span>
<span class="hljs-addition">+   }</span>
  }
  const fiber = createFiber(fiberTag, pendingProps, key);
  fiber.type = type;
  return fiber;
}
export function createFiberFromElement(element) {
  const { type } = element;
  const { key } = element;
  const pendingProps = element.props;
  const fiber = createFiberFromTypeAndProps(type, key, pendingProps);
  return fiber;
}

export function createFiberFromText(content) {
  const fiber = createFiber(HostText, content, null);
  return fiber;
}
</code></pre>
<h3 id="t31942.7 ReactFiberBeginWork.js">42.7 ReactFiberBeginWork.js <a href="#t31942.7 ReactFiberBeginWork.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberBeginWork.js</p>
<pre><code class="lang-diff">import {
  HostRoot, HostComponent, HostText, IndeterminateComponent,
<span class="hljs-addition">+ FunctionComponent, ContextProvider</span>
} from &quot;./ReactWorkTags&quot;;
import { processUpdateQueue, cloneUpdateQueue } from &quot;./ReactFiberClassUpdateQueue&quot;;
import { mountChildFibers, reconcileChildFibers } from &quot;./ReactChildFiber&quot;;
import { shouldSetTextContent } from &quot;react-dom-bindings/src/client/ReactDOMHostConfig&quot;;
import { renderWithHooks } from &quot;react-reconciler/src/ReactFiberHooks&quot;;
import { NoLanes } from &apos;./ReactFiberLane&apos;;
<span class="hljs-addition">+import { pushProvider } from &apos;./ReactFiberNewContext&apos;;</span>

function reconcileChildren(current, workInProgress, nextChildren) {
  if (current <span class="hljs-comment">=== null) {</span>
    workInProgress.child = mountChildFibers(workInProgress, null, nextChildren);
  } else {
    workInProgress.child = reconcileChildFibers(workInProgress, current.child, nextChildren);
  }
}
function updateHostRoot(current, workInProgress, renderLanes) {
  const nextProps = workInProgress.pendingProps;
  cloneUpdateQueue(current, workInProgress);
  processUpdateQueue(workInProgress, nextProps, renderLanes)
  const nextState = workInProgress.memoizedState;
  const nextChildren = nextState.element;
  reconcileChildren(current, workInProgress, nextChildren);
  return workInProgress.child;
}
function updateHostComponent(current, workInProgress) {
  const { type } = workInProgress;
  const nextProps = workInProgress.pendingProps;
  let nextChildren = nextProps.children;
  const isDirectTextChild = shouldSetTextContent(type, nextProps);
  if (isDirectTextChild) {
    nextChildren = null;
  }
  reconcileChildren(current, workInProgress, nextChildren);
  return workInProgress.child;
}
function mountIndeterminateComponent(_current, workInProgress, Component) {
  const props = workInProgress.pendingProps;
  const value = renderWithHooks(null, workInProgress, Component, props);
  workInProgress.tag = FunctionComponent;
  reconcileChildren(null, workInProgress, value);
  return workInProgress.child;
}
function updateFunctionComponent(current, workInProgress, Component, nextProps, renderLanes) {
  const nextChildren = renderWithHooks(current, workInProgress, Component, nextProps, renderLanes);
  reconcileChildren(current, workInProgress, nextChildren);
  return workInProgress.child;
}
export function beginWork(current, workInProgress, renderLanes) {
  workInProgress.lanes = NoLanes;
  switch (workInProgress.tag) {
    case IndeterminateComponent: {
      return mountIndeterminateComponent(current, workInProgress, workInProgress.type, renderLanes);
    }
    case FunctionComponent: {
      const Component = workInProgress.type;
      const resolvedProps = workInProgress.pendingProps;
      return updateFunctionComponent(current, workInProgress, Component, resolvedProps, renderLanes);
    }
    case HostRoot:
      return updateHostRoot(current, workInProgress, renderLanes);
    case HostComponent:
      return updateHostComponent(current, workInProgress, renderLanes);
    case HostText:
      return null;
<span class="hljs-addition">+   case ContextProvider:</span>
<span class="hljs-addition">+     return updateContextProvider(current, workInProgress, renderLanes);</span>
    default:
      return null;
  }
}

<span class="hljs-addition">+function updateContextProvider(current, workInProgress, renderLanes) {</span>
<span class="hljs-addition">+  const providerType = workInProgress.type;</span>
<span class="hljs-addition">+  const context = providerType._context;</span>
<span class="hljs-addition">+  const newProps = workInProgress.pendingProps;</span>
<span class="hljs-addition">+  const newValue = newProps.value;</span>
<span class="hljs-addition">+  pushProvider(context, newValue);</span>
<span class="hljs-addition">+  const newChildren = newProps.children;</span>
<span class="hljs-addition">+  reconcileChildren(current, workInProgress, newChildren, renderLanes);</span>
<span class="hljs-addition">+  return workInProgress.child;</span>
<span class="hljs-addition">+}</span>

</code></pre>
<h3 id="t32042.8 ReactFiberCompleteWork.js">42.8 ReactFiberCompleteWork.js <a href="#t32042.8 ReactFiberCompleteWork.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberCompleteWork.js</p>
<pre><code class="lang-diff">import {
  appendInitialChild,
  createInstance,
  createTextInstance,
  finalizeInitialChildren,
  prepareUpdate,
} from &quot;react-dom-bindings/src/client/ReactDOMHostConfig&quot;;
<span class="hljs-addition">+import { HostComponent, HostRoot, HostText, FunctionComponent, ContextProvider } from &quot;./ReactWorkTags&quot;;</span>
import { Ref, NoFlags, Update } from &quot;./ReactFiberFlags&quot;;
import { NoLanes, mergeLanes } from &apos;./ReactFiberLane&apos;;

function markRef(workInProgress) {
  workInProgress.flags |= Ref;
}

function bubbleProperties(completedWork) {
  let newChildLanes = NoLanes;
  let subtreeFlags = NoFlags;
  let child = completedWork.child;
  while (child !== null) {
    newChildLanes = mergeLanes(newChildLanes, mergeLanes(child.lanes, child.childLanes));
    subtreeFlags |= child.subtreeFlags;
    subtreeFlags |= child.flags;
    child = child.sibling;
  }
  completedWork.childLanes = newChildLanes;
  completedWork.subtreeFlags |= subtreeFlags;
}

function appendAllChildren(parent, workInProgress) {
  // &#x6211;&#x4EEC;&#x53EA;&#x6709;&#x521B;&#x5EFA;&#x7684;&#x9876;&#x7EA7;fiber&#xFF0C;&#x4F46;&#x9700;&#x8981;&#x9012;&#x5F52;&#x5176;&#x5B50;&#x8282;&#x70B9;&#x6765;&#x67E5;&#x627E;&#x6240;&#x6709;&#x7EC8;&#x7AEF;&#x8282;&#x70B9;
  let node = workInProgress.child;
  while (node !== null) {
    // &#x5982;&#x679C;&#x662F;&#x539F;&#x751F;&#x8282;&#x70B9;&#xFF0C;&#x76F4;&#x63A5;&#x6DFB;&#x52A0;&#x5230;&#x7236;&#x8282;&#x70B9;&#x4E0A;
    if (node.tag <span class="hljs-comment">=== HostComponent || node.tag === HostText) {</span>
      appendInitialChild(parent, node.stateNode);
      // &#x518D;&#x770B;&#x770B;&#x7B2C;&#x4E00;&#x4E2A;&#x8282;&#x8282;&#x70B9;&#x662F;&#x4E0D;&#x662F;&#x539F;&#x751F;&#x8282;&#x70B9;
    } else if (node.child !== null) {
      // node.child.return = node
      node = node.child;
      continue;
    }
    if (node <span class="hljs-comment">=== workInProgress) {</span>
      return;
    }
    // &#x5982;&#x679C;&#x6CA1;&#x6709;&#x5F1F;&#x5F1F;&#x5C31;&#x627E;&#x7236;&#x4EB2;&#x7684;&#x5F1F;&#x5F1F;
    while (node.sibling <span class="hljs-comment">=== null) {</span>
      // &#x5982;&#x679C;&#x627E;&#x5230;&#x4E86;&#x6839;&#x8282;&#x70B9;&#x6216;&#x8005;&#x56DE;&#x5230;&#x4E86;&#x539F;&#x8282;&#x70B9;&#x7ED3;&#x675F;
      if (node.return <span class="hljs-comment">=== null || node.return === workInProgress) {</span>
        return;
      }
      node = node.return;
    }
    // node.sibling.return = node.return
    // &#x4E0B;&#x4E00;&#x4E2A;&#x5F1F;&#x5F1F;&#x8282;&#x70B9;
    node = node.sibling;
  }
}
function markUpdate(workInProgress) {
  workInProgress.flags |= Update;
}
function updateHostComponent(current, workInProgress, type, newProps) {
  const oldProps = current.memoizedProps;
  const instance = workInProgress.stateNode;
  const updatePayload = prepareUpdate(instance, type, oldProps, newProps);
  workInProgress.updateQueue = updatePayload;
  if (updatePayload) {
    markUpdate(workInProgress);
  }
}
export function completeWork(current, workInProgress) {
  const newProps = workInProgress.pendingProps;
  switch (workInProgress.tag) {
    case HostComponent: {
      const { type } = workInProgress;
      if (current !== null &amp;&amp; workInProgress.stateNode != null) {
        updateHostComponent(current, workInProgress, type, newProps);
        if (current.ref !== workInProgress.ref) {
          markRef(workInProgress);
        }
      } else {
        const instance = createInstance(type, newProps, workInProgress);
        appendAllChildren(instance, workInProgress);
        workInProgress.stateNode = instance;
        finalizeInitialChildren(instance, type, newProps);
        if (workInProgress.ref !== null) {
          markRef(workInProgress);
        }
      }
      bubbleProperties(workInProgress);
      return null;
    }
    case FunctionComponent:
      bubbleProperties(workInProgress);
      break;
    case HostRoot:
      bubbleProperties(workInProgress);
      break;
    case HostText: {
      const newText = newProps;
      workInProgress.stateNode = createTextInstance(newText);
      bubbleProperties(workInProgress);
      break;
    }
<span class="hljs-addition">+   case ContextProvider: {</span>
<span class="hljs-addition">+     bubbleProperties(workInProgress);</span>
<span class="hljs-addition">+     break;</span>
<span class="hljs-addition">+   }</span>
    default:
      break;
  }
}
</code></pre>
<h3 id="t32142.9 ReactFiberCommitWork.js">42.9 ReactFiberCommitWork.js <a href="#t32142.9 ReactFiberCommitWork.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberCommitWork.js</p>
<pre><code class="lang-diff"><span class="hljs-addition">+import { HostRoot, HostComponent, HostText, FunctionComponent, ContextProvider } from &quot;./ReactWorkTags&quot;;</span>
import { Passive, MutationMask, Placement, Update, LayoutMask, Ref } from &quot;./ReactFiberFlags&quot;;
import { insertBefore, appendChild, commitUpdate, removeChild } from &quot;react-dom-bindings/src/client/ReactDOMHostConfig&quot;;
import { HasEffect as HookHasEffect, Passive as HookPassive, Layout as HookLayout } from &quot;./ReactHookEffectTags&quot;;

export function commitMutationEffects(finishedWork, root) {
  commitMutationEffectsOnFiber(finishedWork, root);
}
export function commitPassiveUnmountEffects(finishedWork) {
  commitPassiveUnmountOnFiber(finishedWork);
}
function commitPassiveUnmountOnFiber(finishedWork) {
  switch (finishedWork.tag) {
    case FunctionComponent: {
      recursivelyTraversePassiveUnmountEffects(finishedWork);
      if (finishedWork.flags &amp; Passive) {
        commitHookPassiveUnmountEffects(finishedWork, finishedWork.return, HookPassive | HookHasEffect);
      }
      break;
    }
    default: {
      recursivelyTraversePassiveUnmountEffects(finishedWork);
      break;
    }
  }
}
function recursivelyTraversePassiveUnmountEffects(parentFiber) {
  if (parentFiber.subtreeFlags &amp; Passive) {
    let child = parentFiber.child;
    while (child !== null) {
      commitPassiveUnmountOnFiber(child);
      child = child.sibling;
    }
  }
}
function commitHookPassiveUnmountEffects(finishedWork, nearestMountedAncestor, hookFlags) {
  commitHookEffectListUnmount(hookFlags, finishedWork, nearestMountedAncestor);
}

function commitHookEffectListUnmount(flags, finishedWork) {
  const updateQueue = finishedWork.updateQueue;
  const lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;
  if (lastEffect !== null) {
    const firstEffect = lastEffect.next;
    let effect = firstEffect;
    do {
      if ((effect.tag &amp; flags) <span class="hljs-comment">=== flags) {</span>
        const destroy = effect.destroy;
        effect.destroy = undefined;
        if (destroy !== undefined) {
          destroy();
        }
      }
      effect = effect.next;
    } while (effect !== firstEffect);
  }
}

export function commitPassiveMountEffects(root, finishedWork) {
  commitPassiveMountOnFiber(root, finishedWork);
}
function commitPassiveMountOnFiber(finishedRoot, finishedWork) {
  const flags = finishedWork.flags;
  switch (finishedWork.tag) {
    case FunctionComponent: {
      recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork);
      if (flags &amp; Passive) {
        commitHookPassiveMountEffects(finishedWork, HookPassive | HookHasEffect);
      }
      break;
    }
    case HostRoot: {
      recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork);
      break;
    }
    default:
      break;
  }
}
function commitHookPassiveMountEffects(finishedWork, hookFlags) {
  commitHookEffectListMount(hookFlags, finishedWork);
}
function commitHookEffectListMount(flags, finishedWork) {
  const updateQueue = finishedWork.updateQueue;
  const lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;
  if (lastEffect !== null) {
    const firstEffect = lastEffect.next;
    let effect = firstEffect;
    do {
      if ((effect.tag &amp; flags) <span class="hljs-comment">=== flags) {</span>
        const create = effect.create;
        effect.destroy = create();
      }
      effect = effect.next;
    } while (effect !== firstEffect);
  }
}
function recursivelyTraversePassiveMountEffects(root, parentFiber) {
  if (parentFiber.subtreeFlags &amp; Passive) {
    let child = parentFiber.child;
    while (child !== null) {
      commitPassiveMountOnFiber(root, child);
      child = child.sibling;
    }
  }
}
let hostParent = null;
function commitDeletionEffects(root, returnFiber, deletedFiber) {
  let parent = returnFiber;
  findParent: while (parent !== null) {
    switch (parent.tag) {
      case HostComponent: {
        hostParent = parent.stateNode;
        break findParent;
      }
      case HostRoot: {
        hostParent = parent.stateNode.containerInfo;
        break findParent;
      }
      default:
        break;
    }
    parent = parent.return;
  }
  commitDeletionEffectsOnFiber(root, returnFiber, deletedFiber);
  hostParent = null;
}
function commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, deletedFiber) {
  switch (deletedFiber.tag) {
    case HostComponent:
    case HostText: {
      recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
      if (hostParent !== null) {
        removeChild(hostParent, deletedFiber.stateNode);
      }
      break;
    }
    default:
      break;
  }
}
function recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, parent) {
  let child = parent.child;
  while (child !== null) {
    commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, child);
    child = child.sibling;
  }
}
function recursivelyTraverseMutationEffects(root, parentFiber) {
  const deletions = parentFiber.deletions;
  if (deletions !== null) {
    for (let i = 0; i &lt; deletions.length; i++) {
      const childToDelete = deletions[i];
      commitDeletionEffects(root, parentFiber, childToDelete);
    }
  }
  if (parentFiber.subtreeFlags &amp; MutationMask) {
    let { child } = parentFiber;
    while (child !== null) {
      commitMutationEffectsOnFiber(child, root);
      child = child.sibling;
    }
  }
}
function isHostParent(fiber) {
  return fiber.tag <span class="hljs-comment">=== HostComponent || fiber.tag === HostRoot;</span>
}
function getHostParentFiber(fiber) {
  let parent = fiber.return;
  while (parent !== null) {
    if (isHostParent(parent)) {
      return parent;
    }
    parent = parent.return;
  }
  return parent;
}
function insertOrAppendPlacementNode(node, before, parent) {
  const { tag } = node;
  const isHost = tag <span class="hljs-comment">=== HostComponent || tag === HostText;</span>
  if (isHost) {
    const { stateNode } = node;
    if (before) {
      insertBefore(parent, stateNode, before);
    } else {
      appendChild(parent, stateNode);
    }
  } else {
    const { child } = node;
    if (child !== null) {
      insertOrAppendPlacementNode(child, before, parent);
      let { sibling } = child;
      while (sibling !== null) {
        insertOrAppendPlacementNode(sibling, before, parent);
        sibling = sibling.sibling;
      }
    }
  }
}
function getHostSibling(fiber) {
  let node = fiber;
  siblings: while (true) {
    // &#x5982;&#x679C;&#x6211;&#x4EEC;&#x6CA1;&#x6709;&#x627E;&#x5230;&#x4EFB;&#x4F55;&#x4E1C;&#x897F;&#xFF0C;&#x8BA9;&#x6211;&#x4EEC;&#x8BD5;&#x8BD5;&#x4E0B;&#x4E00;&#x4E2A;&#x5F1F;&#x5F1F;
    while (node.sibling <span class="hljs-comment">=== null) {</span>
      if (node.return <span class="hljs-comment">=== null || isHostParent(node.return)) {</span>
        // &#x5982;&#x679C;&#x6211;&#x4EEC;&#x662F;&#x6839;Fiber&#x6216;&#x8005;&#x7236;&#x4EB2;&#x662F;&#x539F;&#x751F;&#x8282;&#x70B9;&#xFF0C;&#x6211;&#x4EEC;&#x5C31;&#x662F;&#x6700;&#x540E;&#x7684;&#x5F1F;&#x5F1F;
        return null;
      }
      node = node.return;
    }
    // node.sibling.return = node.return
    node = node.sibling;
    while (node.tag !== HostComponent &amp;&amp; node.tag !== HostText) {
      // &#x5982;&#x679C;&#x5B83;&#x4E0D;&#x662F;&#x539F;&#x751F;&#x8282;&#x70B9;&#xFF0C;&#x5E76;&#x4E14;&#xFF0C;&#x6211;&#x4EEC;&#x53EF;&#x80FD;&#x5728;&#x5176;&#x4E2D;&#x6709;&#x4E00;&#x4E2A;&#x539F;&#x751F;&#x8282;&#x70B9;
      // &#x8BD5;&#x7740;&#x5411;&#x4E0B;&#x641C;&#x7D22;&#xFF0C;&#x76F4;&#x5230;&#x627E;&#x5230;&#x4E3A;&#x6B62;
      if (node.flags &amp; Placement) {
        // &#x5982;&#x679C;&#x6211;&#x4EEC;&#x6CA1;&#x6709;&#x5B69;&#x5B50;&#xFF0C;&#x53EF;&#x4EE5;&#x8BD5;&#x8BD5;&#x5F1F;&#x5F1F;
        continue siblings;
      } else {
        // node.child.return = node
        node = node.child;
      }
    } // Check if this host node is stable or about to be placed.
    // &#x68C0;&#x67E5;&#x6B64;&#x539F;&#x751F;&#x8282;&#x70B9;&#x662F;&#x5426;&#x7A33;&#x5B9A;&#x53EF;&#x4EE5;&#x653E;&#x7F6E;
    if (!(node.flags &amp; Placement)) {
      // &#x627E;&#x5230;&#x5B83;&#x4E86;!
      return node.stateNode;
    }
  }
}
function commitPlacement(finishedWork) {
  const parentFiber = getHostParentFiber(finishedWork);
  switch (parentFiber.tag) {
    case HostComponent: {
      const parent = parentFiber.stateNode;
      const before = getHostSibling(finishedWork);
      insertOrAppendPlacementNode(finishedWork, before, parent);
      break;
    }
    case HostRoot: {
      const parent = parentFiber.stateNode.containerInfo;
      const before = getHostSibling(finishedWork);
      insertOrAppendPlacementNode(finishedWork, before, parent);
      break;
    }
    default:
      break;
  }
}
function commitReconciliationEffects(finishedWork) {
  const { flags } = finishedWork;
  if (flags &amp; Placement) {
    commitPlacement(finishedWork);
    finishedWork.flags &amp;= ~Placement;
  }
}
export function commitMutationEffectsOnFiber(finishedWork, root) {
  const current = finishedWork.alternate;
  const flags = finishedWork.flags;
  switch (finishedWork.tag) {
    case HostRoot: {
      recursivelyTraverseMutationEffects(root, finishedWork);
      commitReconciliationEffects(finishedWork);
      break;
    }
    case FunctionComponent: {
      recursivelyTraverseMutationEffects(root, finishedWork);
      commitReconciliationEffects(finishedWork);
      if (flags &amp; Update) {
        commitHookEffectListUnmount(HookLayout | HookHasEffect, finishedWork, finishedWork.return);
      }
      break;
    }
    case HostComponent: {
      recursivelyTraverseMutationEffects(root, finishedWork);
      commitReconciliationEffects(finishedWork);
      if (flags &amp; Ref) {
        commitAttachRef(finishedWork);
      }
      if (flags &amp; Update) {
        const instance = finishedWork.stateNode;
        if (instance != null) {
          const newProps = finishedWork.memoizedProps;
          const oldProps = current !== null ? current.memoizedProps : newProps;
          const type = finishedWork.type;
          const updatePayload = finishedWork.updateQueue;
          finishedWork.updateQueue = null;
          if (updatePayload !== null) {
            commitUpdate(instance, updatePayload, type, oldProps, newProps, finishedWork);
          }
        }
      }

      break;
    }
    case HostText: {
      recursivelyTraverseMutationEffects(root, finishedWork);
      commitReconciliationEffects(finishedWork);
      break;
    }
<span class="hljs-addition">+   case ContextProvider: {</span>
<span class="hljs-addition">+     recursivelyTraverseMutationEffects(root, finishedWork);</span>
<span class="hljs-addition">+     commitReconciliationEffects(finishedWork);</span>
<span class="hljs-addition">+     break;</span>
    }
    default: {
      break;
    }
  }
}
function commitAttachRef(finishedWork) {
  const ref = finishedWork.ref;
  if (ref !== null) {
    const instance = finishedWork.stateNode;
    if (typeof ref <span class="hljs-comment">=== &quot;function&quot;) {</span>
      ref(instance)
    } else {
      ref.current = instance;
    }
  }
}
export function commitLayoutEffects(finishedWork, root) {
  const current = finishedWork.alternate;
  commitLayoutEffectOnFiber(root, current, finishedWork);
}
function commitLayoutEffectOnFiber(finishedRoot, current, finishedWork) {
  const flags = finishedWork.flags;
  switch (finishedWork.tag) {
    case FunctionComponent: {
      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
      if (flags &amp; Update) {
        commitHookLayoutEffects(finishedWork, HookLayout | HookHasEffect);
      }
      break;
    }
    case HostRoot: {
      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
      break;
    }
    default:
      break;
  }
}
function recursivelyTraverseLayoutEffects(root, parentFiber) {
  if (parentFiber.subtreeFlags &amp; LayoutMask) {
    let child = parentFiber.child;
    while (child !== null) {
      const current = child.alternate;
      commitLayoutEffectOnFiber(root, current, child);
      child = child.sibling;
    }
  }
}
function commitHookLayoutEffects(finishedWork, hookFlags) {
  commitHookEffectListMount(hookFlags, finishedWork);
}

</code></pre>
<h3 id="t32242.10 ReactFiberHooks.js">42.10 ReactFiberHooks.js <a href="#t32242.10 ReactFiberHooks.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberHooks.js</p>
<pre><code class="lang-diff">import ReactSharedInternals from &quot;shared/ReactSharedInternals&quot;;
import { enqueueConcurrentHookUpdate } from &quot;./ReactFiberConcurrentUpdates&quot;;
import { scheduleUpdateOnFiber, requestUpdateLane, requestEventTime } from &quot;./ReactFiberWorkLoop&quot;;
import is from &quot;shared/objectIs&quot;;
import { Passive as PassiveEffect, Update as UpdateEffect } from &quot;./ReactFiberFlags&quot;;
import { HasEffect as HookHasEffect, Passive as HookPassive, Layout as HookLayout } from &quot;./ReactHookEffectTags&quot;;
import { NoLanes, NoLane, mergeLanes, isSubsetOfLanes } from &apos;./ReactFiberLane&apos;;
<span class="hljs-addition">+import { readContext } from &apos;./ReactFiberNewContext&apos;;</span>

const { ReactCurrentDispatcher } = ReactSharedInternals;
let currentlyRenderingFiber = null;
let workInProgressHook = null;
let currentHook = null;
let renderLanes = NoLanes;

const HooksDispatcherOnMountInDEV = {
  useReducer: mountReducer,
  useState: mountState,
  useEffect: mountEffect,
  useLayoutEffect: mountLayoutEffect,
  useRef: mountRef,
<span class="hljs-addition">+ useContext: readContext</span>
};
const HooksDispatcherOnUpdateInDEV = {
  useReducer: updateReducer,
  useState: updateState,
  useEffect: updateEffect,
  useLayoutEffect: updateLayoutEffect,
  useRef: updateRef,
<span class="hljs-addition">+ useContext: readContext</span>
};
function mountRef(initialValue) {
  const hook = mountWorkInProgressHook();
  const ref = {
    current: initialValue,
  };
  hook.memoizedState = ref;
  return ref;
}
function updateRef() {
  const hook = updateWorkInProgressHook();
  return hook.memoizedState;
}
export function useLayoutEffect(reducer, initialArg) {
  return ReactCurrentDispatcher.current.useLayoutEffect(reducer, initialArg);
}
function updateLayoutEffect(create, deps) {
  return updateEffectImpl(UpdateEffect, HookLayout, create, deps);
}
function mountLayoutEffect(create, deps) {
  const fiberFlags = UpdateEffect;
  return mountEffectImpl(fiberFlags, HookLayout, create, deps);
}
function updateEffect(create, deps) {
  return updateEffectImpl(PassiveEffect, HookPassive, create, deps);
}
function updateEffectImpl(fiberFlags, hookFlags, create, deps) {
  const hook = updateWorkInProgressHook();
  const nextDeps = deps <span class="hljs-comment">=== undefined ? null : deps;</span>
  let destroy;
  if (currentHook !== null) {
    const prevEffect = currentHook.memoizedState;
    destroy = prevEffect.destroy;
    if (nextDeps !== null) {
      const prevDeps = prevEffect.deps;
      if (areHookInputsEqual(nextDeps, prevDeps)) {
        hook.memoizedState = pushEffect(hookFlags, create, destroy, nextDeps);
        return;
      }
    }
  }
  currentlyRenderingFiber.flags |= fiberFlags;
  hook.memoizedState = pushEffect(HookHasEffect | hookFlags, create, destroy, nextDeps);
}
function areHookInputsEqual(nextDeps, prevDeps) {
  if (prevDeps <span class="hljs-comment">=== null) {</span>
    return false;
  }
  for (let i = 0; i &lt; prevDeps.length &amp;&amp; i &lt; nextDeps.length; i++) {
    if (is(nextDeps[i], prevDeps[i])) {
      continue;
    }
    return false;
  }

  return true;
}
function mountEffect(create, deps) {
  return mountEffectImpl(PassiveEffect, HookPassive, create, deps);
}
function mountEffectImpl(fiberFlags, hookFlags, create, deps) {
  const hook = mountWorkInProgressHook();
  const nextDeps = deps <span class="hljs-comment">=== undefined ? null : deps;</span>
  currentlyRenderingFiber.flags |= fiberFlags;
  hook.memoizedState = pushEffect(HookHasEffect | hookFlags, create, undefined, nextDeps);
}
function pushEffect(tag, create, destroy, deps) {
  const effect = {
    tag,
    create,
    destroy,
    deps,
    next: null,
  };
  let componentUpdateQueue = currentlyRenderingFiber.updateQueue;
  if (componentUpdateQueue <span class="hljs-comment">=== null) {</span>
    componentUpdateQueue = createFunctionComponentUpdateQueue();
    currentlyRenderingFiber.updateQueue = componentUpdateQueue;
    componentUpdateQueue.lastEffect = effect.next = effect;
  } else {
    const lastEffect = componentUpdateQueue.lastEffect;
    if (lastEffect <span class="hljs-comment">=== null) {</span>
      componentUpdateQueue.lastEffect = effect.next = effect;
    } else {
      const firstEffect = lastEffect.next;
      lastEffect.next = effect;
      effect.next = firstEffect;
      componentUpdateQueue.lastEffect = effect;
    }
  }
  return effect;
}
function createFunctionComponentUpdateQueue() {
  return {
    lastEffect: null,
  };
}
function basicStateReducer(state, action) {
  return typeof action <span class="hljs-comment">=== &quot;function&quot; ? action(state) : action;</span>
}
function mountReducer(reducer, initialArg) {
  const hook = mountWorkInProgressHook();
  hook.memoizedState = initialArg;
  const queue = {
    pending: null,
    dispatch: null,
    lastRenderedReducer: reducer,
    lastRenderedState: initialArg
  };
  hook.queue = queue;
  const dispatch = (queue.dispatch = dispatchReducerAction.bind(null, currentlyRenderingFiber, queue));
  return [hook.memoizedState, dispatch];
}
function updateReducer(reducer) {
  const hook = updateWorkInProgressHook();
  const queue = hook.queue;
  queue.lastRenderedReducer = reducer;
  const current = currentHook;
  let baseQueue = current.baseQueue;
  const pendingQueue = queue.pending;
  if (pendingQueue !== null) {
    if (baseQueue !== null) {
      const baseFirst = baseQueue.next;
      const pendingFirst = pendingQueue.next;
      baseQueue.next = pendingFirst;
      pendingQueue.next = baseFirst;
    }
    current.baseQueue = baseQueue = pendingQueue;
    queue.pending = null;
  }
  if (baseQueue !== null) {
    printQueue(baseQueue)
    const first = baseQueue.next;
    let newState = current.baseState;
    let newBaseState = null;
    let newBaseQueueFirst = null;
    let newBaseQueueLast = null;
    let update = first;
    do {
      const updateLane = update.lane;
      const shouldSkipUpdate = !isSubsetOfLanes(renderLanes, updateLane);
      if (shouldSkipUpdate) {
        const clone = {
          lane: updateLane,
          action: update.action,
          hasEagerState: update.hasEagerState,
          eagerState: update.eagerState,
          next: null,
        };
        if (newBaseQueueLast <span class="hljs-comment">=== null) {</span>
          newBaseQueueFirst = newBaseQueueLast = clone;
          newBaseState = newState;
        } else {
          newBaseQueueLast = newBaseQueueLast.next = clone;
        }
        currentlyRenderingFiber.lanes = mergeLanes(currentlyRenderingFiber.lanes, updateLane);
      } else {
        if (newBaseQueueLast !== null) {
          const clone = {
            lane: NoLane,
            action: update.action,
            hasEagerState: update.hasEagerState,
            eagerState: update.eagerState,
            next: null,
          };
          newBaseQueueLast = newBaseQueueLast.next = clone;
        }
        if (update.hasEagerState) {
          newState = update.eagerState;
        } else {
          const action = update.action;
          newState = reducer(newState, action);
        }
      }
      update = update.next;
    } while (update !== null &amp;&amp; update !== first);
    if (newBaseQueueLast <span class="hljs-comment">=== null) {</span>
      newBaseState = newState;
    } else {
      newBaseQueueLast.next = newBaseQueueFirst;
    }
    hook.memoizedState = newState;
    hook.baseState = newBaseState;
    hook.baseQueue = newBaseQueueLast;
    queue.lastRenderedState = newState;
  }
  if (baseQueue <span class="hljs-comment">=== null) {</span>
    queue.lanes = NoLanes;
  }
  const dispatch = queue.dispatch;
  return [hook.memoizedState, dispatch];
}
function mountState(initialState) {
  const hook = mountWorkInProgressHook();
  hook.memoizedState = initialState;
  const queue = {
    pending: null,
    dispatch: null,
    lastRenderedReducer: basicStateReducer,
    lastRenderedState: initialState,
  };
  hook.queue = queue;
  const dispatch = (queue.dispatch = dispatchSetState.bind(null, currentlyRenderingFiber, queue));
  return [hook.memoizedState, dispatch];
}
function dispatchSetState(fiber, queue, action) {
  const lane = requestUpdateLane(fiber);
  const update = {
    lane,
    action,
    hasEagerState: false,
    eagerState: null,
    next: null,
  };
  const alternate = fiber.alternate;
  if (fiber.lanes <span class="hljs-comment">=== NoLanes &amp;&amp; (alternate === null || alternate.lanes === NoLanes)) {</span>
    const lastRenderedReducer = queue.lastRenderedReducer;
    const currentState = queue.lastRenderedState;
    const eagerState = lastRenderedReducer(currentState, action);
    update.hasEagerState = true;
    update.eagerState = eagerState;
    if (is(eagerState, currentState)) {
      return;
    }
  }
  const root = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
  const eventTime = requestEventTime();
  scheduleUpdateOnFiber(root, fiber, lane, eventTime);
}
function updateState(initialState) {
  return updateReducer(basicStateReducer, initialState);
}
function mountWorkInProgressHook() {
  const hook = {
    memoizedState: null,
    queue: null,
    next: null,
    baseState: null,
    baseQueue: null,
  };
  if (workInProgressHook <span class="hljs-comment">=== null) {</span>
    currentlyRenderingFiber.memoizedState = workInProgressHook = hook;
  } else {
    workInProgressHook = workInProgressHook.next = hook;
  }
  return workInProgressHook;
}
function dispatchReducerAction(fiber, queue, action) {
  const update = {
    action,
    next: null,
  };
  const root = enqueueConcurrentHookUpdate(fiber, queue, update);
  scheduleUpdateOnFiber(root, fiber);
}

function updateWorkInProgressHook() {
  let nextCurrentHook;
  if (currentHook <span class="hljs-comment">=== null) {</span>
    const current = currentlyRenderingFiber.alternate;
    if (current !== null) {
      nextCurrentHook = current.memoizedState;
    } else {
      nextCurrentHook = null;
    }
  } else {
    nextCurrentHook = currentHook.next;
  }

  let nextWorkInProgressHook;
  if (workInProgressHook <span class="hljs-comment">=== null) {</span>
    nextWorkInProgressHook = currentlyRenderingFiber.memoizedState;
  } else {
    nextWorkInProgressHook = workInProgressHook.next;
  }

  if (nextWorkInProgressHook !== null) {
    workInProgressHook = nextWorkInProgressHook;
    nextWorkInProgressHook = workInProgressHook.next;
    currentHook = nextCurrentHook;
  } else {
    currentHook = nextCurrentHook;
    const newHook = {
      memoizedState: currentHook.memoizedState,
      queue: currentHook.queue,
      next: null,
      baseState: currentHook.baseState,
      baseQueue: currentHook.baseQueue,
    };
    if (workInProgressHook <span class="hljs-comment">=== null) {</span>
      currentlyRenderingFiber.memoizedState = workInProgressHook = newHook;
    } else {
      workInProgressHook = workInProgressHook.next = newHook;
    }
  }
  return workInProgressHook;
}

export function renderWithHooks(current, workInProgress, Component, props, nextRenderLanes) {
  renderLanes = nextRenderLanes;
  currentlyRenderingFiber = workInProgress;
  workInProgress.updateQueue = null;
  workInProgress.memoizedState = null;
  if (current !== null &amp;&amp; current.memoizedState !== null) {
    ReactCurrentDispatcher.current = HooksDispatcherOnUpdateInDEV;
  } else {
    ReactCurrentDispatcher.current = HooksDispatcherOnMountInDEV;
  }
  const children = Component(props);
  currentlyRenderingFiber = null;
  workInProgressHook = null;
  currentHook = null;
  renderLanes = NoLanes;
  return children;
}

function printQueue(queue) {
  const first = queue.next;
  let desc = &apos;&apos;;
  let update = first;
  do {
    desc += (&quot;=&gt;&quot; + (update.action.id));
    update = update.next;
  } while (update !== null &amp;&amp; update !== first);
  desc += &quot;=&gt;null&quot;;
  console.log(desc);
}
</code></pre>
<h3 id="t32342.11 ReactFiberNewContext.js">42.11 ReactFiberNewContext.js <a href="#t32342.11 ReactFiberNewContext.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberNewContext.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pushProvider</span>(<span class="hljs-params">context, nextValue</span>) </span>{
  context._currentValue = nextValue;
}

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">readContext</span>(<span class="hljs-params">context</span>) </span>{
  <span class="hljs-keyword">return</span> context._currentValue;
}
</code></pre>
<h3 id="t32442.12 ReactWorkTags.js">42.12 ReactWorkTags.js <a href="#t32442.12 ReactWorkTags.js"> # </a></h3>
<p>src\react-reconciler\src\ReactWorkTags.js</p>
<pre><code class="lang-diff">export const FunctionComponent = 0;
export const IndeterminateComponent = 2;
export const HostRoot = 3;
export const HostComponent = 5;
export const HostText = 6;
<span class="hljs-addition">+export const ContextProvider = 10;</span>
</code></pre>
<h3 id="t32542.13 ReactSymbols.js">42.13 ReactSymbols.js <a href="#t32542.13 ReactSymbols.js"> # </a></h3>
<p>src\shared\ReactSymbols.js</p>
<pre><code class="lang-diff">export const REACT_ELEMENT_TYPE = Symbol.for(&quot;react.element&quot;);
<span class="hljs-addition">+export const REACT_PROVIDER_TYPE = Symbol.for(&apos;react.provider&apos;);</span>
<span class="hljs-addition">+export const REACT_CONTEXT_TYPE = Symbol.for(&apos;react.context&apos;);</span>
</code></pre>

    </div>
</div>

<script src="./assets/js/jquerymin_1645176580555.js"></script>
<script src="./assets/js/bootstrapmin_1645176554753.js"></script>

<script>
$('.warpper .page-toc ul ul li a').on('click',function(){
  $('.warpper .page-toc ul ul li a').removeClass('my-active')
  $(this).addClass('my-active')
})
$('.logo').on('mouseenter',function(){
  $('.nav').height('450px');
})
$('.nav').on('mouseleave',function(){
  $('.nav').height('80px');
})
$('.logo').on('click',function(){
  $('.nav').css('display','none');
 $('.warpper').css('padding','0px');
})
</script>
</body>
</html>
